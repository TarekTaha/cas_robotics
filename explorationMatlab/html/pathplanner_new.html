
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN">
<html xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   
      <!--
This HTML is auto-generated from an M-file.
To make changes, update the M-file and republish this document.
      -->
      <title>pathplanner_new</title>
      <meta name="generator" content="MATLAB 7.4">
      <meta name="date" content="2008-01-14">
      <meta name="m-file" content="pathplanner_new"><style>

body {
  background-color: white;
  margin:10px;
}

h1 {
  color: #990000; 
  font-size: x-large;
}

h2 {
  color: #990000;
  font-size: medium;
}

/* Make the text shrink to fit narrow windows, but not stretch too far in 
wide windows. */ 
p,h1,h2,div.content div {
  max-width: 600px;
  /* Hack for IE6 */
  width: auto !important; width: 600px;
}

pre.codeinput {
  background: #EEEEEE;
  padding: 10px;
}
@media print {
  pre.codeinput {word-wrap:break-word; width:100%;}
} 

span.keyword {color: #0000FF}
span.comment {color: #228B22}
span.string {color: #A020F0}
span.untermstring {color: #B20000}
span.syscmd {color: #B28C00}

pre.codeoutput {
  color: #666666;
  padding: 10px;
}

pre.error {
  color: red;
}

p.footer {
  text-align: right;
  font-size: xx-small;
  font-weight: lighter;
  font-style: italic;
  color: gray;
}

  </style></head>
   <body>
      <div class="content">
         <h1>pathplanner_new</h1>
         <introduction>
            <p><b>Description:</b>  NEW version of function which goes from where we are at Q to where we want to be at newQ and checks for collisions
            </p>
         </introduction>
         <h2>Contents</h2>
         <div>
            <ul>
               <li><a href="#1">Function Call</a></li>
               <li><a href="#2">Variables</a></li>
               <li><a href="#3">check if we are at the end (exit if we are)</a></li>
               <li><a href="#4">Check passed arguments set defaults where appropriate</a></li>
               <li><a href="#5">check that the initial desired end joint config is safe and possible</a></li>
               <li><a href="#6">Check if there is a direct path</a></li>
               <li><a href="#7">If we are trying to find an alternate end work this out</a></li>
               <li><a href="#8">Go through required number of iterations and try and find a path</a></li>
               <li><a href="#9">FUNCTION: check between a start and end point to see if there is a path</a></li>
               <li><a href="#10">%Additional Combs</a></li>
               <li><a href="#11">FUNCTION: select middleQ with 1st 3 qs rand chosen within bounds</a></li>
               <li><a href="#12">FUNCTION: path_minimise</a></li>
            </ul>
         </div>
         <h2>Function Call<a name="1"></a></h2>
         <p><b>Inputs:</b></p>
         <p><i>newQ</i> (1*6 double) radians - The new joint configuration that want to be in
         </p>
         <p><i>tryalternate</i> (binary) If you want to try and get another possible joint configuration
         </p>
         <p><i>check_arm_perms</i> (binary)  If you want to check each of the joints 1-3 perms for a solution
         </p>
         <p><i>useMiddleQ2</i> (binary) If you want to try and put a second point in from middleQ to end if there is no direct path
         </p>
         <p><i>numofPPiterations</i> (int) This is how many times you want to go through the middleQ paths
         </p>
         <p><i>disON</i> (binary) If you want to see the print outs of the working
         </p>
         <p><b>Returns:</b></p>
         <p><i>pathfound</i> =0 (no path), -1 (not valid newQ), 1 (path found)
         </p>
         <p><i>all_steps</i> = 6 collums of joints * many steps
         </p><pre class="codeinput"><span class="keyword">function</span> [pathfound,all_steps] = pathplanner_new(newQ,tryalternate,check_arm_perms,useMiddleQ2,numofPPiterations,disON)
</pre><h2>Variables<a name="2"></a></h2><pre class="codeinput"><span class="keyword">global</span> r Q optimise workspace

<span class="comment">%intiallise all the steps through the path to empty</span>
all_steps=[];
</pre><h2>check if we are at the end (exit if we are)<a name="3"></a></h2><pre class="codeinput"><span class="keyword">if</span> isempty(find(newQ~=Q, 1))
    pathfound=1;
    <span class="keyword">return</span>;
<span class="keyword">end</span>
</pre><h2>Check passed arguments set defaults where appropriate<a name="4"></a></h2><pre class="codeinput"><span class="keyword">if</span> nargin&lt;6
    disON=false;
    <span class="keyword">if</span> nargin&lt;5
        <span class="comment">%default nu of interations assuming that there IS an alternate solution</span>
        numofPPiterations=optimise.numofPPiterations;
        <span class="keyword">if</span> nargin&lt;4
            <span class="comment">% It will make more than one middle possition and try and reach this</span>
            useMiddleQ2=true;
            <span class="keyword">if</span> nargin&lt;3
                <span class="comment">%if we want to use the different arm movement permutations</span>
                check_arm_perms=true;
                <span class="keyword">if</span> nargin&lt;2
                    <span class="comment">%default is to get an alternate pose just in case</span>
                    tryalternate=true;
                    <span class="keyword">if</span> nargin==0; error(<span class="string">'You must pass at least a newQ value to try and reach from the current (global) Q'</span>);<span class="keyword">end</span>
                <span class="keyword">end</span>
            <span class="keyword">end</span>
        <span class="keyword">end</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">%these are the obstacle point within the arm range that are present during this iteration of path planning</span>
obsticle_points=workspace.indexedobsticles(GetImpLevInfo(workspace.indexedobsticles),:);

<span class="comment">%if we are not going to try and use alternate solution then go through 1/2 amount of times</span>
<span class="keyword">if</span> ~tryalternate
    numofPPiterations=numofPPiterations/2;
<span class="keyword">end</span>

<span class="comment">%what the max angle is or the joints 1,2,3 so we work out steps from this</span>
max_angle_for123=optimise.max_angle_for123;

<span class="comment">%this is parameters of the robot</span>
qlimits=r.qlim;
</pre><h2>check that the initial desired end joint config is safe and possible<a name="5"></a></h2><pre class="codeinput"><span class="keyword">if</span> ~check_path_for_col(newQ,obsticle_points);
    pathfound=-1;
    <span class="keyword">return</span>;
<span class="keyword">end</span>
<span class="comment">% Check joint limits</span>
<span class="keyword">if</span> ~isempty(find(newQ'&lt;qlimits(:,1), 1)) || ~isempty(find(newQ'&gt;qlimits(:,2), 1))
    pathfound=-1;
    <span class="keyword">return</span>;
<span class="keyword">end</span>
</pre><h2>Check if there is a direct path<a name="6"></a></h2><pre class="codeinput">[pathfound,all_steps]=checkdirectpath(Q,newQ,max_angle_for123,check_arm_perms,obsticle_points);
<span class="comment">%since a direct path is possible and safe return with this path</span>
<span class="keyword">if</span> pathfound;
    <span class="keyword">if</span> disON; display(<span class="string">'Complete safe path found-direct'</span>);<span class="keyword">end</span>;
    <span class="keyword">return</span>;
<span class="keyword">end</span>
</pre><h2>If we are trying to find an alternate end work this out<a name="7"></a></h2><pre class="codeinput"><span class="keyword">if</span> tryalternate
    <span class="keyword">try</span>
        requiredT=fkine(r,newQ);
        <span class="keyword">if</span> disON; display(<span class="string">'using new pose selection method which includes collision detection'</span>);<span class="keyword">end</span>
        [alternate_newQ,valid_pose]=streamOnto_mine_manystarts(r,requiredT(1:3,4),requiredT(1:3,3),Q);
        <span class="keyword">if</span> ~valid_pose
            numofPPiterations=numofPPiterations/2;
            tryalternate=0; <span class="comment">%we wont try this section again</span>
            <span class="keyword">if</span> disON; display(<span class="string">'Did not find a valid solution using many starts'</span>);<span class="keyword">end</span>
        <span class="keyword">end</span>
    <span class="keyword">catch</span>
        numofPPiterations=numofPPiterations/2;
        tryalternate=0; <span class="comment">%we wont try this section again</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>
<span class="comment">%try and get a path with the alternate end and same begining</span>
<span class="keyword">if</span> tryalternate
    [pathfound,all_steps]=checkdirectpath(Q,alternate_newQ,max_angle_for123,check_arm_perms,obsticle_points);
    <span class="keyword">if</span> pathfound;
        <span class="keyword">if</span> disON; display(<span class="string">'Complete safe path found'</span>);<span class="keyword">end</span>;
        <span class="keyword">return</span>;
    <span class="keyword">end</span>
<span class="keyword">end</span>
</pre><h2>Go through required number of iterations and try and find a path<a name="8"></a></h2><pre class="codeinput"><span class="keyword">for</span> gothroughtimes=1:numofPPiterations
<span class="keyword">if</span> pathfound==0
    <span class="keyword">if</span> disON;
        display(<span class="string">'%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%'</span>)
        display(strcat(<span class="string">'Currently going through for the:'</span>,num2str(gothroughtimes)));
        display(<span class="string">'-----------------------------------------------'</span>)
    <span class="keyword">end</span>

    <span class="comment">%setup a start Q variable that won't alter the global</span>
    startQ=Q;

    <span class="comment">%this will try the Alternat path on the even numbers for gothroughtimes</span>
    <span class="keyword">if</span> (-1)^(gothroughtimes)==1 &amp;&amp; tryalternate
        endQ=alternate_newQ;
        <span class="keyword">if</span> disON; display(strcat(<span class="string">'Using an alternate end Q:'</span>,num2str(alternate_newQ)));<span class="keyword">end</span>
    <span class="keyword">else</span>
        <span class="comment">% just do the normal endQ which is newQ</span>
        endQ=newQ;
    <span class="keyword">end</span>

    <span class="comment">%this var will hold all the intermediate steps between Q and newQ</span>
    all_steps=startQ;

    <span class="comment">%randomly select a middleQ with first 3 joints randomly chosen between bounds</span>
    middleQ=pick_a_middleQ(startQ,endQ);

    <span class="keyword">if</span> disON; display(strcat(<span class="string">'Splitting path into two parts with middle as:'</span>,num2str(middleQ)));<span class="keyword">end</span>

    [pathfound,all_steps]=checkdirectpath(startQ,middleQ,max_angle_for123,check_arm_perms,obsticle_points);
    <span class="comment">%if no path found found go to the next iteration</span>
    <span class="keyword">if</span> pathfound==0;
        <span class="comment">%else it is a complete failure</span>
        <span class="keyword">if</span> disON; display(<span class="string">'FAILED: path finding failure: couldnt get start-&gt;middle'</span>);<span class="keyword">end</span>;
        <span class="keyword">continue</span>;
    <span class="keyword">else</span>
        <span class="keyword">if</span> disON; display(<span class="string">'With the path now split, we have got halfway, now trying to get whole way'</span>);<span class="keyword">end</span>
        [pathfound,additional_steps]=checkdirectpath(middleQ,endQ,max_angle_for123,check_arm_perms,obsticle_points);
        <span class="keyword">if</span> pathfound==0;
            <span class="keyword">if</span> disON; display(<span class="string">'path finding failure: couldnt get middle-&gt;end'</span>);<span class="keyword">end</span>
            <span class="keyword">if</span> useMiddleQ2
                <span class="comment">%randomly select another middleQ2 between middleQ and endQ</span>
                middleQ2=pick_a_middleQ(middleQ,endQ);
                <span class="keyword">if</span> disON; display(strcat(<span class="string">'Splitting path into 3 parts with middle2 (middle of middle-&gt;end) as:'</span>,num2str(middleQ2)));<span class="keyword">end</span>
                [pathfound_1,additional_steps1]=checkdirectpath(middleQ,middleQ2,max_angle_for123,check_arm_perms,obsticle_points);
                [pathfound_2,additional_steps2]=checkdirectpath(middleQ2,endQ,max_angle_for123,check_arm_perms,obsticle_points);
                <span class="keyword">if</span> pathfound_1 &amp;&amp; pathfound_2
                    all_steps=[all_steps;additional_steps1;additional_steps2];
                    <span class="keyword">if</span> disON; display(<span class="string">'Complete safe path found_with 2 mid points'</span>);<span class="keyword">end</span>;
                    pathfound=1;
                    <span class="keyword">return</span>;
                <span class="keyword">else</span>
                    <span class="comment">%else go on to next path</span>
                    <span class="keyword">if</span> disON; display(<span class="string">'FAILED: path finding failure: couldnt get middle-&gt;middle2 or middle2-&gt;end'</span>);<span class="keyword">end</span>;
                    <span class="keyword">continue</span>; <span class="comment">%to the next itteration</span>
                <span class="keyword">end</span>
            <span class="keyword">else</span> <span class="comment">%we don't want to try and get another point, simple try another</span>
                <span class="keyword">continue</span>;
            <span class="keyword">end</span>
        <span class="keyword">else</span>; all_steps=[all_steps;additional_steps];
            <span class="keyword">if</span> disON; display(<span class="string">'Complete safe path found_with 1 mid point'</span>);<span class="keyword">end</span>;
            <span class="keyword">return</span>;
        <span class="keyword">end</span>
    <span class="keyword">end</span>;

<span class="keyword">else</span> <span class="comment">% asolution has been found so you can break out</span>
    <span class="keyword">break</span>;
<span class="keyword">end</span> <span class="comment">%end the IF path found</span>
<span class="keyword">end</span>; <span class="comment">%end overall for loop for num of iterations</span>
</pre><h2>FUNCTION: check between a start and end point to see if there is a path<a name="9"></a></h2><pre class="codeinput"><span class="keyword">function</span> [pathfound,all_steps]=checkdirectpath(startQ,endQ,max_angle_for123,check_arm_perms,obsticle_points)
<span class="comment">%even if it is half a whole path still start with the startQ</span>
all_steps=startQ;

<span class="comment">%how many increments to go through to get to end</span>
num_inc=ceil(max([abs(endQ(1)-startQ(1))/max_angle_for123(1),<span class="keyword">...</span>
                  abs(endQ(2)-startQ(2))/max_angle_for123(2),<span class="keyword">...</span>
                  abs(endQ(3)-startQ(3))/max_angle_for123(3)]));
<span class="comment">%since we may not be at our destination but only joint 4,5,6 may change and</span>
<span class="comment">%so we will have num_inc==0 so we have to make it go through in atleast 1 step</span>
num_inc=max(num_inc,1);

<span class="comment">%this is the size of the increment values</span>
inc_val=(endQ-startQ)/num_inc;

<span class="comment">%make the path up out of the smaller steps</span>
<span class="keyword">for</span> i=1:num_inc
    all_steps=[all_steps;startQ+i*inc_val];
<span class="keyword">end</span>
<span class="comment">%if the final step is not the actual end then just add it on</span>
<span class="keyword">if</span> ~isempty(find(all_steps(end,:)-endQ~=0)&gt;0)
    all_steps=[all_steps;endQ];
<span class="keyword">end</span>
pathfound=check_path_for_col(all_steps,obsticle_points);
<span class="keyword">if</span> pathfound==1
<span class="comment">%     all_steps=path_minimise(all_steps);</span>
    <span class="keyword">return</span>
<span class="comment">%if we are to go through and check each arm permutation as well for a collsion free path</span>
<span class="keyword">elseif</span> check_arm_perms
    <span class="comment">%calculate new increment value because each angle is separate there is</span>
    <span class="comment">%no need to make so many steps</span>
    <span class="comment">%how many increments to go through to get to end</span>
    num_inc=[abs(endQ(1)-startQ(1))/max_angle_for123(1),<span class="keyword">...</span>
            abs(endQ(2)-startQ(2))/max_angle_for123(2),<span class="keyword">...</span>
            abs(endQ(3)-startQ(3))/max_angle_for123(3)];
    num_inc=[ceil(num_inc),ones([1,3])*ceil(sum(num_inc(1:3)))];
    <span class="keyword">if</span> num_inc==0
        keyboard
    <span class="keyword">end</span>

    <span class="comment">%this is the size of the increment values</span>
    inc_val=(endQ-startQ)./num_inc;
</pre><h2>%Additional Combs<a name="10"></a></h2>
         <p>combs=       1 &amp; 2,3       2 &amp; 3,1       3 &amp; 1,2</p><pre class="codeinput"><span class="comment">%       1,2 &amp; 3</span>
<span class="comment">%       2,3 &amp; 1</span>
<span class="comment">%       3,1 &amp; 2</span>


jointcombs= [1,2,3;2,3,1;3,1,2];
    <span class="comment">%make the path up out of the smaller steps for each of joint individually</span>
    <span class="comment">%Check each per for a path and return if there is one</span>
    <span class="keyword">for</span> firstcombo=1:2
        <span class="keyword">for</span> currentcomb=1:size(jointcombs,1)
            <span class="comment">% work out the first 3 perms</span>
            temp1=[startQ(jointcombs(currentcomb,1)):inc_val((jointcombs(currentcomb,1))):endQ(jointcombs(currentcomb,1))]';
            temp2=[startQ(jointcombs(currentcomb,2)):inc_val((jointcombs(currentcomb,2))):endQ(jointcombs(currentcomb,2))]';
            temp3=[startQ(jointcombs(currentcomb,3)):inc_val((jointcombs(currentcomb,3))):endQ(jointcombs(currentcomb,3))]';
            <span class="comment">%check largest size</span>
            sizetomakeall=max([size(temp1,1),size(temp2,1),size(temp3,1)]);
            <span class="comment">%make all mats same size by populating with end value</span>
            temp1=[temp1;temp1(end)*ones([sizetomakeall-size(temp1,1),1])];
            temp2=[temp2;temp2(end)*ones([sizetomakeall-size(temp2,1),1])];
            temp3=[temp3;temp3(end)*ones([sizetomakeall-size(temp3,1),1])];

            <span class="comment">%Now work out how to combine these</span>
            <span class="comment">% start off with joint 1 which is either to move or the start state</span>
            <span class="keyword">if</span> jointcombs(currentcomb,1)==1
                all_steps=[temp1;<span class="keyword">...</span>
                           temp1(end)*ones([size(temp1,1),1])];
            <span class="keyword">elseif</span> jointcombs(currentcomb,2)==1
                all_steps=[temp2(1)*ones([size(temp2,1),1]);<span class="keyword">...</span>
                            temp2];
            <span class="keyword">elseif</span> jointcombs(currentcomb,3)==1
                all_steps=[temp3(1)*ones([size(temp3,1),1]);<span class="keyword">...</span>
                            temp3];
            <span class="keyword">end</span>
            <span class="comment">%for JOINT2 and JOINT3</span>
            <span class="keyword">for</span> cur_joint=2:3
                <span class="keyword">if</span> jointcombs(currentcomb,1)==cur_joint
                    all_steps=[all_steps,[temp1;<span class="keyword">...</span>
                                         temp1(end)*ones([size(temp1,1),1])]];
                <span class="keyword">elseif</span> firstcombo==2 &amp;&amp; jointcombs(currentcomb,2)==cur_joint
                    all_steps=[all_steps,[temp2;<span class="keyword">...</span>
                                         temp2(end)*ones([size(temp2,1),1])]];
                <span class="keyword">elseif</span> firstcombo==1 &amp;&amp; jointcombs(currentcomb,2)==cur_joint
                    all_steps=[all_steps,[temp2(1)*ones([size(temp2,1),1]);<span class="keyword">...</span>
                                         temp2]];
                <span class="keyword">elseif</span> jointcombs(currentcomb,3)==cur_joint
                    all_steps=[all_steps,[temp3(1)*ones([size(temp3,1),1]);<span class="keyword">...</span>
                                         temp3]];
                <span class="keyword">end</span>
            <span class="keyword">end</span>

            <span class="comment">%fill size of last 3 joints then tac onto all_steps</span>
            <span class="keyword">try</span> <span class="comment">%Joint 4</span>
                temp4=[startQ(4):(endQ(4)-startQ(4))/(size(all_steps,1)-1):endQ(4)]';
                <span class="keyword">if</span> isempty(temp4);temp4=0;<span class="keyword">end</span>
            <span class="keyword">catch</span>
                temp4=0;
            <span class="keyword">end</span>

            <span class="keyword">try</span> <span class="comment">%Joint 5</span>
                temp5=[startQ(5):(endQ(5)-startQ(5))/(size(all_steps,1)-1):endQ(5)]';
                <span class="keyword">if</span> isempty(temp5);temp5=0;<span class="keyword">end</span>
            <span class="keyword">catch</span>
                temp5=0;
            <span class="keyword">end</span>

            <span class="keyword">try</span> <span class="comment">%Joint 5</span>
                temp6=[startQ(6):(endQ(6)-startQ(6))/(size(all_steps,1)-1):endQ(6)]';
                <span class="keyword">if</span> isempty(temp6);temp6=0;<span class="keyword">end</span>
            <span class="keyword">catch</span>
                temp6=0;
            <span class="keyword">end</span>
<span class="comment">%             try</span>
            <span class="comment">% resize 45 and 6 if necessary either up or down</span>
            <span class="keyword">if</span> size(temp4,1)&gt;size(all_steps,1)
                display(<span class="string">'speeding up speed of 4th joint'</span>);
                temp4(size(all_steps,1))=temp4(end);
                temp4=temp4(1:size(all_steps,1));
            <span class="keyword">elseif</span> size(temp4,1)&lt;size(all_steps,1)
                temp4=[temp4;temp4(end)*ones([size(all_steps,1)-size(temp4,1),1])];
            <span class="keyword">end</span>

            <span class="keyword">if</span> size(temp5,1)&gt;size(all_steps,1)
                display(<span class="string">'speeding up speed of 5th joint'</span>);
                temp5(size(all_steps,1))=temp5(end);
                temp5=temp5(1:size(all_steps,1));
            <span class="keyword">elseif</span> size(temp5,1)&lt;size(all_steps,1)
                temp5=[temp5;temp5(end)*ones([size(all_steps,1)-size(temp5,1),1])];
            <span class="keyword">end</span>

            <span class="keyword">if</span> size(temp6,1)&gt;size(all_steps,1)
                display(<span class="string">'speeding up speed of 6th joint'</span>);
                temp6(size(all_steps,1))=temp6(end);
                temp6=temp6(1:size(all_steps,1));
            <span class="keyword">elseif</span> size(temp6,1)&lt;size(all_steps,1)
                temp6=[temp6;temp6(end)*ones([size(all_steps,1)-size(temp6,1),1])];
            <span class="keyword">end</span>
<span class="comment">%             catch;keyboard;end;</span>
            <span class="comment">%put them all together</span>
            all_steps=[all_steps,temp4,temp5,temp6];

            <span class="comment">%get rid of steps where 1,2,3 dont move joint up 4,5,6 before</span>
            <span class="comment">%and after steps also include end position (for safety)</span>
            abspathdiff_bin=abs(all_steps(2:end,1:3)-all_steps(1:end-1,1:3))&gt;eps;
            all_steps=[all_steps(abspathdiff_bin(:,1)|abspathdiff_bin(:,2)|abspathdiff_bin(:,3),:);
                       all_steps(end,:)];
<span class="comment">%             if size(all_steps_temp,1)~=size(all_steps,1)</span>
<span class="comment">%                 display(['Size dif is ',num2str(size(all_steps,1)-size(all_steps_temp,1))]);</span>
<span class="comment">%             end</span>
<span class="comment">%             all_steps=all_steps_temp;</span>

            <span class="comment">%check for collisions</span>
            <span class="keyword">if</span> ~isempty(find(all_steps(end,:)-endQ~=0)&gt;0);all_steps=[all_steps;endQ];<span class="keyword">end</span>
            pathfound=check_path_for_col(all_steps,obsticle_points);
            <span class="keyword">if</span> pathfound==1;
<span class="comment">%                 all_steps=path_minimise(all_steps);</span>
<span class="comment">%                 display('Found a path with combinations');</span>
                <span class="keyword">return</span>;
            <span class="keyword">end</span>
        <span class="keyword">end</span>
    <span class="keyword">end</span>

    <span class="comment">%%end additional</span>





<span class="comment">%%Do perms</span>

    jointperm=perms(1:3);
    <span class="comment">%make the path up out of the smaller steps for each of joint individually</span>
    <span class="comment">%Check each per for a path and return if there is one</span>
    <span class="keyword">for</span> currentperm=1:size(jointperm,1)
        all_steps=startQ;
        <span class="keyword">for</span> jointnum=jointperm(currentperm,:)
            <span class="keyword">for</span> current_inc=1:num_inc(jointnum)
                <span class="keyword">if</span>     jointnum==1; all_steps=[all_steps;all_steps(end,:)+[inc_val(1),0,0,inc_val(4:6)]];
                <span class="keyword">elseif</span> jointnum==2; all_steps=[all_steps;all_steps(end,:)+[0,inc_val(2),0,inc_val(4:6)]];
                <span class="keyword">elseif</span> jointnum==3; all_steps=[all_steps;all_steps(end,:)+[0,0,inc_val(3),inc_val(4:6)]];<span class="keyword">end</span>
            <span class="keyword">end</span>
        <span class="keyword">end</span>
        <span class="keyword">if</span> ~isempty(find(all_steps(end,:)-endQ~=0)&gt;0);all_steps=[all_steps;endQ];<span class="keyword">end</span>
        pathfound=check_path_for_col(all_steps,obsticle_points);
        <span class="keyword">if</span> pathfound==1;
<span class="comment">%             all_steps=path_minimise(all_steps);</span>
            <span class="keyword">return</span>;
        <span class="keyword">end</span>
    <span class="keyword">end</span>







<span class="keyword">end</span>
</pre><h2>FUNCTION: select middleQ with 1st 3 qs rand chosen within bounds<a name="11"></a></h2>
         <p>then the joint4-6 are simply between where they are moving. Keep on going through until to find a valid middle point</p><pre class="codeinput"><span class="keyword">function</span> middleQ=pick_a_middleQ(startQ,endQ)
<span class="keyword">global</span> r workspace densoobj

n = r.n;
L = r.link;
qlimits=r.qlim;

result_row=[0,0,0,0,0,0];
<span class="keyword">while</span> ~isempty(find(result_row==0, 1))
    <span class="comment">%this gets the value for joints 2 and 3 so they are on</span>
    <span class="comment">%oppisite sides of their centers</span>
    randnum=rand();
    <span class="keyword">if</span> randnum&gt;0.5
        randnum=(randnum)^2;
        joint2=randnum;
        joint3=1-randnum;
    <span class="keyword">else</span> <span class="comment">%it is on the other side</span>
        randnum=sqrt(randnum);
        joint2=randnum;
        joint3=1-randnum;
    <span class="keyword">end</span>


    <span class="comment">%%additional</span>
    <span class="keyword">if</span> startQ(1)&lt;0
        <span class="comment">%this will put it on the negative side but close to 0</span>
        J1rand=rand()^6*qlimits(1,1);
    <span class="keyword">elseif</span> startQ(1)&gt;0
        <span class="comment">%this will put it on the negative side but close to 0</span>
        J1rand=rand()^6*qlimits(1,2);
    <span class="keyword">else</span> <span class="comment">%startQ(1)==0</span>
        <span class="keyword">if</span> endQ(1)&lt;0
            J1rand=rand()^6*qlimits(1,1);
        <span class="keyword">elseif</span> endQ(1)&gt;0
            J1rand=rand()^6*qlimits(1,2);
        <span class="keyword">else</span>
            J1rand=0;
        <span class="keyword">end</span>
    <span class="keyword">end</span>
    middleQ=[J1rand,<span class="keyword">...</span>
             joint2*(-qlimits(2,1)+qlimits(2,2))+qlimits(2,1),<span class="keyword">...</span>
             joint3*(-qlimits(3,1)+qlimits(3,2))+qlimits(3,1),<span class="keyword">...</span>
             startQ(4:6) + (endQ(4:6)-startQ(4:6))/2];

         <span class="comment">%commented out this</span>
         <span class="comment">%     middleQ=[rand()*(-qlimits(1,1)+qlimits(1,2))+qlimits(1,1),...</span>
<span class="comment">%              joint2*(-qlimits(2,1)+qlimits(2,2))+qlimits(2,1),...</span>
<span class="comment">%              joint3*(-qlimits(3,1)+qlimits(3,2))+qlimits(3,1),...</span>
<span class="comment">%              startQ(4:6) + (endQ(4:6)-startQ(4:6))/2];</span>

    <span class="comment">%%%%%end additional</span>



t = r.base;
    result_row=[];
    <span class="comment">%make sure the randomly gained solution is not impossible to reach</span>
    <span class="keyword">for</span> piece=1:n
        t = t * L{piece}(middleQ(piece));
        tempresult=check_FF(t,densoobj(piece+1).ellipse,workspace.indexedobsticles);
        result_row=[result_row,tempresult];
        <span class="keyword">if</span> tempresult==0
            <span class="keyword">break</span>; <span class="comment">%break out of for loop since this one is not valid</span>
        <span class="keyword">end</span>
    <span class="keyword">end</span>
<span class="keyword">end</span> <span class="comment">%end while (trying to split path) loop</span>
</pre><h2>FUNCTION: path_minimise<a name="12"></a></h2>
         <p>Go through all paths and if the gradient on one joint goes positive then negative remove the middle crap</p><pre class="codeinput"><span class="keyword">function</span> all_steps=path_minimise(initial_all_steps)
<span class="comment">%intialise return variable</span>
all_steps=initial_all_steps;
initialsize=size(all_steps,1);
<span class="comment">%If there is only one value then it is not a path worth checking</span>
<span class="keyword">if</span> size(all_steps,1)&lt;4
    <span class="keyword">if</span> size(all_steps,1)==0
        keyboard;
    <span class="keyword">end</span>;
<span class="keyword">return</span>;
<span class="keyword">end</span>

<span class="keyword">try</span>
    <span class="comment">%determine path diferential</span>
    pathdiff=all_steps(2:end,:)-all_steps(1:end-1,:);
    pathdoubdiff=pathdiff(2:end,:)-pathdiff(1:end-1,:);
    tworows_diff0_12=find(pathdiff(:,1)==0&amp;pathdiff(:,2)==0);
    tworows_diff0_23=find(pathdiff(:,2)==0&amp;pathdiff(:,3)==0);
    tworows_diff0_13=find(pathdiff(:,1)==0&amp;pathdiff(:,3)==0);
    <span class="keyword">if</span> length(tworows_diff0_12)&gt;2 &amp;&amp; <span class="keyword">...</span>
            ~isempty(find(pathdoubdiff(tworows_diff0_12(1:end-1),3)&gt;eps,1)) &amp;&amp;<span class="keyword">...</span>
            ~isempty(find(pathdoubdiff(tworows_diff0_12(1:end-1),3)&lt;-eps,1))
        display(<span class="string">'maybe path could be shorter J3'</span>);
<span class="comment">%             keyboard;</span>
    <span class="keyword">end</span>
    <span class="keyword">if</span> length(tworows_diff0_23)&gt;2 &amp;&amp;<span class="keyword">...</span>
            ~isempty(find(pathdoubdiff(tworows_diff0_23(1:end-1),1)&gt;eps,1)) &amp;&amp;<span class="keyword">...</span>
            ~isempty(find(pathdoubdiff(tworows_diff0_23(1:end-1),1)&lt;-eps,1))
        display(<span class="string">'maybe path could be shorter J1'</span>);
<span class="comment">%             keyboard;</span>
    <span class="keyword">end</span>
    <span class="keyword">if</span> length(tworows_diff0_13)&gt;2 &amp;&amp;<span class="keyword">...</span>
            ~isempty(find(pathdoubdiff(tworows_diff0_13(1:end-1),2)&gt;eps,1)) &amp;&amp;<span class="keyword">...</span>
            ~isempty(find(pathdoubdiff(tworows_diff0_13(1:end-1),2)&lt;-eps,1))
        display(<span class="string">'maybe path could be shorter J2'</span>);
<span class="comment">%         keyboard;</span>
    <span class="keyword">end</span>
<span class="keyword">catch</span>
    display(<span class="string">'Error in path min func'</span>);
    lasterr
    all_steps=initial_all_steps;
    keyboard
<span class="keyword">end</span>

<span class="keyword">if</span> initialsize~=size(all_steps,1)
    display([<span class="string">'The path size has been reduced from '</span>,num2str(initalsize),<span class="string">' to '</span>,num2str(size(all_steps,1))]);
<span class="keyword">end</span>
</pre><p class="footer"><br>
            Published with MATLAB&reg; 7.4<br></p>
      </div>
      <!--
##### SOURCE BEGIN #####
%% pathplanner_new
%
% *Description:*  NEW version of function which goes from where we are at Q
% to where we want to be at newQ and checks for collisions

%% Function Call
% 
% *Inputs:* 
%
% _newQ_ (1*6 double) radians - The new joint configuration that want to be in
%
% _tryalternate_ (binary) If you want to try and get another possible joint configuration
%
% _check_arm_perms_ (binary)  If you want to check each of the joints 1-3 perms for a solution
%
% _useMiddleQ2_ (binary) If you want to try and put a second point in from middleQ to end if there is no direct path
%
% _numofPPiterations_ (int) This is how many times you want to go through the middleQ paths
%
% _disON_ (binary) If you want to see the print outs of the working
%
% *Returns:* 
%
% _pathfound_ =0 (no path), -1 (not valid newQ), 1 (path found)
%
% _all_steps_ = 6 collums of joints * many steps

function [pathfound,all_steps] = pathplanner_new(newQ,tryalternate,check_arm_perms,useMiddleQ2,numofPPiterations,disON)

%% Variables
global r Q optimise workspace
  
%intiallise all the steps through the path to empty
all_steps=[];

%% check if we are at the end (exit if we are)
if isempty(find(newQ~=Q, 1))
    pathfound=1;
    return;
end

%% Check passed arguments set defaults where appropriate
if nargin<6
    disON=false;
    if nargin<5
        %default nu of interations assuming that there IS an alternate solution
        numofPPiterations=optimise.numofPPiterations;
        if nargin<4
            % It will make more than one middle possition and try and reach this
            useMiddleQ2=true;
            if nargin<3        
                %if we want to use the different arm movement permutations
                check_arm_perms=true;
                if nargin<2
                    %default is to get an alternate pose just in case
                    tryalternate=true;
                    if nargin==0; error('You must pass at least a newQ value to try and reach from the current (global) Q');end
                end
            end
        end
    end
end

%these are the obstacle point within the arm range that are present during this iteration of path planning
obsticle_points=workspace.indexedobsticles(GetImpLevInfo(workspace.indexedobsticles),:);

%if we are not going to try and use alternate solution then go through 1/2 amount of times
if ~tryalternate
    numofPPiterations=numofPPiterations/2;
end

%what the max angle is or the joints 1,2,3 so we work out steps from this
max_angle_for123=optimise.max_angle_for123;

%this is parameters of the robot
qlimits=r.qlim;

%% check that the initial desired end joint config is safe and possible
if ~check_path_for_col(newQ,obsticle_points); 
    pathfound=-1; 
    return; 
end
% Check joint limits
if ~isempty(find(newQ'<qlimits(:,1), 1)) || ~isempty(find(newQ'>qlimits(:,2), 1))
    pathfound=-1;
    return;
end
   
%% Check if there is a direct path
[pathfound,all_steps]=checkdirectpath(Q,newQ,max_angle_for123,check_arm_perms,obsticle_points);
%since a direct path is possible and safe return with this path
if pathfound; 
    if disON; display('Complete safe path found-direct');end; 
    return; 
end

%% If we are trying to find an alternate end work this out
if tryalternate
    try 
        requiredT=fkine(r,newQ);
        if disON; display('using new pose selection method which includes collision detection');end
        [alternate_newQ,valid_pose]=streamOnto_mine_manystarts(r,requiredT(1:3,4),requiredT(1:3,3),Q);
        if ~valid_pose 
            numofPPiterations=numofPPiterations/2;
            tryalternate=0; %we wont try this section again
            if disON; display('Did not find a valid solution using many starts');end        
        end            
    catch
        numofPPiterations=numofPPiterations/2;
        tryalternate=0; %we wont try this section again
    end
end
%try and get a path with the alternate end and same begining
if tryalternate
    [pathfound,all_steps]=checkdirectpath(Q,alternate_newQ,max_angle_for123,check_arm_perms,obsticle_points);
    if pathfound; 
        if disON; display('Complete safe path found');end; 
        return; 
    end
end


%% Go through required number of iterations and try and find a path
for gothroughtimes=1:numofPPiterations    
if pathfound==0
    if disON; 
        display('%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%')
        display(strcat('Currently going through for the:',num2str(gothroughtimes)));
        display('REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-')
    end

    %setup a start Q variable that won't alter the global
    startQ=Q;
       
    %this will try the Alternat path on the even numbers for gothroughtimes
    if (-1)^(gothroughtimes)==1 && tryalternate
        endQ=alternate_newQ;
        if disON; display(strcat('Using an alternate end Q:',num2str(alternate_newQ)));end
    else
        % just do the normal endQ which is newQ
        endQ=newQ;
    end    

    %this var will hold all the intermediate steps between Q and newQ
    all_steps=startQ;  
    
    %randomly select a middleQ with first 3 joints randomly chosen between bounds
    middleQ=pick_a_middleQ(startQ,endQ);

    if disON; display(strcat('Splitting path into two parts with middle as:',num2str(middleQ)));end
    
    [pathfound,all_steps]=checkdirectpath(startQ,middleQ,max_angle_for123,check_arm_perms,obsticle_points);    
    %if no path found found go to the next iteration
    if pathfound==0; 
        %else it is a complete failure
        if disON; display('FAILED: path finding failure: couldnt get start->middle');end; 
        continue; 
    else
        if disON; display('With the path now split, we have got halfway, now trying to get whole way');end
        [pathfound,additional_steps]=checkdirectpath(middleQ,endQ,max_angle_for123,check_arm_perms,obsticle_points);
        if pathfound==0; 
            if disON; display('path finding failure: couldnt get middle->end');end
            if useMiddleQ2
                %randomly select another middleQ2 between middleQ and endQ
                middleQ2=pick_a_middleQ(middleQ,endQ);
                if disON; display(strcat('Splitting path into 3 parts with middle2 (middle of middle->end) as:',num2str(middleQ2)));end
                [pathfound_1,additional_steps1]=checkdirectpath(middleQ,middleQ2,max_angle_for123,check_arm_perms,obsticle_points); 
                [pathfound_2,additional_steps2]=checkdirectpath(middleQ2,endQ,max_angle_for123,check_arm_perms,obsticle_points);            
                if pathfound_1 && pathfound_2
                    all_steps=[all_steps;additional_steps1;additional_steps2];
                    if disON; display('Complete safe path found_with 2 mid points');end; 
                    pathfound=1;
                    return;
                else               
                    %else go on to next path
                    if disON; display('FAILED: path finding failure: couldnt get middle->middle2 or middle2->end');end;
                    continue; %to the next itteration
                end
            else %we don't want to try and get another point, simple try another
                continue;
            end
        else; all_steps=[all_steps;additional_steps];
            if disON; display('Complete safe path found_with 1 mid point');end; 
            return;
        end
    end;     

else % asolution has been found so you can break out
    break;
end %end the IF path found
end; %end overall for loop for num of iterations

   
%% FUNCTION: check between a start and end point to see if there is a path
function [pathfound,all_steps]=checkdirectpath(startQ,endQ,max_angle_for123,check_arm_perms,obsticle_points)
%even if it is half a whole path still start with the startQ
all_steps=startQ;

%how many increments to go through to get to end
num_inc=ceil(max([abs(endQ(1)-startQ(1))/max_angle_for123(1),...
                  abs(endQ(2)-startQ(2))/max_angle_for123(2),...
                  abs(endQ(3)-startQ(3))/max_angle_for123(3)]));
%since we may not be at our destination but only joint 4,5,6 may change and
%so we will have num_inc==0 so we have to make it go through in atleast 1 step
num_inc=max(num_inc,1);

%this is the size of the increment values
inc_val=(endQ-startQ)/num_inc;

%make the path up out of the smaller steps
for i=1:num_inc
    all_steps=[all_steps;startQ+i*inc_val];
end
%if the final step is not the actual end then just add it on
if ~isempty(find(all_steps(end,:)-endQ~=0)>0)
    all_steps=[all_steps;endQ];
end
pathfound=check_path_for_col(all_steps,obsticle_points);
if pathfound==1
%     all_steps=path_minimise(all_steps);
    return
%if we are to go through and check each arm permutation as well for a collsion free path 
elseif check_arm_perms
    %calculate new increment value because each angle is separate there is
    %no need to make so many steps
    %how many increments to go through to get to end
    num_inc=[abs(endQ(1)-startQ(1))/max_angle_for123(1),...
            abs(endQ(2)-startQ(2))/max_angle_for123(2),...
            abs(endQ(3)-startQ(3))/max_angle_for123(3)];
    num_inc=[ceil(num_inc),ones([1,3])*ceil(sum(num_inc(1:3)))];
    if num_inc==0
        keyboard
    end

    %this is the size of the increment values
    inc_val=(endQ-startQ)./num_inc;

%% %Additional Combs
% combs=
%       1 & 2,3
%       2 & 3,1
%       3 & 1,2

%       1,2 & 3
%       2,3 & 1
%       3,1 & 2


jointcombs= [1,2,3;2,3,1;3,1,2];
    %make the path up out of the smaller steps for each of joint individually
    %Check each per for a path and return if there is one
    for firstcombo=1:2
        for currentcomb=1:size(jointcombs,1)
            % work out the first 3 perms
            temp1=[startQ(jointcombs(currentcomb,1)):inc_val((jointcombs(currentcomb,1))):endQ(jointcombs(currentcomb,1))]';
            temp2=[startQ(jointcombs(currentcomb,2)):inc_val((jointcombs(currentcomb,2))):endQ(jointcombs(currentcomb,2))]';
            temp3=[startQ(jointcombs(currentcomb,3)):inc_val((jointcombs(currentcomb,3))):endQ(jointcombs(currentcomb,3))]';
            %check largest size
            sizetomakeall=max([size(temp1,1),size(temp2,1),size(temp3,1)]);
            %make all mats same size by populating with end value
            temp1=[temp1;temp1(end)*ones([sizetomakeall-size(temp1,1),1])];
            temp2=[temp2;temp2(end)*ones([sizetomakeall-size(temp2,1),1])];
            temp3=[temp3;temp3(end)*ones([sizetomakeall-size(temp3,1),1])];

            %Now work out how to combine these
            % start off with joint 1 which is either to move or the start state
            if jointcombs(currentcomb,1)==1
                all_steps=[temp1;...
                           temp1(end)*ones([size(temp1,1),1])];
            elseif jointcombs(currentcomb,2)==1
                all_steps=[temp2(1)*ones([size(temp2,1),1]);...
                            temp2];
            elseif jointcombs(currentcomb,3)==1
                all_steps=[temp3(1)*ones([size(temp3,1),1]);...
                            temp3];
            end
            %for JOINT2 and JOINT3
            for cur_joint=2:3
                if jointcombs(currentcomb,1)==cur_joint 
                    all_steps=[all_steps,[temp1;...
                                         temp1(end)*ones([size(temp1,1),1])]];
                elseif firstcombo==2 && jointcombs(currentcomb,2)==cur_joint
                    all_steps=[all_steps,[temp2;...
                                         temp2(end)*ones([size(temp2,1),1])]];
                elseif firstcombo==1 && jointcombs(currentcomb,2)==cur_joint
                    all_steps=[all_steps,[temp2(1)*ones([size(temp2,1),1]);...
                                         temp2]];
                elseif jointcombs(currentcomb,3)==cur_joint
                    all_steps=[all_steps,[temp3(1)*ones([size(temp3,1),1]);...
                                         temp3]];
                end
            end
            
            %fill size of last 3 joints then tac onto all_steps
            try %Joint 4
                temp4=[startQ(4):(endQ(4)-startQ(4))/(size(all_steps,1)-1):endQ(4)]';
                if isempty(temp4);temp4=0;end
            catch
                temp4=0;
            end

            try %Joint 5
                temp5=[startQ(5):(endQ(5)-startQ(5))/(size(all_steps,1)-1):endQ(5)]';
                if isempty(temp5);temp5=0;end
            catch
                temp5=0;
            end

            try %Joint 5
                temp6=[startQ(6):(endQ(6)-startQ(6))/(size(all_steps,1)-1):endQ(6)]';
                if isempty(temp6);temp6=0;end
            catch
                temp6=0;
            end
%             try
            % resize 45 and 6 if necessary either up or down
            if size(temp4,1)>size(all_steps,1)
                display('speeding up speed of 4th joint');
                temp4(size(all_steps,1))=temp4(end);
                temp4=temp4(1:size(all_steps,1));
            elseif size(temp4,1)<size(all_steps,1)
                temp4=[temp4;temp4(end)*ones([size(all_steps,1)-size(temp4,1),1])];
            end

            if size(temp5,1)>size(all_steps,1)
                display('speeding up speed of 5th joint');
                temp5(size(all_steps,1))=temp5(end);
                temp5=temp5(1:size(all_steps,1));
            elseif size(temp5,1)<size(all_steps,1)
                temp5=[temp5;temp5(end)*ones([size(all_steps,1)-size(temp5,1),1])];
            end

            if size(temp6,1)>size(all_steps,1)
                display('speeding up speed of 6th joint');
                temp6(size(all_steps,1))=temp6(end);
                temp6=temp6(1:size(all_steps,1));
            elseif size(temp6,1)<size(all_steps,1)
                temp6=[temp6;temp6(end)*ones([size(all_steps,1)-size(temp6,1),1])];
            end
%             catch;keyboard;end;
            %put them all together
            all_steps=[all_steps,temp4,temp5,temp6];
            
            %get rid of steps where 1,2,3 dont move joint up 4,5,6 before
            %and after steps also include end position (for safety)
            abspathdiff_bin=abs(all_steps(2:end,1:3)-all_steps(1:end-1,1:3))>eps;
            all_steps=[all_steps(abspathdiff_bin(:,1)|abspathdiff_bin(:,2)|abspathdiff_bin(:,3),:);
                       all_steps(end,:)];
%             if size(all_steps_temp,1)~=size(all_steps,1)
%                 display(['Size dif is ',num2str(size(all_steps,1)-size(all_steps_temp,1))]);
%             end
%             all_steps=all_steps_temp;
            
            %check for collisions
            if ~isempty(find(all_steps(end,:)-endQ~=0)>0);all_steps=[all_steps;endQ];end
            pathfound=check_path_for_col(all_steps,obsticle_points);
            if pathfound==1; 
%                 all_steps=path_minimise(all_steps);
%                 display('Found a path with combinations');
                return; 
            end
        end        
    end

    %%end additional
    
    
    
    
    
%%Do perms    
    
    jointperm=perms(1:3);
    %make the path up out of the smaller steps for each of joint individually
    %Check each per for a path and return if there is one
    for currentperm=1:size(jointperm,1)
        all_steps=startQ;
        for jointnum=jointperm(currentperm,:)                      
            for current_inc=1:num_inc(jointnum)
                if     jointnum==1; all_steps=[all_steps;all_steps(end,:)+[inc_val(1),0,0,inc_val(4:6)]];
                elseif jointnum==2; all_steps=[all_steps;all_steps(end,:)+[0,inc_val(2),0,inc_val(4:6)]];
                elseif jointnum==3; all_steps=[all_steps;all_steps(end,:)+[0,0,inc_val(3),inc_val(4:6)]];end                
            end
        end
        if ~isempty(find(all_steps(end,:)-endQ~=0)>0);all_steps=[all_steps;endQ];end
        pathfound=check_path_for_col(all_steps,obsticle_points);
        if pathfound==1; 
%             all_steps=path_minimise(all_steps);
            return; 
        end
    end        
    
    
    
    
    
    
    
end

%% FUNCTION: select middleQ with 1st 3 qs rand chosen within bounds 
% then the joint4-6 are simply between where they are moving. Keep on going
% through until to find a valid middle point
function middleQ=pick_a_middleQ(startQ,endQ)
global r workspace densoobj

n = r.n;
L = r.link;
qlimits=r.qlim;

result_row=[0,0,0,0,0,0];
while ~isempty(find(result_row==0, 1))
    %this gets the value for joints 2 and 3 so they are on
    %oppisite sides of their centers
    randnum=rand();
    if randnum>0.5
        randnum=(randnum)^2;
        joint2=randnum;
        joint3=1-randnum;
    else %it is on the other side
        randnum=sqrt(randnum);
        joint2=randnum;
        joint3=1-randnum;
    end
    
    
    %%additional
    if startQ(1)<0
        %this will put it on the negative side but close to 0
        J1rand=rand()^6*qlimits(1,1);
    elseif startQ(1)>0
        %this will put it on the negative side but close to 0
        J1rand=rand()^6*qlimits(1,2);
    else %startQ(1)==0
        if endQ(1)<0
            J1rand=rand()^6*qlimits(1,1);
        elseif endQ(1)>0
            J1rand=rand()^6*qlimits(1,2);
        else
            J1rand=0;
        end
    end
    middleQ=[J1rand,...
             joint2*(-qlimits(2,1)+qlimits(2,2))+qlimits(2,1),...
             joint3*(-qlimits(3,1)+qlimits(3,2))+qlimits(3,1),...
             startQ(4:6) + (endQ(4:6)-startQ(4:6))/2];

         %commented out this
         %     middleQ=[rand()*(-qlimits(1,1)+qlimits(1,2))+qlimits(1,1),...
%              joint2*(-qlimits(2,1)+qlimits(2,2))+qlimits(2,1),...
%              joint3*(-qlimits(3,1)+qlimits(3,2))+qlimits(3,1),...
%              startQ(4:6) + (endQ(4:6)-startQ(4:6))/2];

    %%%%%end additional
    
    

t = r.base;
    result_row=[];
    %make sure the randomly gained solution is not impossible to reach
    for piece=1:n
        t = t * L{piece}(middleQ(piece));
        tempresult=check_FF(t,densoobj(piece+1).ellipse,workspace.indexedobsticles);                
        result_row=[result_row,tempresult];
        if tempresult==0
            break; %break out of for loop since this one is not valid
        end
    end
end %end while (trying to split path) loop

%% FUNCTION: path_minimise
% Go through all paths and if the gradient on one joint goes positive then
% negative remove the middle crap
function all_steps=path_minimise(initial_all_steps)
%intialise return variable
all_steps=initial_all_steps;
initialsize=size(all_steps,1);
%If there is only one value then it is not a path worth checking
if size(all_steps,1)<4
    if size(all_steps,1)==0
        keyboard;
    end;
return;
end

try
    %determine path diferential
    pathdiff=all_steps(2:end,:)-all_steps(1:end-1,:);
    pathdoubdiff=pathdiff(2:end,:)-pathdiff(1:end-1,:);
    tworows_diff0_12=find(pathdiff(:,1)==0&pathdiff(:,2)==0);
    tworows_diff0_23=find(pathdiff(:,2)==0&pathdiff(:,3)==0);
    tworows_diff0_13=find(pathdiff(:,1)==0&pathdiff(:,3)==0);
    if length(tworows_diff0_12)>2 && ...
            ~isempty(find(pathdoubdiff(tworows_diff0_12(1:end-1),3)>eps,1)) &&...
            ~isempty(find(pathdoubdiff(tworows_diff0_12(1:end-1),3)<-eps,1))
        display('maybe path could be shorter J3');
%             keyboard;
    end
    if length(tworows_diff0_23)>2 &&...
            ~isempty(find(pathdoubdiff(tworows_diff0_23(1:end-1),1)>eps,1)) &&...
            ~isempty(find(pathdoubdiff(tworows_diff0_23(1:end-1),1)<-eps,1))
        display('maybe path could be shorter J1');
%             keyboard;           
    end
    if length(tworows_diff0_13)>2 &&...
            ~isempty(find(pathdoubdiff(tworows_diff0_13(1:end-1),2)>eps,1)) &&...
            ~isempty(find(pathdoubdiff(tworows_diff0_13(1:end-1),2)<-eps,1))
        display('maybe path could be shorter J2');    
%         keyboard;
    end
catch
    display('Error in path min func');
    lasterr
    all_steps=initial_all_steps;
    keyboard
end

if initialsize~=size(all_steps,1)
    display(['The path size has been reduced from ',num2str(initalsize),' to ',num2str(size(all_steps,1))]);
end

##### SOURCE END #####
-->
   </body>
</html>