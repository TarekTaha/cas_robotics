
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN">
<html xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   
      <!--
This HTML is auto-generated from an M-file.
To make changes, update the M-file and republish this document.
      -->
      <title>calc_all_views</title>
      <meta name="generator" content="MATLAB 7.4">
      <meta name="date" content="2008-01-14">
      <meta name="m-file" content="calc_all_views"><style>

body {
  background-color: white;
  margin:10px;
}

h1 {
  color: #990000; 
  font-size: x-large;
}

h2 {
  color: #990000;
  font-size: medium;
}

/* Make the text shrink to fit narrow windows, but not stretch too far in 
wide windows. */ 
p,h1,h2,div.content div {
  max-width: 600px;
  /* Hack for IE6 */
  width: auto !important; width: 600px;
}

pre.codeinput {
  background: #EEEEEE;
  padding: 10px;
}
@media print {
  pre.codeinput {word-wrap:break-word; width:100%;}
} 

span.keyword {color: #0000FF}
span.comment {color: #228B22}
span.string {color: #A020F0}
span.untermstring {color: #B20000}
span.syscmd {color: #B28C00}

pre.codeoutput {
  color: #666666;
  padding: 10px;
}

pre.error {
  color: red;
}

p.footer {
  text-align: right;
  font-size: xx-small;
  font-weight: lighter;
  font-style: italic;
  color: gray;
}

  </style></head>
   <body>
      <div class="content">
         <h1>calc_all_views</h1>
         <introduction>
            <p><b>Description:</b>  This function goes through all the poses discretely and looks to see which ones give most innformation saves in a file that
               could be used by NBV_beta
            </p>
         </introduction>
         <h2>Contents</h2>
         <div>
            <ul>
               <li><a href="#1">Function Call</a></li>
               <li><a href="#2">Variables</a></li>
               <li><a href="#3">Go through the joints at discrete positions</a></li>
               <li><a href="#4">Display Results - currently commented</a></li>
            </ul>
         </div>
         <h2>Function Call<a name="1"></a></h2>
         <p><b>Inputs:</b> NULL
         </p>
         <p><b>Returns:</b> NULL
         </p><pre class="codeinput"><span class="keyword">function</span> calc_all_views()
</pre><h2>Variables<a name="2"></a></h2>
         <p>clear the plots and global bestviews variable</p><pre class="codeinput">clear <span class="string">global</span> <span class="string">bestviews</span>;

<span class="comment">%this starts the timer</span>
tic

<span class="keyword">global</span> Q r workspace robot_maxreach;

<span class="comment">%tempory make global Q something else</span>
actualQ=Q;
Q=robot_maxreach.default_Q(end,:);

<span class="comment">%actually will go through first step and then this many more</span>
numNBVanglesteps=6;
qlimit=r.qlim;
<span class="comment">%taking 10 deg off either side so we don't use the max range for these joints</span>
qlimit(1:3,1)=qlimit(1:3,1)+10*pi/180;
qlimit(1:3,2)=qlimit(1:3,2)-10*pi/180;


indexed_knowncoords=round(setdiff(workspace.knowncoords(GetImpLevInfo(workspace.knowncoords),:),workspace.indexedobsticles,<span class="string">'rows'</span>)/workspace.inc_size);

<span class="comment">%this makes the check for a collision quicker</span>
obsticle_points=workspace.indexedobsticles(GetImpLevInfo(workspace.indexedobsticles),:);

<span class="comment">%%STARTADDED</span>
<span class="comment">%Additional (unknown info)</span>
all_possible=round(   workspace.unknowncoords(workspace.lev1unknown   ,:)/workspace.inc_size);
[nothing,index]=setdiff(all_possible,[indexed_knowncoords;obsticle_points],<span class="string">'rows'</span>);
unknown_points=workspace.unknowncoords(workspace.lev1unknown(index),:);
<span class="comment">%%ENDADDED</span>

unknownweight=calunknownweight();

q1=qlimit(1,1):(qlimit(1,2)-qlimit(1,1))/numNBVanglesteps:qlimit(1,2);
q2=qlimit(2,1):(qlimit(2,2)-qlimit(2,1))/numNBVanglesteps:qlimit(2,2);
q3=qlimit(3,1):(qlimit(3,2)-qlimit(3,1))/numNBVanglesteps:qlimit(3,2);
q4=[-135,-45,135,45]*pi/180;

total_size=size(q1,2)*size(q2,2)*size(q3,2)*size(q4,2)*2;

all_views.result=zeros([total_size,1]);
all_views.newQ=zeros([total_size,6]);
all_views.tr=zeros([total_size,4,4]);
all_views.scanorigin=zeros([total_size,3]);
all_views.path(total_size).valid=0;
all_views.path(total_size).path=zeros([2,6]);

count=1;
</pre><h2>Go through the joints at discrete positions<a name="3"></a></h2><pre class="codeinput"><span class="keyword">for</span> J1=q1
    <span class="keyword">for</span> J2=q2
        <span class="keyword">for</span> J3=q3
            <span class="comment">%Check collision which also checks soft mostion limit which we can't exceed</span>
            [obstacle_result,unknown_result]=check_path_for_col([J1,J2,J3,0,0,0],obsticle_points,unknown_points);
            <span class="keyword">if</span> ~obstacle_result <span class="comment">%leave it at 0 then get out of this IF</span>
                <span class="comment">%all_views.result(count:count+7)=0*ones([8,1]);</span>
            <span class="keyword">elseif</span> ~unknown_result <span class="comment">%we are in unknown space</span>
                all_views.result(count:count+7)=-1*ones([8,1]);
            <span class="keyword">else</span> <span class="comment">%no problem</span>
                all_views.result(count:count+7)=1*ones([8,1]);
            <span class="keyword">end</span>

            <span class="comment">%predefinedJ4's since we don't really need the whole range of movement</span>
            <span class="keyword">for</span> J4=q4
                <span class="comment">%Sets up the limits (possible poses) of J5</span>
                <span class="comment">%depending on J3</span>
                <span class="keyword">if</span> J3&gt;150*pi/180;  J5s_to_go_through=[-60,30]*pi/180;
                <span class="keyword">else</span> J5s_to_go_through=[-45,45]*pi/180; <span class="keyword">end</span>
                <span class="keyword">for</span> J5=J5s_to_go_through
                    all_views.newQ(count,:)=[J1,J2,J3,J4,J5,0];
                    <span class="comment">%if we haven't already done this pose before</span>
                    all_views.tr(count,:,:)=fkine(r,all_views.newQ(count,:));
                    all_views.scanorigin(count,:)=round(all_views.tr(count,1:3,4)/workspace.inc_size)*workspace.inc_size;
                    all_views.expectedaddinfo(count).vals=nbv_volume(squeeze(all_views.tr(count,:,:)),all_views.newQ(count,:));

                    <span class="comment">%recheck if we have said it is safe</span>
                    <span class="keyword">if</span> all_views.result(count)==1
                        [obstacle_result,unknown_result]=check_path_for_col(all_views.newQ(count,:),obsticle_points,unknown_points);
                        <span class="keyword">if</span> ~obstacle_result
                            all_views.result(count)=0;
                        <span class="keyword">elseif</span> ~unknown_result <span class="comment">%we are in unknown space</span>
                            all_views.result(count)=-1;
                        <span class="keyword">end</span>
                    <span class="keyword">end</span>
                    <span class="comment">%could be on known free or unknown spot</span>

                    <span class="keyword">if</span> all_views.result(count)~=0
                        [all_views.path(count).valid,all_views.path(count).all_steps]=pathplanner_new(all_views.newQ(count,:),false,true,true,30);
                    <span class="keyword">end</span>

                    <span class="comment">%update the count</span>
                    count=count+1;
                <span class="keyword">end</span>
            <span class="keyword">end</span>
        <span class="keyword">end</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">%delete all unneeded ones</span>
all_views=remove_all_views_result0(all_views);

save(<span class="string">'all_views.mat'</span>,<span class="string">'all_views'</span>);
</pre><h2>Display Results - currently commented<a name="4"></a></h2><pre class="codeinput">toc

<span class="comment">%put back global Q to its actual spot</span>
Q=actualQ;
</pre><p class="footer"><br>
            Published with MATLAB&reg; 7.4<br></p>
      </div>
      <!--
##### SOURCE BEGIN #####
%% calc_all_views
%
% *Description:*  This function goes through all the poses discretely and
% looks to see which ones give most innformation saves in a file that could
% be used by NBV_beta

%% Function Call
%
% *Inputs:* NULL
%
% *Returns:* NULL

function calc_all_views()

%% Variables
% clear the plots and global bestviews variable
clear global bestviews;

%this starts the timer
tic

global Q r workspace robot_maxreach;

%tempory make global Q something else
actualQ=Q;
Q=robot_maxreach.default_Q(end,:);

%actually will go through first step and then this many more 
numNBVanglesteps=6;
qlimit=r.qlim;
%taking 10 deg off either side so we don't use the max range for these joints
qlimit(1:3,1)=qlimit(1:3,1)+10*pi/180;
qlimit(1:3,2)=qlimit(1:3,2)-10*pi/180;


indexed_knowncoords=round(setdiff(workspace.knowncoords(GetImpLevInfo(workspace.knowncoords),:),workspace.indexedobsticles,'rows')/workspace.inc_size);

%this makes the check for a collision quicker
obsticle_points=workspace.indexedobsticles(GetImpLevInfo(workspace.indexedobsticles),:);

%%STARTADDED
%Additional (unknown info)
all_possible=round(   workspace.unknowncoords(workspace.lev1unknown   ,:)/workspace.inc_size);
[nothing,index]=setdiff(all_possible,[indexed_knowncoords;obsticle_points],'rows');
unknown_points=workspace.unknowncoords(workspace.lev1unknown(index),:);
%%ENDADDED

unknownweight=calunknownweight();

q1=qlimit(1,1):(qlimit(1,2)-qlimit(1,1))/numNBVanglesteps:qlimit(1,2);
q2=qlimit(2,1):(qlimit(2,2)-qlimit(2,1))/numNBVanglesteps:qlimit(2,2);
q3=qlimit(3,1):(qlimit(3,2)-qlimit(3,1))/numNBVanglesteps:qlimit(3,2);
q4=[-135,-45,135,45]*pi/180;

total_size=size(q1,2)*size(q2,2)*size(q3,2)*size(q4,2)*2;

all_views.result=zeros([total_size,1]);
all_views.newQ=zeros([total_size,6]);
all_views.tr=zeros([total_size,4,4]);
all_views.scanorigin=zeros([total_size,3]);
all_views.path(total_size).valid=0;
all_views.path(total_size).path=zeros([2,6]);

count=1;
%% Go through the joints at discrete positions
for J1=q1
    for J2=q2
        for J3=q3
            %Check collision which also checks soft mostion limit which we can't exceed  
            [obstacle_result,unknown_result]=check_path_for_col([J1,J2,J3,0,0,0],obsticle_points,unknown_points);
            if ~obstacle_result %leave it at 0 then get out of this IF                                   
                %all_views.result(count:count+7)=0*ones([8,1]);
            elseif ~unknown_result %we are in unknown space
                all_views.result(count:count+7)=-1*ones([8,1]);
            else %no problem
                all_views.result(count:count+7)=1*ones([8,1]);
            end

            %predefinedJ4's since we don't really need the whole range of movement
            for J4=q4
                %Sets up the limits (possible poses) of J5
                %depending on J3
                if J3>150*pi/180;  J5s_to_go_through=[-60,30]*pi/180; 
                else J5s_to_go_through=[-45,45]*pi/180; end                
                for J5=J5s_to_go_through                        
                    all_views.newQ(count,:)=[J1,J2,J3,J4,J5,0];
                    %if we haven't already done this pose before
                    all_views.tr(count,:,:)=fkine(r,all_views.newQ(count,:));                                    
                    all_views.scanorigin(count,:)=round(all_views.tr(count,1:3,4)/workspace.inc_size)*workspace.inc_size;
                    all_views.expectedaddinfo(count).vals=nbv_volume(squeeze(all_views.tr(count,:,:)),all_views.newQ(count,:));
                    
                    %recheck if we have said it is safe
                    if all_views.result(count)==1
                        [obstacle_result,unknown_result]=check_path_for_col(all_views.newQ(count,:),obsticle_points,unknown_points);
                        if ~obstacle_result
                            all_views.result(count)=0;
                        elseif ~unknown_result %we are in unknown space
                            all_views.result(count)=-1;
                        end                        
                    end
                    %could be on known free or unknown spot
                    
                    if all_views.result(count)~=0
                        [all_views.path(count).valid,all_views.path(count).all_steps]=pathplanner_new(all_views.newQ(count,:),false,true,true,30);
                    end
                    
                    %update the count
                    count=count+1;
                end
            end
        end
    end
end

%delete all unneeded ones
all_views=remove_all_views_result0(all_views);

save('all_views.mat','all_views');

%% Display Results - currently commented
toc

%put back global Q to its actual spot
Q=actualQ;
##### SOURCE END #####
-->
   </body>
</html>