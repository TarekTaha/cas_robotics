
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN">
<html xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   
      <!--
This HTML is auto-generated from an M-file.
To make changes, update the M-file and republish this document.
      -->
      <title>Block_Classifier</title>
      <meta name="generator" content="MATLAB 7.4">
      <meta name="date" content="2007-10-10">
      <meta name="m-file" content="Block_Classifier"><style>

body {
  background-color: white;
  margin:10px;
}

h1 {
  color: #990000; 
  font-size: x-large;
}

h2 {
  color: #990000;
  font-size: medium;
}

/* Make the text shrink to fit narrow windows, but not stretch too far in 
wide windows. */ 
p,h1,h2,div.content div {
  max-width: 600px;
  /* Hack for IE6 */
  width: auto !important; width: 600px;
}

pre.codeinput {
  background: #EEEEEE;
  padding: 10px;
}
@media print {
  pre.codeinput {word-wrap:break-word; width:100%;}
} 

span.keyword {color: #0000FF}
span.comment {color: #228B22}
span.string {color: #A020F0}
span.untermstring {color: #B20000}
span.syscmd {color: #B28C00}

pre.codeoutput {
  color: #666666;
  padding: 10px;
}

pre.error {
  color: red;
}

p.footer {
  text-align: right;
  font-size: xx-small;
  font-weight: lighter;
  font-style: italic;
  color: gray;
}

  </style></head>
   <body>
      <div class="content">
         <h2>Contents</h2>
         <div>
            <ul>
               <li><a href="#2">Flags</a></li>
               <li><a href="#3">Find surfaces in the point cloud</a></li>
               <li><a href="#4">The hokuyo uses the last data for a ray if no return is recieved - This</a></li>
               <li><a href="#5">Edge detecting in IntensityData image</a></li>
               <li><a href="#6">Init's classification result matrix and does classify</a></li>
               <li><a href="#7">Put edges (found from intensity data) on the Classified data</a></li>
               <li><a href="#8">Point Cloud</a></li>
               <li><a href="#9">Image of PC</a></li>
               <li><a href="#10">Data Smoothing via Median Filtering</a></li>
               <li><a href="#11">Find Surfaces in the point cloud - Curtiousy of Gav'</a></li>
            </ul>
         </div><pre class="codeinput"><span class="keyword">function</span> Block_Classifier(PointData, IntensityData, RangeData) <span class="comment">% this one uses edges from IntensityData Image</span>
</pre><h2>Flags<a name="2"></a></h2><pre class="codeinput">do_smoothing = 1; <span class="comment">%Set to 1 to do median filtering to smooth the classification result</span>
draw_image = 1; <span class="comment">%Set to 1 to draw an 2D image of the PC</span>
draw_PC = 0; <span class="comment">%Set to 1 to draw the PC</span>
display_ID_edgeim = 0; <span class="comment">%displays an image of the intensity data and an image of teh edges found in the intensity image</span>
draw_image_with_edge = 1; <span class="comment">%displays the images with the found edges marked on them</span>
dont_run_classifier = 0; <span class="comment">%doesn't classify data -used when ClassifiedData already exists</span>
replace_hoks_false_intensity_data = 1; <span class="comment">%This  replaces the hokuyo's false data with the intensity reading from the ray next to the non-returned  ray but on the same scan</span>
find_surfaces_in_PC = 1; <span class="comment">% This finds surface in the PC - used for AOI scaling in the classifier</span>

classiy_scan_range_start = 1;
classiy_scan_range_end = size(PointData,1);

colordef <span class="string">black</span>;
</pre><h2>Find surfaces in the point cloud<a name="3"></a></h2><pre class="codeinput"><span class="keyword">if</span> find_surfaces_in_PC == 1
    [PointsPlaneData, surface_plane_coefs] = surface_making_simple(PointData,0.2);
<span class="keyword">end</span>
</pre><h2>The hokuyo uses the last data for a ray if no return is recieved - This<a name="4"></a></h2>
         <p>causes a problem with edge detection. This cell replaces the hokuyo's false data with the intensity reading from the ray next
            to the non-returned ray but on the same scan - so in other waords, more false data, but more realistic false data
         </p><pre class="codeinput"><span class="keyword">if</span> replace_hoks_false_intensity_data == 1;
    IntensityDataFlaseDataFixed = IntensityData;
    last_known_good_data(size(IntensityDataFlaseDataFixed,2)) = 0;
    last_known_good_data(:) = IntensityDataFlaseDataFixed(1,1);

    <span class="keyword">for</span> i = 2:size(IntensityDataFlaseDataFixed,2);
        <span class="keyword">for</span> j = 2:size(IntensityDataFlaseDataFixed,1);
            <span class="keyword">if</span> IntensityDataFlaseDataFixed(j,i) == last_known_good_data(i)
                IntensityDataFlaseDataFixed(j,i) = IntensityDataFlaseDataFixed(j,i-1);
            <span class="keyword">else</span>
                last_known_good_data(i) = IntensityDataFlaseDataFixed(j,i);
            <span class="keyword">end</span>
        <span class="keyword">end</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="keyword">if</span> replace_hoks_false_intensity_data == 1;
    IntensityDatatoUse = IntensityDataFlaseDataFixed;
<span class="keyword">else</span>
    IntensityDatatoUse = IntensityData;
<span class="keyword">end</span>

<span class="comment">%clean up</span>
clear <span class="string">last_known_good_data</span>;
clear <span class="string">IntensityDataFlaseDataFixed</span>;
clear <span class="string">i</span>;
clear <span class="string">j</span>;
</pre><h2>Edge detecting in IntensityData image<a name="5"></a></h2><pre class="codeinput"><span class="comment">%edge detection method to use</span>
<span class="comment">% edge_finding_method_to_use = 'sobel';</span>
<span class="comment">% edge_finding_method_to_use = 'prewitt';</span>
 edge_finding_method_to_use = <span class="string">'roberts'</span>;
<span class="comment">% edge_finding_method_to_use = 'log';</span>
<span class="comment">% edge_finding_method_to_use = 'zerocross';</span>
<span class="comment">% edge_finding_method_to_use = 'canny';</span>

InData4Image = IntensityDatatoUse/max(max(IntensityDatatoUse));
image_being_used = InData4Image;

<span class="comment">%finds edges in the image</span>
Iedges = edge(image_being_used, edge_finding_method_to_use);

<span class="comment">%displays images</span>
<span class="keyword">if</span> display_ID_edgeim == 1
    figure, imshow(image_being_used);
    figure, imshow(Iedges);
<span class="keyword">end</span>
</pre><h2>Init's classification result matrix and does classify<a name="6"></a></h2><pre class="codeinput"><span class="keyword">if</span> dont_run_classifier == 0
    ClassifiedData = IntensityDatatoUse; <span class="comment">% creats a variable of the correct size - one classifcation per point</span>
    ClassifiedData(:,:) = 4; <span class="comment">% sets all points classification to 4 - 'don't know'</span>

    <span class="comment">%% Sends data to the classifier one scan at a time and creates a matrix of classification results - one for each point</span>
    <span class="keyword">for</span> i = classiy_scan_range_start:classiy_scan_range_end
    <span class="keyword">if</span> mod(i,20) == 0 <span class="comment">% puts something in debug so I know its working</span>
        i
    <span class="keyword">end</span>
        <span class="keyword">try</span> <span class="comment">% I use try as sometimes the classifier crashes for an unknown reason</span>
            <span class="keyword">if</span> find_surfaces_in_PC == 0
                found_lines = Classifier(PointData, IntensityDatatoUse, RangeData, i, Iedges); <span class="comment">% this one uses edges from IntensityData Image</span>
            <span class="keyword">else</span>
                found_lines = Classifier(PointData, IntensityDatatoUse, RangeData, i, Iedges, PointsPlaneData, surface_plane_coefs); <span class="comment">% this one uses edges from IntensityData Image</span>
            <span class="keyword">end</span>
        <span class="keyword">end</span>
        <span class="comment">% This creats the classfier output matrix. The matrix is in the same</span>
        <span class="comment">% format as PointData, IntensityData, etc</span>
        number_of_lines = size(found_lines.line_start_end_points_smoothed,1);
        <span class="keyword">for</span> j = 1:number_of_lines
            <span class="keyword">if</span> found_lines.line_start_end_points_smoothed(j,1) &gt; 0
                number_of_points_classified_by_this_line = found_lines.line_start_end_points_smoothed(j,2)-found_lines.line_start_end_points_smoothed(j,1)+1;
                <span class="keyword">for</span> k = 1:number_of_points_classified_by_this_line
                    ClassifiedData(i,(found_lines.line_start_end_points_smoothed(j,1)+k-1)) = found_lines.classifier_output(j);
                <span class="keyword">end</span>
            <span class="keyword">end</span>
        <span class="keyword">end</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>
</pre><h2>Put edges (found from intensity data) on the Classified data<a name="7"></a></h2><pre class="codeinput"><span class="keyword">for</span> i = 1:size(Iedges,1)
    <span class="keyword">for</span> j = 1:size(Iedges,2)
        <span class="keyword">if</span> Iedges(i,j) == 1
            ClassifiedDatawEdges(i,j) = 5;
        <span class="keyword">else</span>
            ClassifiedDatawEdges(i,j) = ClassifiedData(i,j);
        <span class="keyword">end</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>
</pre><h2>Point Cloud<a name="8"></a></h2><pre class="codeinput"><span class="keyword">if</span> draw_PC == 1
    <span class="comment">%Coloured (by classification) point cloud</span>
    <span class="keyword">if</span> draw_image_with_edge == 1
        data_to_display = ClassifiedDatawEdges;
    <span class="keyword">else</span>
        data_to_display = ClassifiedData;
    <span class="keyword">end</span>
    figure();
    view(-90,-90);
    hold <span class="string">on</span>;
    <span class="keyword">for</span> i = 1:size(data_to_display,1)
        <span class="keyword">for</span> j = 1:size(data_to_display,2)
            <span class="comment">%for user output colouring</span>
            <span class="keyword">switch</span> (data_to_display(i,j))
                <span class="keyword">case</span> 0
                    <span class="comment">%output = 'void';</span>
                    output_color = [0 0 0]; <span class="comment">% BLACK</span>
                <span class="keyword">case</span> 1
                    <span class="comment">%output = 'Grey Metal ';</span>
                    output_color = [.35 .35 .35]; <span class="comment">% GREY</span>
                <span class="keyword">case</span> 2
                    <span class="comment">%output = 'Shiny Metal';</span>
                    output_color = [.8 .8 .8]; <span class="comment">% Silver</span>
                <span class="keyword">case</span> 3
                    <span class="comment">%output = 'Cloth/Wood'; % OR RED OR WHITE --- JUST CLOTH or WOOD!!!</span>
                    output_color = [1 0 0]; <span class="comment">% RED</span>
                <span class="keyword">case</span> 4
                    <span class="comment">%output = 'Do not know';</span>
                    output_color = [0 0 0]; <span class="comment">% BLACK</span>
                <span class="keyword">case</span> 5
                    <span class="comment">%output = 'Edge';</span>
                    output_color = [.7 .9 .0]; <span class="comment">% GREEN</span>
            <span class="keyword">end</span>
            plot3(PointData(i,j,1),PointData(i,j,2),PointData(i,j,3),<span class="string">'color'</span>, output_color);
        <span class="keyword">end</span>
    <span class="keyword">end</span>
    drawnow;
<span class="keyword">end</span>
</pre><h2>Image of PC<a name="9"></a></h2><pre class="codeinput"><span class="keyword">if</span> draw_image == 1
    <span class="keyword">if</span> draw_image_with_edge ==1
        data_to_display = ClassifiedDatawEdges;
    <span class="keyword">else</span>
        data_to_display = ClassifiedData;
    <span class="keyword">end</span>
    figure();
    colmap = [[.35 .35 .35]; [.8 .8 .8]; [1 0 0]; [0 0 0]; [.7 .9 .0]];
    colormap(colmap)
    image(data_to_display);
<span class="keyword">end</span>
</pre><h2>Data Smoothing via Median Filtering<a name="10"></a></h2><pre class="codeinput"><span class="keyword">if</span> do_smoothing == 1
    <span class="comment">%Median filtering</span>
    filter_level = 7;
    ClassifiedDataSmoothed=ClassifiedData/max(max(ClassifiedData)); <span class="comment">% pre scaler</span>
    ClassifiedDataSmoothed = medfilt2(ClassifiedDataSmoothed,[filter_level filter_level]); <span class="comment">% the filter</span>
    ClassifiedDataSmoothed=ClassifiedDataSmoothed*max(max(ClassifiedData)); <span class="comment">%post scaler</span>

    <span class="comment">% Put edges (found from intensity data) on the Smoothed Classified data</span>
    <span class="keyword">for</span> i = 1:size(Iedges,1)
        <span class="keyword">for</span> j = 1:size(Iedges,2)
            <span class="keyword">if</span> Iedges(i,j) == 1
                ClassifiedDataSmoothedwEdges(i,j) = 5;
            <span class="keyword">else</span>
                ClassifiedDataSmoothedwEdges(i,j) = ClassifiedDataSmoothed(i,j);
            <span class="keyword">end</span>
        <span class="keyword">end</span>
    <span class="keyword">end</span>

    <span class="comment">%---- Cut and paste from above ----------------------------------------</span>
        <span class="comment">% Point Cloud</span>
        <span class="keyword">if</span> draw_PC == 1
            <span class="comment">%Coloured (by classification) point cloud</span>
            <span class="keyword">if</span> draw_image_with_edge == 1
                data_to_display = ClassifiedDataSmoothedwEdges;
            <span class="keyword">else</span>
                data_to_display = ClassifiedDataSmoothed;
            <span class="keyword">end</span>
            figure();
            view(-90,-90);
            hold <span class="string">on</span>;
            <span class="keyword">for</span> i = 1:size(data_to_display,1)
                <span class="keyword">for</span> j = 1:size(data_to_display,2)
                    <span class="comment">%for user output colouring</span>
                    <span class="keyword">switch</span> (data_to_display(i,j))
                        <span class="keyword">case</span> 0
                            <span class="comment">%output = 'void';</span>
                            output_color = [0 0 0]; <span class="comment">% BLACK</span>
                        <span class="keyword">case</span> 1
                            <span class="comment">%output = 'Grey Metal ';</span>
                            output_color = [.35 .35 .35]; <span class="comment">% GREY</span>
                        <span class="keyword">case</span> 2
                            <span class="comment">%output = 'Shiny Metal';</span>
                            output_color = [.8 .8 .8]; <span class="comment">% Silver</span>
                        <span class="keyword">case</span> 3
                            <span class="comment">%output = 'Cloth/Wood'; % OR RED OR WHITE --- JUST CLOTH or WOOD!!!</span>
                            output_color = [1 0 0]; <span class="comment">% RED</span>
                        <span class="keyword">case</span> 4
                            <span class="comment">%output = 'Do not know';</span>
                            output_color = [0 0 0]; <span class="comment">% BLACK</span>
                        <span class="keyword">case</span> 5
                            <span class="comment">%output = 'Edge';</span>
                            output_color = [.7 .9 .0]; <span class="comment">% GREEN</span>
                    <span class="keyword">end</span>
                    plot3(PointData(i,j,1),PointData(i,j,2),PointData(i,j,3),<span class="string">'color'</span>, output_color);
                <span class="keyword">end</span>
            <span class="keyword">end</span>
            drawnow;
        <span class="keyword">end</span>

        <span class="comment">%% Image of PC</span>
        <span class="keyword">if</span> draw_image == 1
            <span class="keyword">if</span> draw_image_with_edge ==1
                data_to_display = ClassifiedDataSmoothedwEdges;
            <span class="keyword">else</span>
                data_to_display = ClassifiedDataSmoothedData;
            <span class="keyword">end</span>
            figure();
            colmap = [[.35 .35 .35]; [.8 .8 .8]; [1 0 0]; [0 0 0]; [.7 .9 .0]];
            colormap(colmap)
            image(data_to_display);
        <span class="keyword">end</span>
    <span class="comment">%----------------------------------------------------------------------</span>
<span class="keyword">end</span>
</pre><h2>Find Surfaces in the point cloud - Curtiousy of Gav'<a name="11"></a></h2><pre class="codeinput">        <span class="comment">% This function goes through each point and register it to one or more planes</span>
        <span class="keyword">function</span> [PointsPlaneData, surface_plane_coefs] = surface_making_simple(PointData,mew);

        <span class="comment">%make into a 3 by many matrix of points</span>
        <span class="comment">% (it would be better if a 1* matrix could be passed to this function instead</span>
        scan_data=zeros([size(PointData,1)*size(PointData,2),3]);
        <span class="keyword">for</span> i=1:size(PointData,1);
            scan_data((i-1)*size(PointData,2)+1 : i*size(PointData,2) , :)=<span class="keyword">...</span>
                [[PointData(i,:,1)]',[PointData(i,:,2)]',[PointData(i,:,3)]'];
        <span class="keyword">end</span>

        <span class="comment">%other variables</span>
        plane_num=1;
        point_cloud_reg=zeros([size(scan_data,1),1]);
        min_num_pts_in_plane=8;
        eigen_value_thresh=2;

        <span class="comment">%breakinto cubes</span>
        start_time=clock;
        cube_size=mew;
        [point_in_cube]=break_into_cubes_internal(scan_data,cube_size);
        voxelate_time=etime(clock,start_time);

        <span class="comment">%Go through and register the points and make planes</span>
        <span class="keyword">for</span> current_point=1:size(scan_data,1)
            <span class="comment">%if not registered to a plane try and resister it or start its own</span>
            <span class="keyword">if</span> point_cloud_reg(current_point)==0
                <span class="comment">%get the distance from all points to current point</span>
                distance_between=distance_between_all_points_internal(scan_data,current_point,mew,point_in_cube);

                 <span class="keyword">if</span> length(distance_between.closest_indices)&gt;min_num_pts_in_plane
                     <span class="comment">%make the point group zero mean</span>
                     mean_to_sub=sum(scan_data(distance_between.closest_indices,:))/<span class="keyword">...</span>
                                     length(distance_between.closest_indices);
                     scan_data_minusmean=[scan_data(distance_between.closest_indices,1)-mean_to_sub(1),<span class="keyword">...</span>
                                          scan_data(distance_between.closest_indices,2)-mean_to_sub(2),<span class="keyword">...</span>
                                          scan_data(distance_between.closest_indices,3)-mean_to_sub(3)];
                    <span class="comment">%get the convergance matrix of points and eigen values and vectors</span>
                    convergange_mat=cov(scan_data_minusmean);
                    [eigenvectors,eigenvalues]=eig(convergange_mat);
                    eigenvalues=eigenvalues*[1;1;1];

                    <span class="comment">%sort 3 eigenvalues so as to get data correlation</span>
                    min2max_eig=sort(eigenvalues,<span class="string">'ascend'</span>);
                    <span class="keyword">if</span> min2max_eig(1)&gt;0
                        data_correlation=min2max_eig(2)/min2max_eig(1);
                    <span class="keyword">else</span>
                        data_correlation=[Inf];
                    <span class="keyword">end</span>

                    <span class="comment">%finds which has least correlation =normal and the greatest</span>
                    <span class="comment">%is on the plane</span>
                    norm=eigenvectors(:,find(eigenvalues==min2max_eig(1)));
                    temp_plane_equ=[norm(1),norm(2),norm(3),<span class="keyword">...</span>
                                  -(norm(1)*scan_data(current_point,1)+norm(2)*scan_data(current_point,2)+norm(3)*scan_data(current_point,3))];

                    <span class="keyword">if</span> (dis_bet_plane_n_pnt_internal(temp_plane_equ,scan_data(current_point,:))&lt;mew &amp;&amp; data_correlation&gt;eigen_value_thresh)
                        dis_to_plane=dis_bet_plane_n_pnt_internal(temp_plane_equ,scan_data(distance_between.closest_indices,:));
                        plane(plane_num).home_point=scan_data(current_point,:);
                        plane(plane_num).equ=temp_plane_equ;
                        plane(plane_num).normal_by_eigenval=norm;
                        plane(plane_num).points=distance_between.closest_indices(find(dis_to_plane&lt;mew));
                        point_cloud_reg(plane(plane_num).points)=1;
                        plane_num=plane_num+1;
                    <span class="keyword">end</span>
                 <span class="keyword">end</span> <span class="comment">%end the if to see if there are at least 3 points within mew</span>
            <span class="keyword">end</span> <span class="comment">%end the if unregistered current point</span>
        <span class="keyword">end</span> <span class="comment">%end the for loop for every point</span>

        <span class="comment">% prepare output data</span>
        surface_plane_coefs=zeros(plane_num-1,4);
        <span class="keyword">for</span> i = 1:plane_num-1
            surface_plane_coefs(i,1:4) = plane(1,i).equ;
        <span class="keyword">end</span>

        <span class="comment">%assign points to a plane they belong to, remember they could belong to</span>
        <span class="comment">%more than one plane and this will only assign them to one of these</span>
        point_belongs_to=zeros([size(scan_data,1),1]);
        <span class="keyword">for</span> i=1:size(plane,2)
            point_belongs_to(plane(i).points)=i;
        <span class="keyword">end</span>

        <span class="comment">% puts back in original form</span>
        PointsPlaneData=zeros([size(PointData,1),size(PointData,2)]);
        <span class="keyword">for</span> i=1:size(PointsPlaneData,1)
            PointsPlaneData(i,1:size(PointsPlaneData,2))=point_belongs_to((i-1)*size(PointsPlaneData,2)+1:i*size(PointsPlaneData,2))';
        <span class="keyword">end</span>
        <span class="comment">%shows the intensity image</span>
        <span class="comment">% imshow(PointsPlaneData/max(max(PointsPlaneData)));</span>

        <span class="comment">% Printing out details - this is not needed</span>
        <span class="comment">% Print out the time taken and the points covered</span>
        perc_of_pnts_reg=100*(1-size(find(point_cloud_reg==0),1)/size(point_cloud_reg,1));
        calc_time=etime(clock,start_time);
        <span class="comment">%determine memory use</span>
        temp=whos(<span class="string">'scan_data'</span>,<span class="string">'bytes'</span>);
        memB4=temp.bytes;
        temp1=plane(1).home_point;temp2=whos(<span class="string">'temp1'</span>);
        temp3=plane(1).equ;temp4=whos(<span class="string">'temp3'</span>);
        memafta=(temp2.bytes+temp4.bytes)*length(plane);

        <span class="comment">%%%%%%%%</span>
        <span class="comment">% Display Algorithm Statistics</span>
        <span class="comment">% disp(strcat('From a point cloud with:_',num2str(size(scan_data,1)),'_points'));</span>
        <span class="comment">% disp(strcat('_Dividing into cubes took:_', num2str(voxelate_time),'_We used mew=_', num2str(mew),'_Min no. pts in plane=_',num2str(min_num_pts_in_plane),'_. The total time was:_',num2str(calc_time),'_sec.'));</span>
        <span class="comment">% disp(strcat('We made:_',num2str(size(plane,2)),'_planes and registered:_',num2str(perc_of_pnts_reg),'_% of pnts'));</span>
        <span class="comment">% disp(strcat('This reduced the data size from:_',num2str(memB4),'_to:_',num2str(memafta)));</span>

        <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
        <span class="comment">% ADDITIONAL FUNCTIONS</span>
        <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>

        <span class="comment">% Function:break_into_cubes_internal</span>
        <span class="comment">%breaks into cubes so that the searching is quicker</span>
        <span class="keyword">function</span> [point_in_cube]=break_into_cubes_internal(scan_data,cube_size)

        min_max=[min(scan_data(:,1)),max(scan_data(:,1));<span class="keyword">...</span>
                 min(scan_data(:,2)),max(scan_data(:,2));<span class="keyword">...</span>
                 min(scan_data(:,3)),max(scan_data(:,3))];
        shifed_points=[scan_data(:,1)-min_max(1,1),<span class="keyword">...</span>
                       scan_data(:,2)-min_max(2,1),<span class="keyword">...</span>
                       scan_data(:,3)-min_max(3,1)];
        <span class="comment">%this fixes up the cubes so they start at 1 and go through to end</span>
        in_which_cube=floor(shifed_points/cube_size)+1;
        max_values=max(in_which_cube);

        point_in_cube=zeros([size(scan_data)]);

        <span class="keyword">for</span> i=1:max_values(1)
            point_in_cube(find(in_which_cube(:,1)==i),1)=i;
        <span class="keyword">end</span>
        <span class="keyword">for</span> j=1:max_values(2)
            point_in_cube(find(in_which_cube(:,2)==j),2)=j;
        <span class="keyword">end</span>
        <span class="keyword">for</span> k=1:max_values(3)
            point_in_cube(find(in_which_cube(:,3)==k),3)=k;
        <span class="keyword">end</span>


        <span class="comment">% distance_between_all_points_internal</span>
        <span class="comment">%this will give the distance between all points</span>
        <span class="keyword">function</span> distance_between=distance_between_all_points_internal(scan_data,current_point,mew,point_in_cube)

        hc=point_in_cube(current_point,:);

        a=            find(point_in_cube(:,1)==hc(1)-1 | point_in_cube(:,1)==hc(1) | point_in_cube(:,1)==hc(1)+1);
        b=            a(find(point_in_cube(a,2)==hc(2)-1 | point_in_cube(a,2)==hc(2) | point_in_cube(a,2)==hc(2)+1));
        close_pts_ind=b(find(point_in_cube(b,3)==hc(3)-1 | point_in_cube(b,3)==hc(3) | point_in_cube(b,3)==hc(3)+1));


        distance_between.all_values=sqrt((scan_data(current_point,1)-scan_data(close_pts_ind,1)).^2+<span class="keyword">...</span>
                                         (scan_data(current_point,2)-scan_data(close_pts_ind,2)).^2+<span class="keyword">...</span>
                                         (scan_data(current_point,3)-scan_data(close_pts_ind,3)).^2);
        distance_between.indices=close_pts_ind;
        temp=find(distance_between.all_values&lt;mew);
        [distance_between.closest_values,temp_order]=sort(distance_between.all_values(temp),<span class="string">'ascend'</span>);
        distance_between.closest_indices=distance_between.indices(temp(temp_order));


        <span class="comment">% dis_bet_plane_n_pnt_internal</span>
        <span class="keyword">function</span> dis_to_plane=dis_bet_plane_n_pnt_internal(plane_equ,pnt)
        <span class="comment">%dis_to_plane=zeros([1,size(pnt,1)]);</span>
        <span class="keyword">if</span> size(pnt,1)&gt;1
                dis_to_plane=abs((plane_equ(1)*pnt(:,1)+<span class="keyword">...</span>
                                               plane_equ(2)*pnt(:,2)+<span class="keyword">...</span>
                                               plane_equ(3)*pnt(:,3)+plane_equ(4))./<span class="keyword">...</span>
                                               sqrt(plane_equ(1)^2+plane_equ(2)^2+plane_equ(3)^2));

        <span class="keyword">else</span>
            dis_to_plane=abs((plane_equ(1)*pnt(1)+plane_equ(2)*pnt(2)+plane_equ(3)*pnt(3)+plane_equ(4))/<span class="keyword">...</span>
                     sqrt(plane_equ(1)^2+plane_equ(2)^2+plane_equ(3)^2));
        <span class="keyword">end</span>
</pre><p class="footer"><br>
            Published with MATLAB&reg; 7.4<br></p>
      </div>
      <!--
##### SOURCE BEGIN #####
function Block_Classifier(PointData, IntensityData, RangeData) % this one uses edges from IntensityData Image

%% Flags
do_smoothing = 1; %Set to 1 to do median filtering to smooth the classification result
draw_image = 1; %Set to 1 to draw an 2D image of the PC
draw_PC = 0; %Set to 1 to draw the PC
display_ID_edgeim = 0; %displays an image of the intensity data and an image of teh edges found in the intensity image
draw_image_with_edge = 1; %displays the images with the found edges marked on them
dont_run_classifier = 0; %doesn't classify data -used when ClassifiedData already exists
replace_hoks_false_intensity_data = 1; %This  replaces the hokuyo's false data with the intensity reading from the ray next to the non-returned  ray but on the same scan
find_surfaces_in_PC = 1; % This finds surface in the PC - used for AOI scaling in the classifier

classiy_scan_range_start = 1;
classiy_scan_range_end = size(PointData,1);

colordef black;

%% Find surfaces in the point cloud
if find_surfaces_in_PC == 1
    [PointsPlaneData, surface_plane_coefs] = surface_making_simple(PointData,0.2);
end

%% The hokuyo uses the last data for a ray if no return is recieved - This
% causes a problem with edge detection. This cell replaces the hokuyo's
% false data with the intensity reading from the ray next to the non-returned 
% ray but on the same scan - so in other waords, more false data, but more
% realistic false data
if replace_hoks_false_intensity_data == 1;
    IntensityDataFlaseDataFixed = IntensityData;
    last_known_good_data(size(IntensityDataFlaseDataFixed,2)) = 0;
    last_known_good_data(:) = IntensityDataFlaseDataFixed(1,1);

    for i = 2:size(IntensityDataFlaseDataFixed,2);
        for j = 2:size(IntensityDataFlaseDataFixed,1);
            if IntensityDataFlaseDataFixed(j,i) == last_known_good_data(i)
                IntensityDataFlaseDataFixed(j,i) = IntensityDataFlaseDataFixed(j,i-1);
            else 
                last_known_good_data(i) = IntensityDataFlaseDataFixed(j,i);
            end
        end
    end
end

if replace_hoks_false_intensity_data == 1;
    IntensityDatatoUse = IntensityDataFlaseDataFixed;
else
    IntensityDatatoUse = IntensityData;
end

%clean up
clear last_known_good_data;
clear IntensityDataFlaseDataFixed;
clear i;
clear j;

%% Edge detecting in IntensityData image
%edge detection method to use
% edge_finding_method_to_use = 'sobel';
% edge_finding_method_to_use = 'prewitt';
 edge_finding_method_to_use = 'roberts';
% edge_finding_method_to_use = 'log';
% edge_finding_method_to_use = 'zerocross';
% edge_finding_method_to_use = 'canny';

InData4Image = IntensityDatatoUse/max(max(IntensityDatatoUse));
image_being_used = InData4Image;

%finds edges in the image
Iedges = edge(image_being_used, edge_finding_method_to_use);

%displays images
if display_ID_edgeim == 1
    figure, imshow(image_being_used);
    figure, imshow(Iedges);
end

%% Init's classification result matrix and does classify
if dont_run_classifier == 0
    ClassifiedData = IntensityDatatoUse; % creats a variable of the correct size - one classifcation per point
    ClassifiedData(:,:) = 4; % sets all points classification to 4 - 'don't know'

    %% Sends data to the classifier one scan at a time and creates a matrix of classification results - one for each point
    for i = classiy_scan_range_start:classiy_scan_range_end  
    if mod(i,20) == 0 % puts something in debug so I know its working
        i
    end
        try % I use try as sometimes the classifier crashes for an unknown reason
            if find_surfaces_in_PC == 0
                found_lines = Classifier(PointData, IntensityDatatoUse, RangeData, i, Iedges); % this one uses edges from IntensityData Image
            else
                found_lines = Classifier(PointData, IntensityDatatoUse, RangeData, i, Iedges, PointsPlaneData, surface_plane_coefs); % this one uses edges from IntensityData Image
            end
        end
        % This creats the classfier output matrix. The matrix is in the same
        % format as PointData, IntensityData, etc
        number_of_lines = size(found_lines.line_start_end_points_smoothed,1); 
        for j = 1:number_of_lines
            if found_lines.line_start_end_points_smoothed(j,1) > 0
                number_of_points_classified_by_this_line = found_lines.line_start_end_points_smoothed(j,2)-found_lines.line_start_end_points_smoothed(j,1)+1;
                for k = 1:number_of_points_classified_by_this_line
                    ClassifiedData(i,(found_lines.line_start_end_points_smoothed(j,1)+k-1)) = found_lines.classifier_output(j);
                end 
            end
        end
    end
end

%% Put edges (found from intensity data) on the Classified data 
for i = 1:size(Iedges,1)
    for j = 1:size(Iedges,2)
        if Iedges(i,j) == 1
            ClassifiedDatawEdges(i,j) = 5;
        else
            ClassifiedDatawEdges(i,j) = ClassifiedData(i,j);
        end
    end
end

%% Point Cloud
if draw_PC == 1
    %Coloured (by classification) point cloud
    if draw_image_with_edge == 1
        data_to_display = ClassifiedDatawEdges;
    else
        data_to_display = ClassifiedData;
    end
    figure();
    view(-90,-90);
    hold on;
    for i = 1:size(data_to_display,1)
        for j = 1:size(data_to_display,2)
            %for user output colouring
            switch (data_to_display(i,j))
                case 0
                    %output = 'void';
                    output_color = [0 0 0]; % BLACK
                case 1
                    %output = 'Grey Metal ';
                    output_color = [.35 .35 .35]; % GREY
                case 2
                    %output = 'Shiny Metal';
                    output_color = [.8 .8 .8]; % Silver
                case 3
                    %output = 'Cloth/Wood'; % OR RED OR WHITE REPLACE_WITH_DASH_DASH- JUST CLOTH or WOOD!!!
                    output_color = [1 0 0]; % RED
                case 4
                    %output = 'Do not know';
                    output_color = [0 0 0]; % BLACK 
                case 5
                    %output = 'Edge';
                    output_color = [.7 .9 .0]; % GREEN 
            end 
            plot3(PointData(i,j,1),PointData(i,j,2),PointData(i,j,3),'color', output_color);
        end 
    end
    drawnow;
end

%% Image of PC
if draw_image == 1
    if draw_image_with_edge ==1
        data_to_display = ClassifiedDatawEdges;
    else
        data_to_display = ClassifiedData;
    end
    figure();
    colmap = [[.35 .35 .35]; [.8 .8 .8]; [1 0 0]; [0 0 0]; [.7 .9 .0]];
    colormap(colmap)
    image(data_to_display);
end

%% Data Smoothing via Median Filtering
if do_smoothing == 1
    %Median filtering
    filter_level = 7;
    ClassifiedDataSmoothed=ClassifiedData/max(max(ClassifiedData)); % pre scaler
    ClassifiedDataSmoothed = medfilt2(ClassifiedDataSmoothed,[filter_level filter_level]); % the filter
    ClassifiedDataSmoothed=ClassifiedDataSmoothed*max(max(ClassifiedData)); %post scaler
    
    % Put edges (found from intensity data) on the Smoothed Classified data 
    for i = 1:size(Iedges,1)
        for j = 1:size(Iedges,2)
            if Iedges(i,j) == 1
                ClassifiedDataSmoothedwEdges(i,j) = 5;
            else
                ClassifiedDataSmoothedwEdges(i,j) = ClassifiedDataSmoothed(i,j);
            end
        end
    end
   
    %REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH Cut and paste from above REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
        % Point Cloud
        if draw_PC == 1
            %Coloured (by classification) point cloud
            if draw_image_with_edge == 1
                data_to_display = ClassifiedDataSmoothedwEdges;
            else
                data_to_display = ClassifiedDataSmoothed;
            end
            figure();
            view(-90,-90);
            hold on;
            for i = 1:size(data_to_display,1)
                for j = 1:size(data_to_display,2)
                    %for user output colouring
                    switch (data_to_display(i,j))
                        case 0
                            %output = 'void';
                            output_color = [0 0 0]; % BLACK
                        case 1
                            %output = 'Grey Metal ';
                            output_color = [.35 .35 .35]; % GREY
                        case 2
                            %output = 'Shiny Metal';
                            output_color = [.8 .8 .8]; % Silver
                        case 3
                            %output = 'Cloth/Wood'; % OR RED OR WHITE REPLACE_WITH_DASH_DASH- JUST CLOTH or WOOD!!!
                            output_color = [1 0 0]; % RED
                        case 4
                            %output = 'Do not know';
                            output_color = [0 0 0]; % BLACK 
                        case 5
                            %output = 'Edge';
                            output_color = [.7 .9 .0]; % GREEN 
                    end 
                    plot3(PointData(i,j,1),PointData(i,j,2),PointData(i,j,3),'color', output_color);
                end 
            end
            drawnow;
        end

        %% Image of PC
        if draw_image == 1
            if draw_image_with_edge ==1
                data_to_display = ClassifiedDataSmoothedwEdges;
            else
                data_to_display = ClassifiedDataSmoothedData;
            end
            figure();
            colmap = [[.35 .35 .35]; [.8 .8 .8]; [1 0 0]; [0 0 0]; [.7 .9 .0]];
            colormap(colmap)
            image(data_to_display);
        end
    %REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
end


%% Find Surfaces in the point cloud - Curtiousy of Gav'

        % This function goes through each point and register it to one or more planes
        function [PointsPlaneData, surface_plane_coefs] = surface_making_simple(PointData,mew);

        %make into a 3 by many matrix of points 
        % (it would be better if a 1* matrix could be passed to this function instead
        scan_data=zeros([size(PointData,1)*size(PointData,2),3]);
        for i=1:size(PointData,1);
            scan_data((i-1)*size(PointData,2)+1 : i*size(PointData,2) , :)=...
                [[PointData(i,:,1)]',[PointData(i,:,2)]',[PointData(i,:,3)]'];                  
        end

        %other variables
        plane_num=1;
        point_cloud_reg=zeros([size(scan_data,1),1]);
        min_num_pts_in_plane=8;
        eigen_value_thresh=2;

        %breakinto cubes
        start_time=clock;
        cube_size=mew;
        [point_in_cube]=break_into_cubes_internal(scan_data,cube_size);
        voxelate_time=etime(clock,start_time);

        %Go through and register the points and make planes
        for current_point=1:size(scan_data,1)
            %if not registered to a plane try and resister it or start its own
            if point_cloud_reg(current_point)==0
                %get the distance from all points to current point
                distance_between=distance_between_all_points_internal(scan_data,current_point,mew,point_in_cube);

                 if length(distance_between.closest_indices)>min_num_pts_in_plane        
                     %make the point group zero mean
                     mean_to_sub=sum(scan_data(distance_between.closest_indices,:))/...
                                     length(distance_between.closest_indices);
                     scan_data_minusmean=[scan_data(distance_between.closest_indices,1)-mean_to_sub(1),...
                                          scan_data(distance_between.closest_indices,2)-mean_to_sub(2),...
                                          scan_data(distance_between.closest_indices,3)-mean_to_sub(3)];    
                    %get the convergance matrix of points and eigen values and vectors
                    convergange_mat=cov(scan_data_minusmean);
                    [eigenvectors,eigenvalues]=eig(convergange_mat);
                    eigenvalues=eigenvalues*[1;1;1];

                    %sort 3 eigenvalues so as to get data correlation
                    min2max_eig=sort(eigenvalues,'ascend');
                    if min2max_eig(1)>0
                        data_correlation=min2max_eig(2)/min2max_eig(1);
                    else
                        data_correlation=[Inf];
                    end

                    %finds which has least correlation =normal and the greatest
                    %is on the plane
                    norm=eigenvectors(:,find(eigenvalues==min2max_eig(1)));                
                    temp_plane_equ=[norm(1),norm(2),norm(3),...
                                  -(norm(1)*scan_data(current_point,1)+norm(2)*scan_data(current_point,2)+norm(3)*scan_data(current_point,3))];

                    if (dis_bet_plane_n_pnt_internal(temp_plane_equ,scan_data(current_point,:))<mew && data_correlation>eigen_value_thresh)
                        dis_to_plane=dis_bet_plane_n_pnt_internal(temp_plane_equ,scan_data(distance_between.closest_indices,:));
                        plane(plane_num).home_point=scan_data(current_point,:);
                        plane(plane_num).equ=temp_plane_equ;
                        plane(plane_num).normal_by_eigenval=norm;
                        plane(plane_num).points=distance_between.closest_indices(find(dis_to_plane<mew));
                        point_cloud_reg(plane(plane_num).points)=1; 
                        plane_num=plane_num+1;                    
                    end            
                 end %end the if to see if there are at least 3 points within mew
            end %end the if unregistered current point         
        end %end the for loop for every point

        % prepare output data
        surface_plane_coefs=zeros(plane_num-1,4);
        for i = 1:plane_num-1
            surface_plane_coefs(i,1:4) = plane(1,i).equ;
        end

        %assign points to a plane they belong to, remember they could belong to
        %more than one plane and this will only assign them to one of these
        point_belongs_to=zeros([size(scan_data,1),1]);
        for i=1:size(plane,2)
            point_belongs_to(plane(i).points)=i;
        end

        % puts back in original form
        PointsPlaneData=zeros([size(PointData,1),size(PointData,2)]);
        for i=1:size(PointsPlaneData,1)
            PointsPlaneData(i,1:size(PointsPlaneData,2))=point_belongs_to((i-1)*size(PointsPlaneData,2)+1:i*size(PointsPlaneData,2))';
        end
        %shows the intensity image
        % imshow(PointsPlaneData/max(max(PointsPlaneData)));

        % Printing out details - this is not needed
        % Print out the time taken and the points covered
        perc_of_pnts_reg=100*(1-size(find(point_cloud_reg==0),1)/size(point_cloud_reg,1));
        calc_time=etime(clock,start_time);
        %determine memory use
        temp=whos('scan_data','bytes');
        memB4=temp.bytes;
        temp1=plane(1).home_point;temp2=whos('temp1');
        temp3=plane(1).equ;temp4=whos('temp3');
        memafta=(temp2.bytes+temp4.bytes)*length(plane);

        %%%%%%%%
        % Display Algorithm Statistics
        % disp(strcat('From a point cloud with:_',num2str(size(scan_data,1)),'_points'));
        % disp(strcat('_Dividing into cubes took:_', num2str(voxelate_time),'_We used mew=_', num2str(mew),'_Min no. pts in plane=_',num2str(min_num_pts_in_plane),'_. The total time was:_',num2str(calc_time),'_sec.')); 
        % disp(strcat('We made:_',num2str(size(plane,2)),'_planes and registered:_',num2str(perc_of_pnts_reg),'_% of pnts'));
        % disp(strcat('This reduced the data size from:_',num2str(memB4),'_to:_',num2str(memafta)));

        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        % ADDITIONAL FUNCTIONS
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

        % Function:break_into_cubes_internal
        %breaks into cubes so that the searching is quicker
        function [point_in_cube]=break_into_cubes_internal(scan_data,cube_size)

        min_max=[min(scan_data(:,1)),max(scan_data(:,1));...
                 min(scan_data(:,2)),max(scan_data(:,2));...
                 min(scan_data(:,3)),max(scan_data(:,3))];
        shifed_points=[scan_data(:,1)-min_max(1,1),...
                       scan_data(:,2)-min_max(2,1),...
                       scan_data(:,3)-min_max(3,1)];
        %this fixes up the cubes so they start at 1 and go through to end
        in_which_cube=floor(shifed_points/cube_size)+1;
        max_values=max(in_which_cube);

        point_in_cube=zeros([size(scan_data)]);

        for i=1:max_values(1)
            point_in_cube(find(in_which_cube(:,1)==i),1)=i;
        end
        for j=1:max_values(2)
            point_in_cube(find(in_which_cube(:,2)==j),2)=j;
        end
        for k=1:max_values(3)                    
            point_in_cube(find(in_which_cube(:,3)==k),3)=k;
        end


        % distance_between_all_points_internal
        %this will give the distance between all points
        function distance_between=distance_between_all_points_internal(scan_data,current_point,mew,point_in_cube)

        hc=point_in_cube(current_point,:);

        a=            find(point_in_cube(:,1)==hc(1)-1 | point_in_cube(:,1)==hc(1) | point_in_cube(:,1)==hc(1)+1);
        b=            a(find(point_in_cube(a,2)==hc(2)-1 | point_in_cube(a,2)==hc(2) | point_in_cube(a,2)==hc(2)+1));
        close_pts_ind=b(find(point_in_cube(b,3)==hc(3)-1 | point_in_cube(b,3)==hc(3) | point_in_cube(b,3)==hc(3)+1));


        distance_between.all_values=sqrt((scan_data(current_point,1)-scan_data(close_pts_ind,1)).^2+...
                                         (scan_data(current_point,2)-scan_data(close_pts_ind,2)).^2+...
                                         (scan_data(current_point,3)-scan_data(close_pts_ind,3)).^2);
        distance_between.indices=close_pts_ind;
        temp=find(distance_between.all_values<mew);
        [distance_between.closest_values,temp_order]=sort(distance_between.all_values(temp),'ascend');
        distance_between.closest_indices=distance_between.indices(temp(temp_order));


        % dis_bet_plane_n_pnt_internal
        function dis_to_plane=dis_bet_plane_n_pnt_internal(plane_equ,pnt)
        %dis_to_plane=zeros([1,size(pnt,1)]);
        if size(pnt,1)>1
                dis_to_plane=abs((plane_equ(1)*pnt(:,1)+...
                                               plane_equ(2)*pnt(:,2)+...
                                               plane_equ(3)*pnt(:,3)+plane_equ(4))./...
                                               sqrt(plane_equ(1)^2+plane_equ(2)^2+plane_equ(3)^2));

        else
            dis_to_plane=abs((plane_equ(1)*pnt(1)+plane_equ(2)*pnt(2)+plane_equ(3)*pnt(3)+plane_equ(4))/...
                     sqrt(plane_equ(1)^2+plane_equ(2)^2+plane_equ(3)^2));
        end

##### SOURCE END #####
-->
   </body>
</html>