
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN">
<html xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   
      <!--
This HTML is auto-generated from an M-file.
To make changes, update the M-file and republish this document.
      -->
      <title>near_exhastive_NBV_search</title>
      <meta name="generator" content="MATLAB 7.4">
      <meta name="date" content="2008-06-19">
      <meta name="m-file" content="near_exhastive_NBV_search"><style>

body {
  background-color: white;
  margin:10px;
}

h1 {
  color: #990000; 
  font-size: x-large;
}

h2 {
  color: #990000;
  font-size: medium;
}

/* Make the text shrink to fit narrow windows, but not stretch too far in 
wide windows. */ 
p,h1,h2,div.content div {
  max-width: 600px;
  /* Hack for IE6 */
  width: auto !important; width: 600px;
}

pre.codeinput {
  background: #EEEEEE;
  padding: 10px;
}
@media print {
  pre.codeinput {word-wrap:break-word; width:100%;}
} 

span.keyword {color: #0000FF}
span.comment {color: #228B22}
span.string {color: #A020F0}
span.untermstring {color: #B20000}
span.syscmd {color: #B28C00}

pre.codeoutput {
  color: #666666;
  padding: 10px;
}

pre.error {
  color: red;
}

p.footer {
  text-align: right;
  font-size: xx-small;
  font-weight: lighter;
  font-style: italic;
  color: gray;
}

  </style></head>
   <body>
      <div class="content">
         <h1>near_exhastive_NBV_search</h1>
         <introduction>
            <p>SAME AS NBV_beta <b>Description:</b>  This function trys an alternate way to find the NBV, it goes through all the poses discretely and looks to see which ones
               give most innformation,  it also tries to find paths to the desired newQs
            </p>
         </introduction>
         <h2>Contents</h2>
         <div>
            <ul>
               <li><a href="#1">Function Call</a></li>
               <li><a href="#2">Variables</a></li>
               <li><a href="#3">Declare the damper variable</a></li>
               <li><a href="#4">Go through the joints at discrete positions</a></li>
               <li><a href="#5">Check if any bestviews were found, if so order them</a></li>
               <li><a href="#6">Display Results - currently commented</a></li>
            </ul>
         </div>
         <h2>Function Call<a name="1"></a></h2>
         <p><b>Inputs:</b> NULL
         </p>
         <p><b>Returns:</b> totaltime searchspace
         </p><pre class="codeinput"><span class="keyword">function</span> [totaltime,searchspace]=near_exhastive_NBV_search(numNBVanglesteps)
</pre><h2>Variables<a name="2"></a></h2>
         <p>clear the plots and global bestviews variable</p><pre class="codeinput">clear <span class="string">global</span> <span class="string">bestviews</span>;

<span class="comment">%this starts the timer</span>
timetaken=clock;
itcounter=0;

<span class="keyword">global</span> r workspace bestviews optimise scan;
<span class="comment">%actually will go through first step and then this many more</span>
<span class="comment">% numNBVanglesteps=2;</span>
qlimit=r.qlim;
<span class="comment">%taking 10 deg off either side so we don't use the max range for these joints</span>
qlimit(1:3,1)=qlimit(1:3,1)+10*pi/180;
qlimit(1:3,2)=qlimit(1:3,2)-10*pi/180;

bestviews=[];
indexed_knowncoords=round(setdiff(workspace.knowncoords(GetImpLevInfo(workspace.knowncoords),:),workspace.indexedobsticles,<span class="string">'rows'</span>)/workspace.inc_size);

<span class="comment">%this makes the check for a collision quicker</span>
obsticle_points=workspace.indexedobsticles(GetImpLevInfo(workspace.indexedobsticles),:);

<span class="comment">%%STARTADDED</span>
<span class="comment">%Additional (unknown info)</span>
all_possible=round(   workspace.unknowncoords(workspace.lev1unknown   ,:)/workspace.inc_size);
[nothing,index]=setdiff(all_possible,[indexed_knowncoords;obsticle_points],<span class="string">'rows'</span>);
unknown_points=workspace.unknowncoords(workspace.lev1unknown(index),:);
<span class="comment">%%ENDADDED</span>

unknownweight=calunknownweight();
</pre><h2>Declare the damper variable<a name="3"></a></h2>
         <p><img vspace="5" hspace="5" src="near_exhastive_NBV_search_eq6807794.png"> </p><pre class="codeinput"><span class="comment">% To compare to rand num, if larger record Q and addinfo as a bestview</span>
end_value_damper_weight=optimise.nbv_beta_dampner*size(indexed_knowncoords,1)/size(workspace.lev1unknown,1);
</pre><h2>Go through the joints at discrete positions<a name="4"></a></h2><pre class="codeinput"><span class="keyword">for</span> J1=qlimit(1,1):(qlimit(1,2)-qlimit(1,1))/numNBVanglesteps:qlimit(1,2)
    <span class="keyword">for</span> J2=qlimit(2,1):(qlimit(2,2)-qlimit(2,1))/numNBVanglesteps:qlimit(2,2)
        <span class="keyword">for</span> J3=qlimit(3,1):(qlimit(3,2)-qlimit(3,1))/numNBVanglesteps:qlimit(3,2)
            itcounter=itcounter+1;

            [obstacle_result,unknown_result]=check_path_for_col([J1,J2,J3,0,0,0],obsticle_points,unknown_points);
            <span class="keyword">if</span> obstacle_result
                <span class="keyword">if</span> ~unknown_result
<span class="comment">%                         display('Failed Joint 4s ellipsoid unknown space test');</span>
                    <span class="keyword">continue</span>;
                <span class="keyword">end</span>

                <span class="comment">%predefinedJ4's since we don't really need the whole range of movement</span>
                <span class="keyword">for</span> J4=[-135,-90,-45,0,45,90,135]*pi/180
                    <span class="comment">%Sets up the limits (possible poses) of J5</span>
                    <span class="comment">%depending on J3</span>
                    <span class="keyword">if</span> J3&gt;150*pi/180;  J5s_to_go_through=[-60,30]*pi/180;
                    <span class="keyword">else</span> J5s_to_go_through=[-45,45]*pi/180; <span class="keyword">end</span>

                    <span class="keyword">for</span> J5=J5s_to_go_through
                        newQ=[J1,J2,J3,J4,J5,0];
                        tr=fkine(r,newQ);
                        indexedpnt=round(tr(1:3,4)'/workspace.inc_size);

                        <span class="keyword">if</span> ~isempty(find(indexedpnt(1)==indexed_knowncoords(:,1) &amp; indexedpnt(2)==indexed_knowncoords(:,2) &amp; indexedpnt(3)==indexed_knowncoords(:,3),1))<span class="keyword">...</span>
                           &amp;&amp;rand()&gt;end_value_damper_weight
                            <span class="keyword">if</span> check_path_for_col(newQ,obsticle_points)
                                bestviews(end+1).tr=tr;
                                bestviews(end).chosenview=sum(tr(1:3,1:3));
                                bestviews(end).scanorigin=indexedpnt*workspace.inc_size;
                                bestviews(end).Q=newQ;
                                bestviews(end).expectedaddinfo=nbv_volume(tr,newQ);
                                bestviews(end).addinfo=getweighted_addinfo(bestviews(end).expectedaddinfo)/unknownweight;
                            <span class="keyword">end</span>
                        <span class="keyword">end</span>
                    <span class="keyword">end</span>
                <span class="keyword">end</span>
            <span class="keyword">end</span>
        <span class="keyword">end</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>
</pre><h2>Check if any bestviews were found, if so order them<a name="5"></a></h2><pre class="codeinput"><span class="keyword">if</span> isempty(bestviews)
    error(<span class="string">'There were no bestviews found, probably because there are no known points to go too, or end_value_damper_weight is too high'</span>);
<span class="keyword">end</span>

<span class="comment">%order the best views</span>
order_bestviews()



<span class="comment">% %% try and get at least 1 path then save the remaing valid_max-1</span>
<span class="comment">% valid_count=0;</span>
<span class="comment">% % this limits the amount of time we can spend searching for a path when</span>
<span class="comment">% % there may not be one</span>
<span class="comment">% valid_max=min(2*optimise.valid_max,size(bestviews,2));</span>
<span class="comment">% for current_view=1:valid_max</span>
<span class="comment">%     if valid_count&lt;1</span>
<span class="comment">% %         [bestviews(current_view).valid,bestviews(current_view).all_steps]=pathplanner(bestviews(current_view).Q,false,true,true,30);</span>
<span class="comment">%         [bestviews(current_view).valid,bestviews(current_view).all_steps]=pathplanner_new(bestviews(current_view).Q,false,true,true,30);</span>
<span class="comment">%     else %once we have one path then we just fill the rest in with blanks</span>
<span class="comment">%         bestviews(current_view).valid=-1;</span>
<span class="comment">%         bestviews(current_view).all_steps=[];</span>
<span class="comment">%     end</span>
<span class="comment">%</span>
<span class="comment">%     if bestviews(current_view).valid || valid_count&gt;=1</span>
<span class="comment">%         valid_count=valid_count+1;</span>
<span class="comment">%         tempbestviews(valid_count)=bestviews(current_view);</span>
<span class="comment">%         %we have enough (optimise.valid_max)</span>
<span class="comment">%         if valid_count&gt;=optimise.valid_max</span>
<span class="comment">%             break;</span>
<span class="comment">%         end</span>
<span class="comment">%     else %it failed so note down that we can't get to this destination</span>
<span class="comment">%         scan.done_bestviews_orfailed=[scan.done_bestviews_orfailed;bestviews(current_view).Q];</span>
<span class="comment">%     end</span>
<span class="comment">% end</span>
<span class="comment">% %set to the new sorted and pathplanned tempbestviews</span>
<span class="comment">% if valid_count==0</span>
<span class="comment">%      error('There were no bestviews found, probably because there were no possible paths to any of the desired ones, consider changing end_value_damper_weight');</span>
<span class="comment">% else</span>
<span class="comment">%     bestviews=tempbestviews;</span>
<span class="comment">% end</span>
</pre><h2>Display Results - currently commented<a name="6"></a></h2><pre class="codeinput">totaltime=etime(clock,timetaken);
display([<span class="string">'TOTAL Time taken is: '</span>, num2str(totaltime)]);
searchspace=itcounter*7*2;
display([<span class="string">'Search space='</span>,num2str(searchspace)]);
</pre><p class="footer"><br>
            Published with MATLAB&reg; 7.4<br></p>
      </div>
      <!--
##### SOURCE BEGIN #####
%% near_exhastive_NBV_search
%
% SAME AS NBV_beta
% *Description:*  This function trys an alternate way to find the NBV, it goes
% through all the poses discretely and looks to see which ones give most
% innformation,  it also tries to find paths to the desired newQs

%% Function Call
%
% *Inputs:* NULL
%
% *Returns:* 
% totaltime
% searchspace

function [totaltime,searchspace]=near_exhastive_NBV_search(numNBVanglesteps)

%% Variables
% clear the plots and global bestviews variable
clear global bestviews;

%this starts the timer
timetaken=clock;
itcounter=0;

global r workspace bestviews optimise scan;
%actually will go through first step and then this many more 
% numNBVanglesteps=2;
qlimit=r.qlim;
%taking 10 deg off either side so we don't use the max range for these joints
qlimit(1:3,1)=qlimit(1:3,1)+10*pi/180;
qlimit(1:3,2)=qlimit(1:3,2)-10*pi/180;

bestviews=[]; 
indexed_knowncoords=round(setdiff(workspace.knowncoords(GetImpLevInfo(workspace.knowncoords),:),workspace.indexedobsticles,'rows')/workspace.inc_size);

%this makes the check for a collision quicker
obsticle_points=workspace.indexedobsticles(GetImpLevInfo(workspace.indexedobsticles),:);

%%STARTADDED
%Additional (unknown info)
all_possible=round(   workspace.unknowncoords(workspace.lev1unknown   ,:)/workspace.inc_size);
[nothing,index]=setdiff(all_possible,[indexed_knowncoords;obsticle_points],'rows');
unknown_points=workspace.unknowncoords(workspace.lev1unknown(index),:);
%%ENDADDED

unknownweight=calunknownweight();

%% Declare the damper variable
% $$ \begin{array}{l}
% P_{known\_lev1}:=(x_j,y_j,z_j)_{j=1,...,m} \\
% P_{all\_lev1}:=(x_j,y_j,z_j)_{j=1,...,n}\\
% C_{end\_value\_damper\_weight}=C_{nbv\_beta\_dampner\times} \frac{m}{n}\\
% \forall validQ,if(C_{end\_value\_damper\_weight}>rand) \rightarrow bestview
% \end{array}$$

% To compare to rand num, if larger record Q and addinfo as a bestview
end_value_damper_weight=optimise.nbv_beta_dampner*size(indexed_knowncoords,1)/size(workspace.lev1unknown,1);


%% Go through the joints at discrete positions
for J1=qlimit(1,1):(qlimit(1,2)-qlimit(1,1))/numNBVanglesteps:qlimit(1,2)
    for J2=qlimit(2,1):(qlimit(2,2)-qlimit(2,1))/numNBVanglesteps:qlimit(2,2)
        for J3=qlimit(3,1):(qlimit(3,2)-qlimit(3,1))/numNBVanglesteps:qlimit(3,2)
            itcounter=itcounter+1;
          
            [obstacle_result,unknown_result]=check_path_for_col([J1,J2,J3,0,0,0],obsticle_points,unknown_points);
            if obstacle_result                   
                if ~unknown_result
%                         display('Failed Joint 4s ellipsoid unknown space test');
                    continue;
                end

                %predefinedJ4's since we don't really need the whole range of movement
                for J4=[-135,-90,-45,0,45,90,135]*pi/180
                    %Sets up the limits (possible poses) of J5
                    %depending on J3
                    if J3>150*pi/180;  J5s_to_go_through=[-60,30]*pi/180; 
                    else J5s_to_go_through=[-45,45]*pi/180; end                
                    
                    for J5=J5s_to_go_through                        
                        newQ=[J1,J2,J3,J4,J5,0];
                        tr=fkine(r,newQ);            
                        indexedpnt=round(tr(1:3,4)'/workspace.inc_size);

                        if ~isempty(find(indexedpnt(1)==indexed_knowncoords(:,1) & indexedpnt(2)==indexed_knowncoords(:,2) & indexedpnt(3)==indexed_knowncoords(:,3),1))...
                           &&rand()>end_value_damper_weight
                            if check_path_for_col(newQ,obsticle_points)
                                bestviews(end+1).tr=tr;                
                                bestviews(end).chosenview=sum(tr(1:3,1:3));
                                bestviews(end).scanorigin=indexedpnt*workspace.inc_size;
                                bestviews(end).Q=newQ;                                
                                bestviews(end).expectedaddinfo=nbv_volume(tr,newQ);
                                bestviews(end).addinfo=getweighted_addinfo(bestviews(end).expectedaddinfo)/unknownweight;
                            end
                        end
                    end
                end
            end
        end
    end
end

%% Check if any bestviews were found, if so order them
if isempty(bestviews)
    error('There were no bestviews found, probably because there are no known points to go too, or end_value_damper_weight is too high');
end

%order the best views
order_bestviews()



% %% try and get at least 1 path then save the remaing valid_max-1
% valid_count=0;
% % this limits the amount of time we can spend searching for a path when
% % there may not be one
% valid_max=min(2*optimise.valid_max,size(bestviews,2));
% for current_view=1:valid_max
%     if valid_count<1
% %         [bestviews(current_view).valid,bestviews(current_view).all_steps]=pathplanner(bestviews(current_view).Q,false,true,true,30);    
%         [bestviews(current_view).valid,bestviews(current_view).all_steps]=pathplanner_new(bestviews(current_view).Q,false,true,true,30);    
%     else %once we have one path then we just fill the rest in with blanks
%         bestviews(current_view).valid=-1;
%         bestviews(current_view).all_steps=[];        
%     end
%     
%     if bestviews(current_view).valid || valid_count>=1
%         valid_count=valid_count+1;
%         tempbestviews(valid_count)=bestviews(current_view);   
%         %we have enough (optimise.valid_max)
%         if valid_count>=optimise.valid_max
%             break;
%         end
%     else %it failed so note down that we can't get to this destination
%         scan.done_bestviews_orfailed=[scan.done_bestviews_orfailed;bestviews(current_view).Q];
%     end
% end
% %set to the new sorted and pathplanned tempbestviews
% if valid_count==0
%      error('There were no bestviews found, probably because there were no possible paths to any of the desired ones, consider changing end_value_damper_weight');
% else
%     bestviews=tempbestviews;
% end


%% Display Results - currently commented
totaltime=etime(clock,timetaken);
display(['TOTAL Time taken is: ', num2str(totaltime)]);
searchspace=itcounter*7*2;
display(['Search space=',num2str(searchspace)]);

##### SOURCE END #####
-->
   </body>
</html>