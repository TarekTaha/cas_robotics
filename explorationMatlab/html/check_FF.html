
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN">
<html xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   
      <!--
This HTML is auto-generated from an M-file.
To make changes, update the M-file and republish this document.
      -->
      <title>check_FF</title>
      <meta name="generator" content="MATLAB 7.4">
      <meta name="date" content="2007-10-03">
      <meta name="m-file" content="check_FF"><style>

body {
  background-color: white;
  margin:10px;
}

h1 {
  color: #990000; 
  font-size: x-large;
}

h2 {
  color: #990000;
  font-size: medium;
}

/* Make the text shrink to fit narrow windows, but not stretch too far in 
wide windows. */ 
p,h1,h2,div.content div {
  max-width: 600px;
  /* Hack for IE6 */
  width: auto !important; width: 600px;
}

pre.codeinput {
  background: #EEEEEE;
  padding: 10px;
}
@media print {
  pre.codeinput {word-wrap:break-word; width:100%;}
} 

span.keyword {color: #0000FF}
span.comment {color: #228B22}
span.string {color: #A020F0}
span.untermstring {color: #B20000}
span.syscmd {color: #B28C00}

pre.codeoutput {
  color: #666666;
  padding: 10px;
}

pre.error {
  color: red;
}

p.footer {
  text-align: right;
  font-size: xx-small;
  font-weight: lighter;
  font-style: italic;
  color: gray;
}

  </style></head>
   <body>
      <div class="content">
         <h1>check_FF</h1>
         <introduction>
            <p><b>Description:</b>  This function takes a transform and an ellipse definition and translates the points back to the original cordinate frame
               of the ellipse. Note the reason for this is because the ellipse has been translated because of the movement of the link of
               the robot which it encompases. This function simply returns true/false as to whether there are any points inside the ellipse
               in question. <i>Note</i> eventually I want to put in unknown points and an acceptable limit
            </p>
         </introduction>
         <h2>Contents</h2>
         <div>
            <ul>
               <li><a href="#1">Function Call</a></li>
               <li><a href="#2">Variables</a></li>
               <li><a href="#3">As long as there are some points</a></li>
               <li><a href="#4">Translate Points back to coordinate frame of ellipse</a></li>
               <li><a href="#5">Check if there are points in ellipse</a></li>
            </ul>
         </div>
         <h2>Function Call<a name="1"></a></h2>
         <div>
            <ul>
               <li><b>Inputs:</b> t (4*4 double) this is the transform of the arm, ellipse_vals (struct) holds the center and parameters of the ellipse points
                  (3*m double) holds the points in space
               </li>
               <li><b>Returns:</b> result (bin) =1 if ok, =0 if NOT ok
               </li>
            </ul>
         </div><pre class="codeinput"><span class="keyword">function</span> result = check_FF(t,ellipse_vals,points)
</pre><h2>Variables<a name="2"></a></h2><pre class="codeinput"><span class="keyword">if</span> nargin&lt;3
    <span class="comment">%import point from somewhere</span>
    <span class="keyword">global</span> workspace
    <span class="comment">% Avoiding only indexed obstacle points</span>
    points=workspace.indexedobsticles;

    <span class="comment">% Suggested way to include unknown points since unknowncoords-knowncoords inludes obstacles</span>
<span class="comment">%     points=setdiff(workspace.unknowncoords(GetImpLevInfo(workspace.unknowncoords),:),...</span>
<span class="comment">%                    workspace.knowncoords(GetImpLevInfo(workspace.knowncoords),:),'rows');</span>
<span class="keyword">end</span>

<span class="comment">%assumed there's nothing to collide with</span>
result=1;
</pre><h2>As long as there are some points<a name="3"></a></h2>
         <p><img vspace="5" hspace="5" src="check_FF_eq5261.png"> </p><pre class="codeinput"><span class="keyword">if</span> size(points,2)&gt;0
</pre><h2>Translate Points back to coordinate frame of ellipse<a name="4"></a></h2>
         <p><img vspace="5" hspace="5" src="check_FF_eq795197.png"> </p><pre class="codeinput">    <span class="comment">%we want to inverse translate the points IE leave the elispes where</span>
    <span class="comment">%they were to start off with and translate the world around them</span>
    translated_points=[points(:,1)-t(1,4) points(:,2)-t(2,4) points(:,3)-t(3,4)];
    translated_points=translated_points*t(1:3,1:3);
</pre><h2>Check if there are points in ellipse<a name="5"></a></h2>
         <p><img vspace="5" hspace="5" src="check_FF_eq2127246.png"> </p><pre class="codeinput">    <span class="keyword">if</span> ~isempty(find(((translated_points(:,1)-ellipse_vals.center(1)).^2)/ellipse_vals.params(1)^2+<span class="keyword">...</span>
                     ((translated_points(:,2)-ellipse_vals.center(2)).^2)/ellipse_vals.params(2)^2+<span class="keyword">...</span>
                     ((translated_points(:,3)-ellipse_vals.center(3)).^2)/ellipse_vals.params(3)^2&lt;=1,1))
        result=0; <span class="comment">% THERE IS some point is inside</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>
</pre><p class="footer"><br>
            Published with MATLAB&reg; 7.4<br></p>
      </div>
      <!--
##### SOURCE BEGIN #####
%% check_FF
%
% *Description:*  This function takes a transform and an ellipse definition
% and translates the points back to the original cordinate frame of the
% ellipse. Note the reason for this is because the ellipse has been
% translated because of the movement of the link of the robot which it
% encompases. This function simply returns true/false as to whether there
% are any points inside the ellipse in question. 
% _Note_ eventually I want to put in unknown points and an acceptable limit 

%% Function Call
% 
% * *Inputs:* t (4*4 double) this is the transform of the arm,
% ellipse_vals (struct) holds the center and parameters of the ellipse
% points (3*m double) holds the points in space
% * *Returns:* result (bin) =1 if ok, =0 if NOT ok

function result = check_FF(t,ellipse_vals,points)

%% Variables
if nargin<3
    %import point from somewhere
    global workspace
    % Avoiding only indexed obstacle points
    points=workspace.indexedobsticles;
    
    % Suggested way to include unknown points since unknowncoords-knowncoords inludes obstacles 
%     points=setdiff(workspace.unknowncoords(GetImpLevInfo(workspace.unknowncoords),:),...
%                    workspace.knowncoords(GetImpLevInfo(workspace.knowncoords),:),'rows');    
end
    
%assumed there's nothing to collide with
result=1;

%% As long as there are some points
% $$P \neq \emptyset $$
if size(points,2)>0

%% Translate Points back to coordinate frame of ellipse
% $$ P_T = P \times Trans(-p_x,-p_y,-p_z) \times 
% \begin{array}{ccc} 
% n_x & o_x & a_x \\ 
% n_y & o_y & a_y \\ 
% n_z & o_z & a_z\end{array}$$

    %we want to inverse translate the points IE leave the elispes where
    %they were to start off with and translate the world around them
    translated_points=[points(:,1)-t(1,4) points(:,2)-t(2,4) points(:,3)-t(3,4)];
    translated_points=translated_points*t(1:3,1:3);

%% Check if there are points in ellipse
% $$ \begin{array}{ccc}
% \forall p_T \in P_T: &  
% \frac{(p_{Tx}-center_x)^2}{a^2}+
% \frac{(p_{Ty}-center_y)^2}{b^2}+
% \frac{(p_{Tz}-center_z)^2}{c^2}<=1 & \Rightarrow
% result = 0 \end{array}$$

    if ~isempty(find(((translated_points(:,1)-ellipse_vals.center(1)).^2)/ellipse_vals.params(1)^2+...
                     ((translated_points(:,2)-ellipse_vals.center(2)).^2)/ellipse_vals.params(2)^2+...
                     ((translated_points(:,3)-ellipse_vals.center(3)).^2)/ellipse_vals.params(3)^2<=1,1))
        result=0; % THERE IS some point is inside
    end
end
##### SOURCE END #####
-->
   </body>
</html>