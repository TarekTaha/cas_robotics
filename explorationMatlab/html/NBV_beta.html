
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN">
<html xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   
      <!--
This HTML is auto-generated from an M-file.
To make changes, update the M-file and republish this document.
      -->
      <title>NBV_beta</title>
      <meta name="generator" content="MATLAB 7.4">
      <meta name="date" content="2008-01-14">
      <meta name="m-file" content="NBV_beta"><style>

body {
  background-color: white;
  margin:10px;
}

h1 {
  color: #990000; 
  font-size: x-large;
}

h2 {
  color: #990000;
  font-size: medium;
}

/* Make the text shrink to fit narrow windows, but not stretch too far in 
wide windows. */ 
p,h1,h2,div.content div {
  max-width: 600px;
  /* Hack for IE6 */
  width: auto !important; width: 600px;
}

pre.codeinput {
  background: #EEEEEE;
  padding: 10px;
}
@media print {
  pre.codeinput {word-wrap:break-word; width:100%;}
} 

span.keyword {color: #0000FF}
span.comment {color: #228B22}
span.string {color: #A020F0}
span.untermstring {color: #B20000}
span.syscmd {color: #B28C00}

pre.codeoutput {
  color: #666666;
  padding: 10px;
}

pre.error {
  color: red;
}

p.footer {
  text-align: right;
  font-size: xx-small;
  font-weight: lighter;
  font-style: italic;
  color: gray;
}

  </style></head>
   <body>
      <div class="content">
         <h1>NBV_beta</h1>
         <introduction>
            <p><b>Description:</b>  This function trys an alternate way to find the NBV, it goes through all the poses discretely and looks to see which ones
               give most innformation,  it also tries to find paths to the desired newQs
            </p>
         </introduction>
         <h2>Contents</h2>
         <div>
            <ul>
               <li><a href="#1">Function Call</a></li>
               <li><a href="#2">Variables</a></li>
               <li><a href="#3">Declare the damper variable</a></li>
               <li><a href="#4">Go through the joints at discrete positions</a></li>
               <li><a href="#5">Check if any bestviews were found, if so order them</a></li>
               <li><a href="#6">try and get at least 1 path then save the remaing valid_max-1</a></li>
               <li><a href="#7">Display Results - currently commented</a></li>
            </ul>
         </div>
         <h2>Function Call<a name="1"></a></h2>
         <p><b>Inputs:</b> NULL
         </p>
         <p><b>Returns:</b> NULL
         </p><pre class="codeinput"><span class="keyword">function</span> NBV_beta()
</pre><h2>Variables<a name="2"></a></h2>
         <p>clear the plots and global bestviews variable</p><pre class="codeinput">clear <span class="string">global</span> <span class="string">bestviews</span>;

<span class="comment">%this starts the timer</span>
timetaken=clock;

<span class="keyword">global</span> r workspace bestviews optimise scan;
<span class="comment">%actually will go through first step and then this many more</span>
numNBVanglesteps=6;
qlimit=r.qlim;
<span class="comment">%taking 10 deg off either side so we don't use the max range for these joints</span>
qlimit(1:3,1)=qlimit(1:3,1)+10*pi/180;
qlimit(1:3,2)=qlimit(1:3,2)-10*pi/180;

bestviews=[];
indexed_knowncoords=round(setdiff(workspace.knowncoords(GetImpLevInfo(workspace.knowncoords),:),workspace.indexedobsticles,<span class="string">'rows'</span>)/workspace.inc_size);

<span class="comment">%this makes the check for a collision quicker</span>
obsticle_points=workspace.indexedobsticles(GetImpLevInfo(workspace.indexedobsticles),:);

<span class="comment">%%STARTADDED</span>
<span class="comment">%Additional (unknown info)</span>
all_possible=round(   workspace.unknowncoords(workspace.lev1unknown   ,:)/workspace.inc_size);
[nothing,index]=setdiff(all_possible,[indexed_knowncoords;obsticle_points],<span class="string">'rows'</span>);
unknown_points=workspace.unknowncoords(workspace.lev1unknown(index),:);
<span class="comment">%%ENDADDED</span>

unknownweight=calunknownweight();
</pre><h2>Declare the damper variable<a name="3"></a></h2>
         <p><img vspace="5" hspace="5" src="NBV_beta_eq6807794.png"> </p><pre class="codeinput"><span class="comment">% To compare to rand num, if larger record Q and addinfo as a bestview</span>
end_value_damper_weight=optimise.nbv_beta_dampner*size(indexed_knowncoords,1)/size(workspace.lev1unknown,1);
</pre><h2>Go through the joints at discrete positions<a name="4"></a></h2><pre class="codeinput"><span class="keyword">for</span> J1=qlimit(1,1):(qlimit(1,2)-qlimit(1,1))/numNBVanglesteps:qlimit(1,2)
    <span class="keyword">for</span> J2=qlimit(2,1):(qlimit(2,2)-qlimit(2,1))/numNBVanglesteps:qlimit(2,2)
        <span class="keyword">for</span> J3=qlimit(3,1):(qlimit(3,2)-qlimit(3,1))/numNBVanglesteps:qlimit(3,2)
            <span class="comment">%Check collision which also checks soft mostion limit which we can't exceed</span>
            <span class="keyword">if</span> ~(J1==scan.done_bestviews_orfailed(:,1)&amp;<span class="keyword">...</span>
                 J2==scan.done_bestviews_orfailed(:,2)&amp;<span class="keyword">...</span>
                 J3==scan.done_bestviews_orfailed(:,3)&amp;<span class="keyword">...</span>
                 inf==scan.done_bestviews_orfailed(:,4)&amp;<span class="keyword">...</span>
                 inf==scan.done_bestviews_orfailed(:,5)&amp;<span class="keyword">...</span>
                 inf==scan.done_bestviews_orfailed(:,6))
<span class="comment">%%ADDED NEW</span>
             [obstacle_result,unknown_result]=check_path_for_col([J1,J2,J3,0,0,0],obsticle_points,unknown_points);
                <span class="keyword">if</span> obstacle_result
                    <span class="keyword">if</span> ~unknown_result
<span class="comment">%                         display('Failed Joint 4s ellipsoid unknown space test');</span>
                        <span class="keyword">continue</span>;
                    <span class="keyword">end</span>

                    <span class="comment">%predefinedJ4's since we don't really need the whole range of movement</span>
                    <span class="keyword">for</span> J4=[-45,45]*pi/180
                        <span class="comment">%Sets up the limits (possible poses) of J5</span>
                        <span class="comment">%depending on J3</span>
                        <span class="keyword">if</span> J3&gt;150*pi/180;  J5s_to_go_through=[-60,30]*pi/180;
                        <span class="keyword">else</span> J5s_to_go_through=[-45,45]*pi/180; <span class="keyword">end</span>
                        <span class="keyword">for</span> J5=J5s_to_go_through
                            newQ=[J1,J2,J3,J4,J5,0];
                            <span class="comment">%if we haven't already done this pose before</span>
                            <span class="keyword">if</span> ~(newQ(1)==scan.done_bestviews_orfailed(:,1)&amp;<span class="keyword">...</span>
                                 newQ(2)==scan.done_bestviews_orfailed(:,2)&amp;<span class="keyword">...</span>
                                 newQ(3)==scan.done_bestviews_orfailed(:,3)&amp;<span class="keyword">...</span><span class="comment">.</span>
                                 newQ(4)==scan.done_bestviews_orfailed(:,4)&amp;<span class="keyword">...</span>
                                 newQ(5)==scan.done_bestviews_orfailed(:,5))
                                tr=fkine(r,newQ);
                                indexedpnt=round(tr(1:3,4)'/workspace.inc_size);

                                <span class="keyword">if</span> ~isempty(find(indexedpnt(1)==indexed_knowncoords(:,1) &amp; indexedpnt(2)==indexed_knowncoords(:,2) &amp; indexedpnt(3)==indexed_knowncoords(:,3),1))<span class="keyword">...</span>
                                   &amp;&amp;rand()&gt;end_value_damper_weight
                                    <span class="keyword">if</span> check_path_for_col(newQ,obsticle_points)
                                        bestviews(end+1).tr=tr;
                                        bestviews(end).chosenview=sum(tr(1:3,1:3));
                                        bestviews(end).scanorigin=indexedpnt*workspace.inc_size;
                                        bestviews(end).Q=newQ;
                                        bestviews(end).expectedaddinfo=nbv_volume(tr,newQ);
                                        bestviews(end).addinfo=getweighted_addinfo(bestviews(end).expectedaddinfo)/unknownweight;
                                    <span class="keyword">else</span> <span class="comment">% add to list of impossible scans</span>
                                        scan.done_bestviews_orfailed=[scan.done_bestviews_orfailed;newQ];
                                    <span class="keyword">end</span>
                                <span class="keyword">end</span>
                            <span class="keyword">end</span>
                        <span class="keyword">end</span>
                    <span class="keyword">end</span>
                <span class="keyword">else</span>
                    <span class="comment">%add this to the list of places we can't get to</span>
                    scan.done_bestviews_orfailed=[scan.done_bestviews_orfailed;[J1,J2,J3,inf,inf,inf]];
                <span class="keyword">end</span>
            <span class="keyword">end</span>
        <span class="keyword">end</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>
</pre><h2>Check if any bestviews were found, if so order them<a name="5"></a></h2><pre class="codeinput"><span class="keyword">if</span> isempty(bestviews)
    error(<span class="string">'There were no bestviews found, probably because there are no known points to go too, or end_value_damper_weight is too high'</span>);
<span class="keyword">end</span>

<span class="comment">%order the best views</span>
order_bestviews()
</pre><h2>try and get at least 1 path then save the remaing valid_max-1<a name="6"></a></h2><pre class="codeinput">valid_count=0;
<span class="comment">% this limits the amount of time we can spend searching for a path when</span>
<span class="comment">% there may not be one</span>
valid_max=min(2*optimise.valid_max,size(bestviews,2));
<span class="keyword">for</span> current_view=1:valid_max
    <span class="keyword">if</span> valid_count&lt;1
<span class="comment">%         [bestviews(current_view).valid,bestviews(current_view).all_steps]=pathplanner(bestviews(current_view).Q,false,true,true,30);</span>
        [bestviews(current_view).valid,bestviews(current_view).all_steps]=pathplanner_new(bestviews(current_view).Q,false,true,true,30);
    <span class="keyword">else</span> <span class="comment">%once we have one path then we just fill the rest in with blanks</span>
        bestviews(current_view).valid=-1;
        bestviews(current_view).all_steps=[];
    <span class="keyword">end</span>

    <span class="keyword">if</span> bestviews(current_view).valid || valid_count&gt;=1
        valid_count=valid_count+1;
        tempbestviews(valid_count)=bestviews(current_view);
        <span class="comment">%we have enough (optimise.valid_max)</span>
        <span class="keyword">if</span> valid_count&gt;=optimise.valid_max
            <span class="keyword">break</span>;
        <span class="keyword">end</span>
    <span class="keyword">else</span> <span class="comment">%it failed so note down that we can't get to this destination</span>
        scan.done_bestviews_orfailed=[scan.done_bestviews_orfailed;bestviews(current_view).Q];
    <span class="keyword">end</span>
<span class="keyword">end</span>
<span class="comment">%set to the new sorted and pathplanned tempbestviews</span>
<span class="keyword">if</span> valid_count==0
     error(<span class="string">'There were no bestviews found, probably because there were no possible paths to any of the desired ones, consider changing end_value_damper_weight'</span>);
<span class="keyword">else</span>
    bestviews=tempbestviews;
<span class="keyword">end</span>
</pre><h2>Display Results - currently commented<a name="7"></a></h2><pre class="codeinput">display(strcat(<span class="string">'TOTAL Time taken is: '</span>, num2str(etime(clock,timetaken))));
</pre><p class="footer"><br>
            Published with MATLAB&reg; 7.4<br></p>
      </div>
      <!--
##### SOURCE BEGIN #####
%% NBV_beta
%
% *Description:*  This function trys an alternate way to find the NBV, it goes
% through all the poses discretely and looks to see which ones give most
% innformation,  it also tries to find paths to the desired newQs

%% Function Call
%
% *Inputs:* NULL
%
% *Returns:* NULL

function NBV_beta()

%% Variables
% clear the plots and global bestviews variable
clear global bestviews;

%this starts the timer
timetaken=clock;

global r workspace bestviews optimise scan;
%actually will go through first step and then this many more 
numNBVanglesteps=6;
qlimit=r.qlim;
%taking 10 deg off either side so we don't use the max range for these joints
qlimit(1:3,1)=qlimit(1:3,1)+10*pi/180;
qlimit(1:3,2)=qlimit(1:3,2)-10*pi/180;

bestviews=[]; 
indexed_knowncoords=round(setdiff(workspace.knowncoords(GetImpLevInfo(workspace.knowncoords),:),workspace.indexedobsticles,'rows')/workspace.inc_size);

%this makes the check for a collision quicker
obsticle_points=workspace.indexedobsticles(GetImpLevInfo(workspace.indexedobsticles),:);

%%STARTADDED
%Additional (unknown info)
all_possible=round(   workspace.unknowncoords(workspace.lev1unknown   ,:)/workspace.inc_size);
[nothing,index]=setdiff(all_possible,[indexed_knowncoords;obsticle_points],'rows');
unknown_points=workspace.unknowncoords(workspace.lev1unknown(index),:);
%%ENDADDED

unknownweight=calunknownweight();

%% Declare the damper variable
% $$ \begin{array}{l}
% P_{known\_lev1}:=(x_j,y_j,z_j)_{j=1,...,m} \\
% P_{all\_lev1}:=(x_j,y_j,z_j)_{j=1,...,n}\\
% C_{end\_value\_damper\_weight}=C_{nbv\_beta\_dampner\times} \frac{m}{n}\\
% \forall validQ,if(C_{end\_value\_damper\_weight}>rand) \rightarrow bestview
% \end{array}$$

% To compare to rand num, if larger record Q and addinfo as a bestview
end_value_damper_weight=optimise.nbv_beta_dampner*size(indexed_knowncoords,1)/size(workspace.lev1unknown,1);


%% Go through the joints at discrete positions
for J1=qlimit(1,1):(qlimit(1,2)-qlimit(1,1))/numNBVanglesteps:qlimit(1,2)
    for J2=qlimit(2,1):(qlimit(2,2)-qlimit(2,1))/numNBVanglesteps:qlimit(2,2)
        for J3=qlimit(3,1):(qlimit(3,2)-qlimit(3,1))/numNBVanglesteps:qlimit(3,2)
            %Check collision which also checks soft mostion limit which we can't exceed
            if ~(J1==scan.done_bestviews_orfailed(:,1)&...
                 J2==scan.done_bestviews_orfailed(:,2)&...
                 J3==scan.done_bestviews_orfailed(:,3)&...
                 inf==scan.done_bestviews_orfailed(:,4)&...
                 inf==scan.done_bestviews_orfailed(:,5)&...
                 inf==scan.done_bestviews_orfailed(:,6))
%%ADDED NEW             
             [obstacle_result,unknown_result]=check_path_for_col([J1,J2,J3,0,0,0],obsticle_points,unknown_points);
                if obstacle_result                   
                    if ~unknown_result
%                         display('Failed Joint 4s ellipsoid unknown space test');
                        continue;
                    end

                    %predefinedJ4's since we don't really need the whole range of movement
                    for J4=[-45,45]*pi/180
                        %Sets up the limits (possible poses) of J5
                        %depending on J3
                        if J3>150*pi/180;  J5s_to_go_through=[-60,30]*pi/180; 
                        else J5s_to_go_through=[-45,45]*pi/180; end                
                        for J5=J5s_to_go_through                        
                            newQ=[J1,J2,J3,J4,J5,0];
                            %if we haven't already done this pose before
                            if ~(newQ(1)==scan.done_bestviews_orfailed(:,1)&...
                                 newQ(2)==scan.done_bestviews_orfailed(:,2)&...
                                 newQ(3)==scan.done_bestviews_orfailed(:,3)&....
                                 newQ(4)==scan.done_bestviews_orfailed(:,4)&...
                                 newQ(5)==scan.done_bestviews_orfailed(:,5))
                                tr=fkine(r,newQ);            
                                indexedpnt=round(tr(1:3,4)'/workspace.inc_size);

                                if ~isempty(find(indexedpnt(1)==indexed_knowncoords(:,1) & indexedpnt(2)==indexed_knowncoords(:,2) & indexedpnt(3)==indexed_knowncoords(:,3),1))...
                                   &&rand()>end_value_damper_weight
                                    if check_path_for_col(newQ,obsticle_points)
                                        bestviews(end+1).tr=tr;                
                                        bestviews(end).chosenview=sum(tr(1:3,1:3));
                                        bestviews(end).scanorigin=indexedpnt*workspace.inc_size;
                                        bestviews(end).Q=newQ;                                
                                        bestviews(end).expectedaddinfo=nbv_volume(tr,newQ);
                                        bestviews(end).addinfo=getweighted_addinfo(bestviews(end).expectedaddinfo)/unknownweight;
                                    else % add to list of impossible scans
                                        scan.done_bestviews_orfailed=[scan.done_bestviews_orfailed;newQ];
                                    end
                                end
                            end                            
                        end
                    end
                else
                    %add this to the list of places we can't get to
                    scan.done_bestviews_orfailed=[scan.done_bestviews_orfailed;[J1,J2,J3,inf,inf,inf]];
                end
            end
        end
    end
end

%% Check if any bestviews were found, if so order them
if isempty(bestviews)
    error('There were no bestviews found, probably because there are no known points to go too, or end_value_damper_weight is too high');
end

%order the best views
order_bestviews()

%% try and get at least 1 path then save the remaing valid_max-1
valid_count=0;
% this limits the amount of time we can spend searching for a path when
% there may not be one
valid_max=min(2*optimise.valid_max,size(bestviews,2));
for current_view=1:valid_max
    if valid_count<1
%         [bestviews(current_view).valid,bestviews(current_view).all_steps]=pathplanner(bestviews(current_view).Q,false,true,true,30);    
        [bestviews(current_view).valid,bestviews(current_view).all_steps]=pathplanner_new(bestviews(current_view).Q,false,true,true,30);    
    else %once we have one path then we just fill the rest in with blanks
        bestviews(current_view).valid=-1;
        bestviews(current_view).all_steps=[];        
    end
    
    if bestviews(current_view).valid || valid_count>=1
        valid_count=valid_count+1;
        tempbestviews(valid_count)=bestviews(current_view);   
        %we have enough (optimise.valid_max)
        if valid_count>=optimise.valid_max
            break;
        end
    else %it failed so note down that we can't get to this destination
        scan.done_bestviews_orfailed=[scan.done_bestviews_orfailed;bestviews(current_view).Q];
    end
end
%set to the new sorted and pathplanned tempbestviews
if valid_count==0
     error('There were no bestviews found, probably because there were no possible paths to any of the desired ones, consider changing end_value_damper_weight');
else
    bestviews=tempbestviews;
end


%% Display Results - currently commented
display(strcat('TOTAL Time taken is: ', num2str(etime(clock,timetaken))));
##### SOURCE END #####
-->
   </body>
</html>