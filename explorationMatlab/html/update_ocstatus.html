
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN">
<html xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   
      <!--
This HTML is auto-generated from an M-file.
To make changes, update the M-file and republish this document.
      -->
      <title>update_ocstatus</title>
      <meta name="generator" content="MATLAB 7.4">
      <meta name="date" content="2008-06-19">
      <meta name="m-file" content="update_ocstatus"><style>

body {
  background-color: white;
  margin:10px;
}

h1 {
  color: #990000; 
  font-size: x-large;
}

h2 {
  color: #990000;
  font-size: medium;
}

/* Make the text shrink to fit narrow windows, but not stretch too far in 
wide windows. */ 
p,h1,h2,div.content div {
  max-width: 600px;
  /* Hack for IE6 */
  width: auto !important; width: 600px;
}

pre.codeinput {
  background: #EEEEEE;
  padding: 10px;
}
@media print {
  pre.codeinput {word-wrap:break-word; width:100%;}
} 

span.keyword {color: #0000FF}
span.comment {color: #228B22}
span.string {color: #A020F0}
span.untermstring {color: #B20000}
span.syscmd {color: #B28C00}

pre.codeoutput {
  color: #666666;
  padding: 10px;
}

pre.error {
  color: red;
}

p.footer {
  text-align: right;
  font-size: xx-small;
  font-weight: lighter;
  font-style: italic;
  color: gray;
}

  </style></head>
   <body>
      <div class="content"><pre class="codeinput"><span class="comment">%function for updating the voxels status</span>
<span class="comment">%pass in a block of classified data that corresponds with the last scans</span>
<span class="comment">%PointData and RangeData</span>

<span class="comment">% should return nothing</span>

<span class="keyword">function</span> UNclassifiedvoxels=update_ocstatus(ClassifiedData)

<span class="keyword">global</span> workspace PointData RangeData robmap_h
<span class="comment">%get the variables from the workspace</span>
class_cubesize=workspace.class_cubesize;
minclassifications=workspace.minclassifications;
classfierthreshhold=workspace.classfierthreshhold;

pointswithclass=zeros([size(PointData,1)*size(PointData,2),4]);
CorrespondingRange=zeros([size(PointData,1)*size(PointData,2),1]);

<span class="keyword">for</span> i=1:size(PointData,1);
    pointswithclass((i-1)*size(PointData,2)+1:i*size(PointData,2),:)=[squeeze(PointData(i,:,:)),ClassifiedData(i,:)'];
    CorrespondingRange((i-1)*size(PointData,2)+1:i*size(PointData,2),:)=RangeData(i,:);
<span class="keyword">end</span>;

<span class="comment">%only use the points that are greater than 0 range since the others make no</span>
<span class="comment">%sense</span>
pointswithclass=pointswithclass(CorrespondingRange&gt;20,:);

<span class="comment">%discreatise into grid</span>
class_ocgrid=[round(pointswithclass(:,1:3)/class_cubesize),pointswithclass(:,4)];
[level1,level2]=GetImpLevInfo(class_ocgrid(:,1:3)*class_cubesize);
class_ocgrid=class_ocgrid(level2,:);

<span class="comment">% hold on;</span>
<span class="comment">% try planeplotHa(end+1)=plot3(class_ocgrid(:,1)*class_cubesize,class_ocgrid(:,2)*class_cubesize,class_ocgrid(:,3)*class_cubesize,'y','marker','.','markersize',0.1,'linestyle','none');end</span>


<span class="comment">% pnts=[-7,10,26;-9,3,30;-8,-13,27];</span>
<span class="comment">% pause</span>
<span class="comment">% for i=1:3</span>
<span class="comment">%     pnt=pnts(i,:);</span>
<span class="comment">%     text(pnt(1)*class_cubesize,pnt(2)*class_cubesize,pnt(3)*class_cubesize,num2str(i));</span>
<span class="comment">%     figure;hist(class_ocgrid(find(class_ocgrid(:,1)==pnt(1) &amp; class_ocgrid(:,2)==pnt(2) &amp; class_ocgrid(:,3)==pnt(3)),4))</span>
<span class="comment">%     pause</span>
<span class="comment">% end</span>

<span class="comment">%make sure the structure is valid</span>
<span class="keyword">if</span> ~isfield(workspace,<span class="string">'ocgrid'</span>);
    workspace.ocgrid=[];
<span class="keyword">end</span>
<span class="keyword">if</span> size(workspace.ocgrid,2)~=6
    tempocgrid=unique(class_ocgrid(:,1:3),<span class="string">'rows'</span>);
<span class="keyword">else</span>
    tempocgrid=setdiff(class_ocgrid(:,1:3),workspace.ocgrid(:,1:3),<span class="string">'rows'</span>);
<span class="keyword">end</span>
workspace.ocgrid=[workspace.ocgrid;tempocgrid,zeros([size(tempocgrid,1),3])];
[level1,level2]=GetImpLevInfo(workspace.ocgrid(:,1:3)*class_cubesize);
workspace.ocgrid=workspace.ocgrid(level2,:);
newoc_toupdate=unique(class_ocgrid(:,1:3),<span class="string">'rows'</span>);
[vals,indexa,indexb]=intersect(newoc_toupdate,workspace.ocgrid(:,1:3),<span class="string">'rows'</span>);

<span class="keyword">for</span> i=1:indexb
    tempdata=class_ocgrid(class_ocgrid(:,1)==workspace.ocgrid(i,1) &amp;<span class="keyword">...</span>
                          class_ocgrid(:,2)==workspace.ocgrid(i,2) &amp; <span class="keyword">...</span>
                          class_ocgrid(:,3)==workspace.ocgrid(i,3),4);
    metalnum=size(find(tempdata&lt;=5),1);
    woodnum=size(find(tempdata&gt;=6 &amp; tempdata&lt;=7),1);
    unknownnum=size(find(tempdata&gt;=8),1);
    workspace.ocgrid(i,4)=workspace.ocgrid(i,4)+metalnum;
    workspace.ocgrid(i,5)=workspace.ocgrid(i,5)+woodnum;
    workspace.ocgrid(i,6)=workspace.ocgrid(i,6)+unknownnum;
<span class="keyword">end</span>


<span class="comment">%we only want to hold the voxels which correspond with the current map</span>
aabb = [-1.5, -1.5, 0.2; 1.5, 1.5, 1.8];
<span class="comment">% aabb = [-inf, -inf, -inf; inf, inf, inf];</span>
hMesh = robmap_h.Mesh(aabb);
<span class="comment">% f = hMesh.FaceData;</span>
v = hMesh.VertexData;
[level1,level2]=GetImpLevInfo(v);
v_decrete=unique(round(v(level2,:)/class_cubesize),<span class="string">'rows'</span>);
[vals,indexa,indexb]=intersect(v_decrete,workspace.ocgrid(:,1:3),<span class="string">'rows'</span>);
workspace.ocgrid=workspace.ocgrid(indexb,:);

<span class="comment">% figure(2)</span>
sumofclass=workspace.ocgrid(:,4)+workspace.ocgrid(:,5);
warning(<span class="string">'off'</span>,<span class="string">'MATLAB:divideByZero'</span>)
<span class="comment">% try classifiedvoxels=find(sumofclass&gt;=minclassifications &amp;...</span>
<span class="comment">%                      (workspace.ocgrid(:,4)./workspace.ocgrid(:,5)&gt;classfierthreshhold |...</span>
<span class="comment">%                       workspace.ocgrid(:,5)./workspace.ocgrid(:,4)&gt;classfierthreshhold));end</span>
<span class="keyword">try</span> UNclassifiedvoxels=find(sumofclass&lt;minclassifications | <span class="keyword">...</span>
                     (workspace.ocgrid(:,4)./workspace.ocgrid(:,5)&lt;=classfierthreshhold &amp;<span class="keyword">...</span>
                      workspace.ocgrid(:,5)./workspace.ocgrid(:,4)&lt;=classfierthreshhold));<span class="keyword">end</span>
warning(<span class="string">'on'</span>,<span class="string">'MATLAB:divideByZero'</span>)
<span class="comment">% if show_classified</span>
<span class="comment">%     hold on;</span>
<span class="comment">%     try planeplotHa(end+1)=plot3(workspace.ocgrid(UNclassifiedvoxels,1)*class_cubesize,...</span>
<span class="comment">%           workspace.ocgrid(UNclassifiedvoxels,2)*class_cubesize,...</span>
<span class="comment">%           workspace.ocgrid(UNclassifiedvoxels,3)*class_cubesize,'y','marker','.','markersize',0.5,'linestyle','none');end</span>
<span class="comment">%     %plot metal and wood voxels</span>
<span class="comment">%</span>
<span class="comment">%     metalvoxels=workspace.ocgrid(classifiedvoxels(workspace.ocgrid(classifiedvoxels,4)&gt;workspace.ocgrid(classifiedvoxels,5)),1:3);</span>
<span class="comment">%     if size(metalvoxels,1)&gt;0</span>
<span class="comment">%         try planeplotHa(end+1)=plot3(metalvoxels(:,1)*class_cubesize,metalvoxels(:,2)*class_cubesize,metalvoxels(:,3)*class_cubesize,'r.');end</span>
<span class="comment">%     end</span>
<span class="comment">%</span>
<span class="comment">%     woodvoxels=workspace.ocgrid(classifiedvoxels(workspace.ocgrid(classifiedvoxels,4)&lt;workspace.ocgrid(classifiedvoxels,5)),1:3);</span>
<span class="comment">%     if size(woodvoxels,1)&gt;0</span>
<span class="comment">%         try planeplotHa(end+1)=plot3(woodvoxels(:,1)*class_cubesize,woodvoxels(:,2)*class_cubesize,woodvoxels(:,3)*class_cubesize,'b.');end</span>
<span class="comment">%     end</span>
<span class="comment">%</span>
<span class="comment">%     drawnow</span>
<span class="comment">% end</span>
</pre><p class="footer"><br>
            Published with MATLAB&reg; 7.4<br></p>
      </div>
      <!--
##### SOURCE BEGIN #####
%function for updating the voxels status
%pass in a block of classified data that corresponds with the last scans
%PointData and RangeData

% should return nothing

function UNclassifiedvoxels=update_ocstatus(ClassifiedData)

global workspace PointData RangeData robmap_h
%get the variables from the workspace 
class_cubesize=workspace.class_cubesize;
minclassifications=workspace.minclassifications;
classfierthreshhold=workspace.classfierthreshhold;

pointswithclass=zeros([size(PointData,1)*size(PointData,2),4]);
CorrespondingRange=zeros([size(PointData,1)*size(PointData,2),1]);

for i=1:size(PointData,1);
    pointswithclass((i-1)*size(PointData,2)+1:i*size(PointData,2),:)=[squeeze(PointData(i,:,:)),ClassifiedData(i,:)'];
    CorrespondingRange((i-1)*size(PointData,2)+1:i*size(PointData,2),:)=RangeData(i,:);
end;

%only use the points that are greater than 0 range since the others make no
%sense
pointswithclass=pointswithclass(CorrespondingRange>20,:);

%discreatise into grid
class_ocgrid=[round(pointswithclass(:,1:3)/class_cubesize),pointswithclass(:,4)];
[level1,level2]=GetImpLevInfo(class_ocgrid(:,1:3)*class_cubesize);
class_ocgrid=class_ocgrid(level2,:);

% hold on;
% try planeplotHa(end+1)=plot3(class_ocgrid(:,1)*class_cubesize,class_ocgrid(:,2)*class_cubesize,class_ocgrid(:,3)*class_cubesize,'y','marker','.','markersize',0.1,'linestyle','none');end


% pnts=[-7,10,26;-9,3,30;-8,-13,27];
% pause
% for i=1:3
%     pnt=pnts(i,:);
%     text(pnt(1)*class_cubesize,pnt(2)*class_cubesize,pnt(3)*class_cubesize,num2str(i));
%     figure;hist(class_ocgrid(find(class_ocgrid(:,1)==pnt(1) & class_ocgrid(:,2)==pnt(2) & class_ocgrid(:,3)==pnt(3)),4))
%     pause
% end

%make sure the structure is valid
if ~isfield(workspace,'ocgrid');
    workspace.ocgrid=[];
end
if size(workspace.ocgrid,2)~=6
    tempocgrid=unique(class_ocgrid(:,1:3),'rows');   
else
    tempocgrid=setdiff(class_ocgrid(:,1:3),workspace.ocgrid(:,1:3),'rows');
end
workspace.ocgrid=[workspace.ocgrid;tempocgrid,zeros([size(tempocgrid,1),3])];
[level1,level2]=GetImpLevInfo(workspace.ocgrid(:,1:3)*class_cubesize);
workspace.ocgrid=workspace.ocgrid(level2,:);
newoc_toupdate=unique(class_ocgrid(:,1:3),'rows');
[vals,indexa,indexb]=intersect(newoc_toupdate,workspace.ocgrid(:,1:3),'rows');

for i=1:indexb
    tempdata=class_ocgrid(class_ocgrid(:,1)==workspace.ocgrid(i,1) &...
                          class_ocgrid(:,2)==workspace.ocgrid(i,2) & ...
                          class_ocgrid(:,3)==workspace.ocgrid(i,3),4);
    metalnum=size(find(tempdata<=5),1);
    woodnum=size(find(tempdata>=6 & tempdata<=7),1);
    unknownnum=size(find(tempdata>=8),1);
    workspace.ocgrid(i,4)=workspace.ocgrid(i,4)+metalnum;
    workspace.ocgrid(i,5)=workspace.ocgrid(i,5)+woodnum;
    workspace.ocgrid(i,6)=workspace.ocgrid(i,6)+unknownnum;
end


%we only want to hold the voxels which correspond with the current map
aabb = [-1.5, -1.5, 0.2; 1.5, 1.5, 1.8];
% aabb = [-inf, -inf, -inf; inf, inf, inf];
hMesh = robmap_h.Mesh(aabb);
% f = hMesh.FaceData;
v = hMesh.VertexData;
[level1,level2]=GetImpLevInfo(v);
v_decrete=unique(round(v(level2,:)/class_cubesize),'rows');
[vals,indexa,indexb]=intersect(v_decrete,workspace.ocgrid(:,1:3),'rows');
workspace.ocgrid=workspace.ocgrid(indexb,:);

% figure(2)
sumofclass=workspace.ocgrid(:,4)+workspace.ocgrid(:,5);
warning('off','MATLAB:divideByZero')
% try classifiedvoxels=find(sumofclass>=minclassifications &...
%                      (workspace.ocgrid(:,4)./workspace.ocgrid(:,5)>classfierthreshhold |...
%                       workspace.ocgrid(:,5)./workspace.ocgrid(:,4)>classfierthreshhold));end
try UNclassifiedvoxels=find(sumofclass<minclassifications | ...
                     (workspace.ocgrid(:,4)./workspace.ocgrid(:,5)<=classfierthreshhold &...
                      workspace.ocgrid(:,5)./workspace.ocgrid(:,4)<=classfierthreshhold));end
warning('on','MATLAB:divideByZero')
% if show_classified
%     hold on;
%     try planeplotHa(end+1)=plot3(workspace.ocgrid(UNclassifiedvoxels,1)*class_cubesize,...
%           workspace.ocgrid(UNclassifiedvoxels,2)*class_cubesize,...
%           workspace.ocgrid(UNclassifiedvoxels,3)*class_cubesize,'y','marker','.','markersize',0.5,'linestyle','none');end
%     %plot metal and wood voxels
% 
%     metalvoxels=workspace.ocgrid(classifiedvoxels(workspace.ocgrid(classifiedvoxels,4)>workspace.ocgrid(classifiedvoxels,5)),1:3);
%     if size(metalvoxels,1)>0
%         try planeplotHa(end+1)=plot3(metalvoxels(:,1)*class_cubesize,metalvoxels(:,2)*class_cubesize,metalvoxels(:,3)*class_cubesize,'r.');end
%     end
% 
%     woodvoxels=workspace.ocgrid(classifiedvoxels(workspace.ocgrid(classifiedvoxels,4)<workspace.ocgrid(classifiedvoxels,5)),1:3);
%     if size(woodvoxels,1)>0
%         try planeplotHa(end+1)=plot3(woodvoxels(:,1)*class_cubesize,woodvoxels(:,2)*class_cubesize,woodvoxels(:,3)*class_cubesize,'b.');end
%     end
% 
%     drawnow
% end

##### SOURCE END #####
-->
   </body>
</html>