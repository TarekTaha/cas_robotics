
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN">
<html xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   
      <!--
This HTML is auto-generated from an M-file.
To make changes, update the M-file and republish this document.
      -->
      <title>blasting_posesel</title>
      <meta name="generator" content="MATLAB 7.4">
      <meta name="date" content="2008-01-14">
      <meta name="m-file" content="blasting_posesel_development"><style>

body {
  background-color: white;
  margin:10px;
}

h1 {
  color: #990000; 
  font-size: x-large;
}

h2 {
  color: #990000;
  font-size: medium;
}

/* Make the text shrink to fit narrow windows, but not stretch too far in 
wide windows. */ 
p,h1,h2,div.content div {
  max-width: 600px;
  /* Hack for IE6 */
  width: auto !important; width: 600px;
}

pre.codeinput {
  background: #EEEEEE;
  padding: 10px;
}
@media print {
  pre.codeinput {word-wrap:break-word; width:100%;}
} 

span.keyword {color: #0000FF}
span.comment {color: #228B22}
span.string {color: #A020F0}
span.untermstring {color: #B20000}
span.syscmd {color: #B28C00}

pre.codeoutput {
  color: #666666;
  padding: 10px;
}

pre.error {
  color: red;
}

p.footer {
  text-align: right;
  font-size: xx-small;
  font-weight: lighter;
  font-style: italic;
  color: gray;
}

  </style></head>
   <body>
      <div class="content">
         <h1>blasting_posesel</h1>
         <introduction>
            <p><b>Description:</b> based on streamOnto - specially made for blasting given a start q it will try and plast a point pt in space within an angle
               to the normal to the plane. It will try and minimise the distance between where the blast hits the plane and the center of
               the given plane. It may use various start positions if not using quick version Returns the joint coordinates corresponding
               to the end-effector at pt Note that the inverse kinematic solution is generally not unique, and depends on the initial guess
               Q (which defaults to 0). Also returns whether solution is valid and which method used and the dist_val to the required tr
            </p>
         </introduction>
         <h2>Contents</h2>
         <div>
            <ul>
               <li><a href="#1">Function Call</a></li>
               <li><a href="#2">Variables</a></li>
               <li><a href="#3">Do the least squared optimisation function using q passed in</a></li>
               <li><a href="#4">Check the optimisation results, change start to all Zeros if necessary</a></li>
               <li><a href="#5">If quickver we are only doing the quick version</a></li>
               <li><a href="#6">Extended find (2 extra starting qs)</a></li>
               <li><a href="#7">EMBEDDED FUNCTION: Run iteratively changing delta q (dq)</a></li>
               <li><a href="#8">Error Vector (being minimised) in embedded cost calc function</a></li>
               <li><a href="#9">FUNCTION: checks pose validity, if valid but dist&gt;min, return distance</a></li>
            </ul>
         </div>
         <h2>Function Call<a name="1"></a></h2>
         <p><b>Inputs:</b></p>
         <p><i>robot</i> (structure) This holds the robot object
         </p>
         <p><i>pt</i> (1*3 double) cartitian point where we want end effector <a href="br">br</a></p>
         <p><i>targetNormal</i> (1*3 double) the desired target normal at the point
         </p>
         <p><i>q</i> (1*6 double) radians - The joint config starting guess
         </p>
         <p><i>quickver</i> (binary) Whether to try more than q and all 0 for start joint configs. Possibly Less acurate but quicker
         </p>
         <p><b>Returns:</b></p>
         <p><i>qt</i> (1*6 double) radians - The recommended joint config
         </p>
         <p><i>solutionvalid</i> (binary) whether the returned qt gives a valid solution within optimisation parameters
         </p>
         <p><i>used_sol</i> (1-&gt;4 int) which solution for starting q was used
         </p>
         <p><i>targetdist</i> (structure) 2 values, (1)Distance between end effector and plane, (2) Distance between end effector (nozzel) and pt
         </p>
         <p><i>dist_val</i> (double) Distance between where the plane is hit with blast stream and pt
         </p><pre class="codeinput"><span class="keyword">function</span> [qt,solutionvalid,dist_val,targetdist,used_sol] = blasting_posesel(robot, pt, plane_equ, q, quickver)

<span class="comment">% load pointcloud</span>
<span class="comment">% pointsindex=find(points(:,1)&gt;-0.2 &amp; points(:,1)&lt;0.2 &amp; points(:,2)&gt;-0.2 &amp; points(:,2)&lt;0.2);</span>
<span class="comment">% points=points(pointsindex,:);</span>
<span class="comment">% surface_making_simple(points,0.04);</span>
<span class="comment">% global plane</span>
</pre><h2>Variables<a name="2"></a></h2>
         <p><img vspace="5" hspace="5" src="blasting_posesel_development_eq120752.png"> </p><pre class="codeinput">    <span class="keyword">global</span> optimise densoobj workspace r;

    <span class="comment">%default is true, unless proven otherwise</span>
    solutionvalid=true;

    <span class="keyword">if</span> size(pt, 1) == 1
        pt = pt(:); <span class="comment">% make sure pt is a column vector</span>
    <span class="keyword">end</span>

    <span class="comment">% make sure targetNormal is a column vector (unit)</span>
    targetNormal = plane_equ(1:3)/ norm(plane_equ(1:3));
    targetNormal=targetNormal(:);

    numlinks = robot.n;
    Links = robot.link;
    t = robot.base;
    qlimits=robot.qlim;

    <span class="comment">%make sure the q is correct</span>
    <span class="keyword">if</span> nargin &lt; 3
        q = zeros(numlinks, 1);
    <span class="keyword">else</span>
        q = q(:);
    <span class="keyword">end</span>
    <span class="comment">%only use the first 5 joints since the 6th makes no difference</span>
    q=q(1:5);

    q_input=q; <span class="comment">%save the input q (or made up q) for later</span>

    options = optimset(<span class="string">'Display'</span>, <span class="string">'off'</span>, <span class="string">'Largescale'</span>, <span class="string">'off'</span>, <span class="string">'TolFun'</span>, optimise.stol,<span class="string">'MaxFunEvals'</span>, optimise.iLimit,<span class="string">'DiffMinChange'</span>,optimise.jointresolution);

    xGuess = zeros(size(q));lb = []; ub = [];
</pre><h2>Do the least squared optimisation function using q passed in<a name="3"></a></h2><pre class="codeinput">    [dq] = lsqnonlin(@costComponents, xGuess, lb, ub, options);

    <span class="comment">% Update the configuration</span>
    qt = [q + dq;0]; all_qts(1).val=qt;

    <span class="comment">%if there is a collision or out of joint limit then no distance is returned</span>
    dist=[inf,inf,inf,inf];
</pre><h2>Check the optimisation results, change start to all Zeros if necessary<a name="4"></a></h2><pre class="codeinput">    [valid,dist(1),targetdist(1).val]=check_newQ(qt,qlimits,pt,t,Links,numlinks,plane_equ);
    <span class="keyword">if</span> valid; used_sol=1; dist_val= dist(1); qt=qt'; <span class="keyword">return</span>;
    <span class="keyword">else</span>
        <span class="comment">%check if current q =0, otherwise try getting a solution with q=0</span>
        <span class="keyword">if</span> ~isempty(find(q(1:3)~=0, 1))
            q = zeros(numlinks-1, 1);
            [dq] = lsqnonlin(@costComponents, xGuess, lb, ub, options);
            qt = [q + dq;0]; all_qts(2).val=qt;
            [valid,dist(2),targetdist(2).val]=check_newQ(qt,qlimits,pt,t,Links,numlinks,plane_equ);
            <span class="keyword">if</span> valid; used_sol=2; dist_val= dist(2); qt=qt'; <span class="keyword">return</span>; <span class="keyword">end</span>
        <span class="keyword">end</span>
</pre><h2>If quickver we are only doing the quick version<a name="5"></a></h2><pre class="codeinput">        <span class="comment">%only using 1/2 num of starts so quit here even if no result found</span>
        <span class="keyword">if</span> quickver
            [dist_val,used_sol]=min(dist);
            <span class="keyword">if</span> dist_val==inf; solutionvalid=false; used_sol=0; qt=qt';<span class="keyword">return</span>;
            <span class="keyword">else</span> qt=all_qts(used_sol).val; solutionvalid=-1; qt=qt';<span class="keyword">return</span>;
            <span class="keyword">end</span>;
        <span class="keyword">end</span>
</pre><h2>Extended find (2 extra starting qs)<a name="6"></a></h2><pre class="codeinput">        <span class="comment">%Try a guess which starts at 90' off the current Q, this might find a solution</span>
        q=q_input+((sqrt(q_input.^2)~=q_input)*2-1)*pi;
        [dq] = lsqnonlin(@costComponents, xGuess, lb, ub, options);
        qt = [q + dq;0]; all_qts(3).val=qt;
        [valid,dist(3),targetdist(3).val]=check_newQ(qt,qlimits,pt,t,Links,numlinks,plane_equ);
        <span class="keyword">if</span> valid; used_sol=3; dist_val= dist(3); qt=qt'; <span class="keyword">return</span>; <span class="keyword">end</span>

        <span class="comment">%Try randomly guessing a starting point</span>
        q=[0;0;0;0;0];
        <span class="keyword">for</span> i=1:size(qlimits,1)-1;  q(i)=rand()*(-qlimits(i,1)+qlimits(i,2))+qlimits(i,1); <span class="keyword">end</span>
        [dq] = lsqnonlin(@costComponents, xGuess, lb, ub, options);
        qt = [q + dq;0]; all_qts(4).val=qt;
        [valid,dist(4),targetdist(4).val]=check_newQ(qt,qlimits,pt,t,Links,numlinks,plane_equ);
        <span class="keyword">if</span> valid; used_sol=4; dist_val= dist(4); qt=qt'; <span class="keyword">return</span>;  <span class="keyword">end</span>

        [dist_val,used_sol]=min(dist);
        <span class="keyword">if</span> dist_val==inf
            <span class="comment">%if we haven't left the function yet then the solution is not valid</span>
            solutionvalid=false;
            used_sol=0; qt=qt';<span class="keyword">return</span>;
        <span class="keyword">else</span> qt=all_qts(used_sol).val;
            solutionvalid=-1;
            qt=qt';<span class="keyword">return</span>;
        <span class="keyword">end</span>
    <span class="keyword">end</span>
</pre><h2>EMBEDDED FUNCTION: Run iteratively changing delta q (dq)<a name="7"></a></h2>
         <p><img vspace="5" hspace="5" src="blasting_posesel_development_eq60749.png"> </p><pre class="codeinput"><span class="comment">% \end{arrary}$$</span>
    <span class="keyword">function</span> [e]=costComponents(dq)
        tr=t;
        q_temp=[q+dq;0];
<span class="comment">%         q_temp=q+dq;</span>
        Jlimitresult=[0,0,0,0,0,0];
        result_row=[1,1,1,1,1,1];
        <span class="comment">%check each joint and link for collisions and exceeding limits</span>
        <span class="keyword">for</span> i=1:numlinks;
            tr = tr * Links{i}(q_temp(i));
            <span class="keyword">if</span> q_temp(i)&lt;qlimits(i,1); Jlimitresult(i)=qlimits(i,1)-q_temp(i);
            <span class="keyword">elseif</span> q_temp(i)&gt;qlimits(i,2); Jlimitresult(i)=q_temp(i)-qlimits(i,2);
            <span class="keyword">end</span>
            <span class="keyword">if</span> i&gt;2
                tempresult=check_FF(tr,densoobj(i+1).ellipse,workspace.indexedobsticles);
                result_row(i)=tempresult;
                <span class="keyword">if</span> tempresult~=1
<span class="comment">%                     keyboard</span>
                <span class="keyword">end</span>
            <span class="keyword">end</span>
        <span class="keyword">end</span>
</pre><h2>Error Vector (being minimised) in embedded cost calc function<a name="8"></a></h2>
         <p>$$e=\left( \begin{array}{c} e^{4( \sqrt{(P_{dt,x}-P_{at,x})^2+(P_{dt,y}-P_{at,y})^2+(P_{dt,z}-P_{at,z})^2}-C_{maxtargetdis})}\\
            e^{4( \sqrt{(P_{z,x}-P_{az,x})^2+(P_{z,y}-P_{az,y})^2+(P_{z,z}-P_{az,z})^2}-C_{maxtargetdis})}\\ e^{10( dist_pt2tr(pt,tr)-C_{minAccepDis})}\\
            \frac{e^{5( <tt>Q_{5th}</tt>-C_{maxDeflectionError})}}{100}\\ e^{5\times \sum{Jlimitresult}}-1\\ e^{5(6-\sum{result\_row}}-1\\ \end{array} \right)$$ stream
            length should be distance to actual point of intersection
         </p><pre class="codeinput">disttotarget=dist_pt2tr(pt,tr);
theta = acos(plane_equ(1:3)*unit((tr(1:3,3)+tr(1:3,4))));
<span class="comment">% theta=acos(dot(targetNormal,unit(tr(1:3,3)+tr(1:3,4))));</span>
<span class="comment">% theta*180/pi</span>
<span class="comment">% plot(r,q_temp','joints');hold on; plot3(pt(1),pt(2),pt(3),'r*')</span>
<span class="comment">% drawnow</span>

<span class="comment">%     streamStart=tr(1:3,4);</span>
<span class="comment">%     streamEnd=tr(1:3,3)'+tr(1:3,4)';</span>
<span class="comment">%     r_var=[streamStart(1)-streamEnd(1),streamStart(2)-streamEnd(2),streamStart(3)-streamEnd(3)];</span>
    r_var=-tr(1:3,3)';

    <span class="comment">%find intersection point between surface and the scan line between scan origin and point</span>
    bottomof_t_var=plane_equ(1)*r_var(1)+<span class="keyword">...</span>
                   plane_equ(2)*r_var(2)+<span class="keyword">...</span>
                   plane_equ(3)*r_var(3);
    <span class="comment">%make sure it is not 0 otherwise change it so it is simply a very small</span>
    <span class="comment">%number (epsilon)</span>
    <span class="keyword">if</span> ~isempty(find(bottomof_t_var==0, 1)); bottomof_t_var=eps; <span class="keyword">end</span>
    t_var=( plane_equ(1)*tr(1,4)+<span class="keyword">...</span>
            plane_equ(2)*tr(2,4)+<span class="keyword">...</span>
            plane_equ(3)*tr(3,4)+<span class="keyword">...</span>
            plane_equ(4)<span class="keyword">...</span>
           )./ bottomof_t_var;

    <span class="comment">% Get the intersection points</span>
    intersectionPNT=[t_var.*-r_var(1)+tr(1,4),<span class="keyword">...</span>
                     t_var.*-r_var(2)+tr(2,4),<span class="keyword">...</span>
                     t_var.*-r_var(3)+tr(3,4)];

streamlength=dist_pt2tr(intersectionPNT,tr);
<span class="comment">%determine distance from unit long stream length to intersectionPNT to make</span>
<span class="comment">%sure that it is on the same side</span>
streamEnd=tr(1:3,3)'+tr(1:3,4)';
cor_orient_vec_streamlen=sqrt((intersectionPNT(1)-streamEnd(1))^2+<span class="keyword">...</span>
                                          (intersectionPNT(2)-streamEnd(2))^2+<span class="keyword">...</span>
                                          (intersectionPNT(3)-streamEnd(3))^2);

<span class="comment">%         e = [exp(-5*(optimise.maxtargetdis-streamlength));</span>
<span class="comment">%              exp(-10*(streamlength-optimise.mintargetdis));</span>
<span class="comment">%              exp(10*(sqrt((pt(1)-intersectionPNT(1))^2+...</span>
<span class="comment">%                           (pt(2)-intersectionPNT(2))^2+...</span>
<span class="comment">%                           (pt(3)-intersectionPNT(3))^2)-optimise.minAccepDis));</span>
<span class="comment">%              exp(5*(theta-optimise.maxDeflectionError));</span>
<span class="comment">%              exp(5*sum(Jlimitresult))-1;</span>
<span class="comment">%              exp(5*(6-sum(result_row)))-1];</span>
         e = [exp(10*(disttotarget-optimise.maxtargetdis));
              exp(10*(optimise.mintargetdis-disttotarget));
             exp((streamlength-optimise.maxtargetdis)/10);
              exp((optimise.mintargetdis-streamlength)/10);
              exp((cor_orient_vec_streamlen-(1-optimise.mintargetdis))/5);
              exp((sqrt((pt(1)-intersectionPNT(1))^2+<span class="keyword">...</span>
                        (pt(2)-intersectionPNT(2))^2+<span class="keyword">...</span>
                        (pt(3)-intersectionPNT(3))^2)-optimise.minAccepDis)/10);
              exp(theta-optimise.maxDeflectionError);
              exp(5*sum(Jlimitresult))-1;
              exp(5*(6-sum(result_row)))-1];
    <span class="keyword">end</span>
<span class="keyword">end</span>
</pre><h2>FUNCTION: checks pose validity, if valid but dist&gt;min, return distance<a name="9"></a></h2><pre class="codeinput"><span class="keyword">function</span> [valid,dist,targetdist]=check_newQ(qt,qlimits,pt,tr,Links,numlinks,plane_equ)
    <span class="keyword">global</span> optimise densoobj workspace;
    <span class="comment">%returns infinite distance by default</span>
    dist=inf;

    <span class="comment">%distance from tr to target pt, distance from tr to target plane</span>
    targetdist=[inf,inf];

    <span class="comment">%it is not valid by default so we can return at anytime and return invalid</span>
    valid=false;

    <span class="comment">%from base transform of the robot check each joint and fkine through</span>
    <span class="keyword">for</span> i=1:numlinks;
        tr = tr * Links{i}(qt(i));
        <span class="keyword">if</span> qt(i)&lt;qlimits(i,1) || qt(i)&gt;qlimits(i,2); <span class="keyword">return</span>; <span class="keyword">end</span>;
        <span class="keyword">if</span> ~check_FF(tr,densoobj(i+1).ellipse,workspace.indexedobsticles); <span class="keyword">return</span>; <span class="keyword">end</span>;
    <span class="keyword">end</span>

    <span class="comment">% Check the actual distance from end effector to target point</span>
    targetdist(1)=dist_pt2tr(pt,tr);

    streamStart=tr(1:3,4);
<span class="comment">%     streamEnd=tr(1:3,3)'+tr(1:3,4)';</span>
<span class="comment">%     r_var=[streamStart(1)-streamEnd(1),...</span>
<span class="comment">%            streamStart(2)-streamEnd(2),...</span>
<span class="comment">%            streamStart(3)-streamEnd(3)];</span>
    r_var=-tr(1:3,3);

    <span class="comment">%find intersection point between surface and the scan line between scan origin and point</span>
    bottomof_t_var=plane_equ(1)*r_var(1)+<span class="keyword">...</span>
                   plane_equ(2)*r_var(2)+<span class="keyword">...</span>
                   plane_equ(3)*r_var(3);
    <span class="comment">%make sure it is not 0 otherwise change it so it is simply a very small</span>
    <span class="comment">%number (epsilon)</span>
    <span class="keyword">if</span> ~isempty(find(bottomof_t_var==0, 1)); bottomof_t_var(bottomof_t_var==0)=eps; <span class="keyword">end</span>
    t_var=( plane_equ(1)*tr(1,4)+<span class="keyword">...</span>
            plane_equ(2)*tr(2,4)+<span class="keyword">...</span>
            plane_equ(3)*tr(3,4)+<span class="keyword">...</span>
            plane_equ(4)<span class="keyword">...</span>
           )./ bottomof_t_var;

    <span class="comment">% Get the intersection points</span>
    intersectionPNT=[t_var.*-r_var(1)+tr(1,4),<span class="keyword">...</span>
                     t_var.*-r_var(2)+tr(2,4),<span class="keyword">...</span>
                     t_var.*-r_var(3)+tr(3,4)];

    targetdist(2)=dist_pt2tr(intersectionPNT,tr);

    <span class="comment">%the distance on the plane between where we aimed and where it hit is</span>
    dist=sqrt((pt(1)-intersectionPNT(1))^2+<span class="keyword">...</span>
              (pt(2)-intersectionPNT(2))^2+<span class="keyword">...</span>
              (pt(3)-intersectionPNT(3))^2);

    <span class="comment">%angle between line and plane</span>
    theta = acos(plane_equ(1:3)*unit((tr(1:3,3)+tr(1:3,4))));

    <span class="comment">%if it is allowable then it is valid and change this to return</span>
    <span class="keyword">if</span> targetdist(2)&lt;optimise.mintargetdis||<span class="keyword">...</span>
       targetdist(2)&gt;optimise.maxtargetdis||<span class="keyword">...</span>
       dist&gt;optimise.minAccepDis ||<span class="keyword">...</span>
       theta&gt;optimise.maxDeflectionError
        display(<span class="string">'Didnt find perfect solution but may still be good enough'</span>);
        display([<span class="string">'values: dist= '</span>,num2str(dist),<span class="string">' targetdist(2) = '</span>,num2str(targetdist(2)),<span class="string">' theta(deg)= '</span>,num2str(theta*180/pi)])
        <span class="keyword">return</span>;
    <span class="keyword">else</span>
        <span class="comment">%if we get to here it is valid</span>
        valid=true;
        display(<span class="string">'Found a solution'</span>);
        display([<span class="string">'values: dist= '</span>,num2str(dist),<span class="string">' targetdist(2) = '</span>,num2str(targetdist(2)),<span class="string">' theta(deg)= '</span>,num2str(theta*180/pi)])
    <span class="keyword">end</span>;
<span class="keyword">end</span>
</pre><p class="footer"><br>
            Published with MATLAB&reg; 7.4<br></p>
      </div>
      <!--
##### SOURCE BEGIN #####
%% blasting_posesel
%
% *Description:* based on streamOnto - specially made for blasting
% given a start q it will try and plast a point pt in space within an angle
% to the normal to the plane. It will try and minimise the distance between
% where the blast hits the plane and the center of the given plane. 
% It may use various start positions if not using quick version
% Returns the joint coordinates corresponding to the end-effector at pt
% Note that the inverse kinematic solution is generally not unique, and 
% depends on the initial guess Q (which defaults to 0).
% Also returns whether solution is valid and which method used and the
% dist_val to the required tr


%% Function Call
% *Inputs:* 
%
% _robot_ (structure) This holds the robot object
%
% _pt_ (1*3 double) cartitian point where we want end effector <br>
%
% _targetNormal_ (1*3 double) the desired target normal at the point
%
% _q_ (1*6 double) radians - The joint config starting guess 
%
% _quickver_ (binary) Whether to try more than q and all 0 for start joint
% configs. Possibly Less acurate but quicker 
%
% *Returns:*
%
% _qt_ (1*6 double) radians - The recommended joint config
%
% _solutionvalid_ (binary) whether the returned qt gives a valid solution
% within optimisation parameters
%
% _used_sol_ (1->4 int) which solution for starting q was used
%
% _targetdist_ (structure) 2 values, (1)Distance between end effector and
% plane, (2) Distance between end effector (nozzel) and pt
%
% _dist_val_ (double) Distance between where the plane is hit with blast stream and pt

function [qt,solutionvalid,dist_val,targetdist,used_sol] = blasting_posesel(robot, pt, plane_equ, q, quickver)

% load pointcloud
% pointsindex=find(points(:,1)>-0.2 & points(:,1)<0.2 & points(:,2)>-0.2 & points(:,2)<0.2);
% points=points(pointsindex,:);
% surface_making_simple(points,0.04);
% global plane


%% Variables
% $$ \begin{array}{lc}
% \mbox{targetNormal...} & V_{tn} \\
% \end{array}$$
    global optimise densoobj workspace r;
    
    %default is true, unless proven otherwise
    solutionvalid=true;
    
    if size(pt, 1) == 1
        pt = pt(:); % make sure pt is a column vector
    end

    % make sure targetNormal is a column vector (unit)
    targetNormal = plane_equ(1:3)/ norm(plane_equ(1:3));
    targetNormal=targetNormal(:);

    numlinks = robot.n;
    Links = robot.link; 
    t = robot.base;
    qlimits=robot.qlim; 
    
    %make sure the q is correct
    if nargin < 3
        q = zeros(numlinks, 1);
    else
        q = q(:);
    end
    %only use the first 5 joints since the 6th makes no difference
    q=q(1:5);
    
    q_input=q; %save the input q (or made up q) for later

    options = optimset('Display', 'off', 'Largescale', 'off', 'TolFun', optimise.stol,'MaxFunEvals', optimise.iLimit,'DiffMinChange',optimise.jointresolution);
 
    xGuess = zeros(size(q));lb = []; ub = [];
    
%% Do the least squared optimisation function using q passed in       
    [dq] = lsqnonlin(@costComponents, xGuess, lb, ub, options);

    % Update the configuration
    qt = [q + dq;0]; all_qts(1).val=qt;
    
    %if there is a collision or out of joint limit then no distance is returned
    dist=[inf,inf,inf,inf];    
        
%% Check the optimisation results, change start to all Zeros if necessary
    [valid,dist(1),targetdist(1).val]=check_newQ(qt,qlimits,pt,t,Links,numlinks,plane_equ); 
    if valid; used_sol=1; dist_val= dist(1); qt=qt'; return;
    else
        %check if current q =0, otherwise try getting a solution with q=0
        if ~isempty(find(q(1:3)~=0, 1))
            q = zeros(numlinks-1, 1);
            [dq] = lsqnonlin(@costComponents, xGuess, lb, ub, options);   
            qt = [q + dq;0]; all_qts(2).val=qt;
            [valid,dist(2),targetdist(2).val]=check_newQ(qt,qlimits,pt,t,Links,numlinks,plane_equ); 
            if valid; used_sol=2; dist_val= dist(2); qt=qt'; return; end
        end
        
%% If quickver we are only doing the quick version 
        %only using 1/2 num of starts so quit here even if no result found
        if quickver
            [dist_val,used_sol]=min(dist);
            if dist_val==inf; solutionvalid=false; used_sol=0; qt=qt';return;
            else qt=all_qts(used_sol).val; solutionvalid=-1; qt=qt';return;
            end;
        end
            
%% Extended find (2 extra starting qs)    
        %Try a guess which starts at 90' off the current Q, this might find a solution 
        q=q_input+((sqrt(q_input.^2)~=q_input)*2-1)*pi;
        [dq] = lsqnonlin(@costComponents, xGuess, lb, ub, options);
        qt = [q + dq;0]; all_qts(3).val=qt;
        [valid,dist(3),targetdist(3).val]=check_newQ(qt,qlimits,pt,t,Links,numlinks,plane_equ);
        if valid; used_sol=3; dist_val= dist(3); qt=qt'; return; end
 
        %Try randomly guessing a starting point
        q=[0;0;0;0;0];
        for i=1:size(qlimits,1)-1;  q(i)=rand()*(-qlimits(i,1)+qlimits(i,2))+qlimits(i,1); end
        [dq] = lsqnonlin(@costComponents, xGuess, lb, ub, options);
        qt = [q + dq;0]; all_qts(4).val=qt;
        [valid,dist(4),targetdist(4).val]=check_newQ(qt,qlimits,pt,t,Links,numlinks,plane_equ);
        if valid; used_sol=4; dist_val= dist(4); qt=qt'; return;  end
        
        [dist_val,used_sol]=min(dist);
        if dist_val==inf
            %if we haven't left the function yet then the solution is not valid
            solutionvalid=false;    
            used_sol=0; qt=qt';return;
        else qt=all_qts(used_sol).val;
            solutionvalid=-1;
            qt=qt';return;
        end
    end
        
%% EMBEDDED FUNCTION: Run iteratively changing delta q (dq)
% $$ \begin{array}{lc}
% \mbox{rewrite this}
% \end{array}$$

% \end{arrary}$$
    function [e]=costComponents(dq)
        tr=t;          
        q_temp=[q+dq;0];
%         q_temp=q+dq;
        Jlimitresult=[0,0,0,0,0,0];
        result_row=[1,1,1,1,1,1];
        %check each joint and link for collisions and exceeding limits
        for i=1:numlinks; 
            tr = tr * Links{i}(q_temp(i));
            if q_temp(i)<qlimits(i,1); Jlimitresult(i)=qlimits(i,1)-q_temp(i);
            elseif q_temp(i)>qlimits(i,2); Jlimitresult(i)=q_temp(i)-qlimits(i,2);
            end
            if i>2
                tempresult=check_FF(tr,densoobj(i+1).ellipse,workspace.indexedobsticles);                
                result_row(i)=tempresult;
                if tempresult~=1
%                     keyboard
                end
            end
        end


%% Error Vector (being minimised) in embedded cost calc function
% $$e=\left( \begin{array}{c}
% e^{4( \sqrt{(P_{dt,x}-P_{at,x})^2+(P_{dt,y}-P_{at,y})^2+(P_{dt,z}-P_{at,z})^2}-C_{maxtargetdis})}\\
% e^{4( \sqrt{(P_{z,x}-P_{az,x})^2+(P_{z,y}-P_{az,y})^2+(P_{z,z}-P_{az,z})^2}-C_{maxtargetdis})}\\
% e^{10( dist_pt2tr(pt,tr)-C_{minAccepDis})}\\
% \frac{e^{5( |Q_{5th}|-C_{maxDeflectionError})}}{100}\\
% e^{5\times \sum{Jlimitresult}}-1\\
% e^{5(6-\sum{result\_row}}-1\\
% \end{array} \right)$$
% stream length should be distance to actual point of intersection
disttotarget=dist_pt2tr(pt,tr);
theta = acos(plane_equ(1:3)*unit((tr(1:3,3)+tr(1:3,4))));
% theta=acos(dot(targetNormal,unit(tr(1:3,3)+tr(1:3,4))));
% theta*180/pi
% plot(r,q_temp','joints');hold on; plot3(pt(1),pt(2),pt(3),'r*')
% drawnow

%     streamStart=tr(1:3,4);
%     streamEnd=tr(1:3,3)'+tr(1:3,4)';
%     r_var=[streamStart(1)-streamEnd(1),streamStart(2)-streamEnd(2),streamStart(3)-streamEnd(3)];
    r_var=-tr(1:3,3)';

    %find intersection point between surface and the scan line between scan origin and point
    bottomof_t_var=plane_equ(1)*r_var(1)+...
                   plane_equ(2)*r_var(2)+...
                   plane_equ(3)*r_var(3);
    %make sure it is not 0 otherwise change it so it is simply a very small
    %number (epsilon)
    if ~isempty(find(bottomof_t_var==0, 1)); bottomof_t_var=eps; end                                                                               
    t_var=( plane_equ(1)*tr(1,4)+...
            plane_equ(2)*tr(2,4)+...
            plane_equ(3)*tr(3,4)+...
            plane_equ(4)...
           )./ bottomof_t_var;                 

    % Get the intersection points
    intersectionPNT=[t_var.*-r_var(1)+tr(1,4),...
                     t_var.*-r_var(2)+tr(2,4),...
                     t_var.*-r_var(3)+tr(3,4)];

streamlength=dist_pt2tr(intersectionPNT,tr);
%determine distance from unit long stream length to intersectionPNT to make
%sure that it is on the same side
streamEnd=tr(1:3,3)'+tr(1:3,4)';
cor_orient_vec_streamlen=sqrt((intersectionPNT(1)-streamEnd(1))^2+...
                                          (intersectionPNT(2)-streamEnd(2))^2+...
                                          (intersectionPNT(3)-streamEnd(3))^2);
                 
%         e = [exp(-5*(optimise.maxtargetdis-streamlength));
%              exp(-10*(streamlength-optimise.mintargetdis));
%              exp(10*(sqrt((pt(1)-intersectionPNT(1))^2+...
%                           (pt(2)-intersectionPNT(2))^2+...
%                           (pt(3)-intersectionPNT(3))^2)-optimise.minAccepDis));
%              exp(5*(theta-optimise.maxDeflectionError));
%              exp(5*sum(Jlimitresult))-1;
%              exp(5*(6-sum(result_row)))-1]; 
         e = [exp(10*(disttotarget-optimise.maxtargetdis));
              exp(10*(optimise.mintargetdis-disttotarget));
             exp((streamlength-optimise.maxtargetdis)/10);
              exp((optimise.mintargetdis-streamlength)/10);
              exp((cor_orient_vec_streamlen-(1-optimise.mintargetdis))/5);
              exp((sqrt((pt(1)-intersectionPNT(1))^2+...
                        (pt(2)-intersectionPNT(2))^2+...
                        (pt(3)-intersectionPNT(3))^2)-optimise.minAccepDis)/10);
              exp(theta-optimise.maxDeflectionError);
              exp(5*sum(Jlimitresult))-1;
              exp(5*(6-sum(result_row)))-1];
    end
end


%% FUNCTION: checks pose validity, if valid but dist>min, return distance 
function [valid,dist,targetdist]=check_newQ(qt,qlimits,pt,tr,Links,numlinks,plane_equ)
    global optimise densoobj workspace;
    %returns infinite distance by default
    dist=inf;

    %distance from tr to target pt, distance from tr to target plane
    targetdist=[inf,inf];
    
    %it is not valid by default so we can return at anytime and return invalid
    valid=false;
    
    %from base transform of the robot check each joint and fkine through
    for i=1:numlinks; 
        tr = tr * Links{i}(qt(i));
        if qt(i)<qlimits(i,1) || qt(i)>qlimits(i,2); return; end;
        if ~check_FF(tr,densoobj(i+1).ellipse,workspace.indexedobsticles); return; end;                      
    end
    
    % Check the actual distance from end effector to target point
    targetdist(1)=dist_pt2tr(pt,tr);  
    
    streamStart=tr(1:3,4);
%     streamEnd=tr(1:3,3)'+tr(1:3,4)';
%     r_var=[streamStart(1)-streamEnd(1),...
%            streamStart(2)-streamEnd(2),...
%            streamStart(3)-streamEnd(3)];               
    r_var=-tr(1:3,3);

    %find intersection point between surface and the scan line between scan origin and point
    bottomof_t_var=plane_equ(1)*r_var(1)+...
                   plane_equ(2)*r_var(2)+...
                   plane_equ(3)*r_var(3);
    %make sure it is not 0 otherwise change it so it is simply a very small
    %number (epsilon)
    if ~isempty(find(bottomof_t_var==0, 1)); bottomof_t_var(bottomof_t_var==0)=eps; end                                                                               
    t_var=( plane_equ(1)*tr(1,4)+...
            plane_equ(2)*tr(2,4)+...
            plane_equ(3)*tr(3,4)+...
            plane_equ(4)...
           )./ bottomof_t_var;                 

    % Get the intersection points
    intersectionPNT=[t_var.*-r_var(1)+tr(1,4),...
                     t_var.*-r_var(2)+tr(2,4),...
                     t_var.*-r_var(3)+tr(3,4)];

    targetdist(2)=dist_pt2tr(intersectionPNT,tr);
    
    %the distance on the plane between where we aimed and where it hit is  
    dist=sqrt((pt(1)-intersectionPNT(1))^2+...
              (pt(2)-intersectionPNT(2))^2+...
              (pt(3)-intersectionPNT(3))^2);

    %angle between line and plane
    theta = acos(plane_equ(1:3)*unit((tr(1:3,3)+tr(1:3,4))));
    
    %if it is allowable then it is valid and change this to return
    if targetdist(2)<optimise.mintargetdis||...
       targetdist(2)>optimise.maxtargetdis||...
       dist>optimise.minAccepDis ||...
       theta>optimise.maxDeflectionError 
        display('Didnt find perfect solution but may still be good enough');            
        display(['values: dist= ',num2str(dist),' targetdist(2) = ',num2str(targetdist(2)),' theta(deg)= ',num2str(theta*180/pi)])
        return; 
    else
        %if we get to here it is valid
        valid=true;
        display('Found a solution');
        display(['values: dist= ',num2str(dist),' targetdist(2) = ',num2str(targetdist(2)),' theta(deg)= ',num2str(theta*180/pi)])
    end;       
end
##### SOURCE END #####
-->
   </body>
</html>