
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN">
<html xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   
      <!--
This HTML is auto-generated from an M-file.
To make changes, update the M-file and republish this document.
      -->
      <title>nbv_volume</title>
      <meta name="generator" content="MATLAB 7.4">
      <meta name="date" content="2008-06-19">
      <meta name="m-file" content="nbv_volume"><style>

body {
  background-color: white;
  margin:10px;
}

h1 {
  color: #990000; 
  font-size: x-large;
}

h2 {
  color: #990000;
  font-size: medium;
}

/* Make the text shrink to fit narrow windows, but not stretch too far in 
wide windows. */ 
p,h1,h2,div.content div {
  max-width: 600px;
  /* Hack for IE6 */
  width: auto !important; width: 600px;
}

pre.codeinput {
  background: #EEEEEE;
  padding: 10px;
}
@media print {
  pre.codeinput {word-wrap:break-word; width:100%;}
} 

span.keyword {color: #0000FF}
span.comment {color: #228B22}
span.string {color: #A020F0}
span.untermstring {color: #B20000}
span.syscmd {color: #B28C00}

pre.codeoutput {
  color: #666666;
  padding: 10px;
}

pre.error {
  color: red;
}

p.footer {
  text-align: right;
  font-size: xx-small;
  font-weight: lighter;
  font-style: italic;
  color: gray;
}

  </style></head>
   <body>
      <div class="content">
         <h1>nbv_volume</h1>
         <introduction>
            <p><b>Description:</b>  this function works out one scan at a given position, by; 1) first calculate an optimal scan (once) by using the scan range,
               pan bearing and scan tilt (6th joint assumed 0 so the robot can actual move with the second last joint so as to maximise the
               scan everytime) 2) then (and subsequent times as long as scan pan and tilt is not changed) it will shift this block of point
               scan to the desired position and desired bearing 3) then if there are any obsticles defined in the workspace it will work
               out the point to carve out these are the points obstructed because of the surface from the laser scan pos Note: setupworkspace
               (or something) to set workspace variables should have been run
            </p>
         </introduction>
         <h2>Contents</h2>
         <div>
            <ul>
               <li><a href="#1">Function Call</a></li>
               <li><a href="#2">Variables</a></li>
               <li><a href="#3">Do the transformation shift and rotation of the points</a></li>
               <li><a href="#4">Temporary Display and plotting for error testing etc</a></li>
               <li><a href="#5">Remove points that are beyond osticle points</a></li>
               <li><a href="#6">Go through each obstacle where the home point is within the scan</a></li>
               <li><a href="#7">If points on other side of this plane, ray trace, check if intersec&lt;mew</a></li>
               <li><a href="#8">FUNCTION: Basic scan</a></li>
               <li><a href="#9">Take the scan - work out end points</a></li>
               <li><a href="#10">Find cubes which are intersected with and fill them with a point</a></li>
               <li><a href="#11">FUNCTION: delete_scan_lines</a></li>
            </ul>
         </div>
         <h2>Function Call<a name="1"></a></h2>
         <p><b>Inputs:</b></p>
         <p><i>tr</i> (4*4 double) transform in space position and orientation
         </p>
         <p><i>newQ</i> (1*6 double) the proposed newQ
         </p>
         <p><b>Returns:</b></p>
         <p><i>points</i> (3*many double) point in space that will be seen at this tr
         </p><pre class="codeinput"><span class="keyword">function</span> points=nbv_volume(tr,newQ)
</pre><h2>Variables<a name="2"></a></h2><pre class="codeinput"><span class="keyword">global</span> scan workspace

<span class="keyword">if</span> ~isfield(scan,<span class="string">'basescan'</span>)
    scan.basescan=dobasic_scan(workspace.inc_size);
    save <span class="string">basic_scan_data.mat</span> <span class="string">-struct</span> <span class="string">scan</span> <span class="string">basescan</span>;
<span class="keyword">end</span>
</pre><h2>Do the transformation shift and rotation of the points<a name="3"></a></h2><pre class="codeinput"><span class="comment">%get the points from memory</span>
points=scan.basescan;

<span class="comment">%if we are using the square vectors where chosen pose goes to, else we have a legitimate tr passed in</span>
<span class="comment">% Used for NBV only (leave here for now)</span>
<span class="keyword">if</span> tr(2,1)==0&amp;&amp;tr(1,2)==0 &amp;&amp; tr(3,1)==0&amp;&amp;tr(1,3)==0 &amp;&amp; tr(2,3)==0&amp;&amp;tr(3,2)==0
    <span class="keyword">if</span> tr(1,1)&lt;0
        points=[-1*points(:,1),points(:,2:3)];
    <span class="keyword">end</span>
    <span class="comment">%you could do for tr(2,2) but it would fip it and it issymetric around z</span>
    <span class="comment">%axis so the y doesn't effect it</span>
    <span class="keyword">if</span> tr(3,3)&lt;0
        points=[points(:,1:2),-1*points(:,3)];
    <span class="keyword">end</span>
    <span class="comment">%now rotate around the y axis in direction clockwise if sign product is &gt;0 or couterclockwise if sign product is &lt;0</span>
    temp_tr=makehgtform(<span class="string">'yrotate'</span>,-sign(tr(1,1)*tr(3,3)) * pi/4);
    points=points*temp_tr(1:3,1:3);
<span class="keyword">else</span> <span class="comment">%For actual NBV_beta where tr is not perfect</span>
    points=points*tr(1:3,1:3)';
<span class="keyword">end</span>

current_scan_origin=[tr(1,4),tr(2,4),tr(3,4)];
points=[points(:,1)+current_scan_origin(1),points(:,2)+current_scan_origin(2),points(:,3)+current_scan_origin(3)];

<span class="comment">%put into the workspace inc size</span>
points=round(points/workspace.inc_size)*workspace.inc_size;
<span class="comment">% Remove points which are in the robot base position</span>
points=points((points(:,1)&lt;workspace.robotsize(1,1)|points(:,1)&gt;workspace.robotsize(1,2)|<span class="keyword">...</span>
               points(:,2)&lt;workspace.robotsize(2,1)|points(:,2)&gt;workspace.robotsize(2,2)|<span class="keyword">...</span>
               points(:,3)&lt;workspace.robotsize(3,1)|points(:,3)&gt;workspace.robotsize(3,2)),:);

<span class="comment">% works out how much of potential info is new and within boundaries</span>
points=points((points(:,1)&gt;=workspace.min(1) &amp; points(:,1)&lt;=workspace.max(1) &amp;<span class="keyword">...</span>
               points(:,2)&gt;=workspace.min(2) &amp; points(:,2)&lt;=workspace.max(2) &amp;<span class="keyword">...</span>
               points(:,3)&gt;=workspace.min(3) &amp; points(:,3)&lt;=workspace.max(3)),:);

<span class="comment">%keep only unique points</span>
points=unique(points,<span class="string">'rows'</span>);
</pre><h2>Temporary Display and plotting for error testing etc<a name="4"></a></h2><pre class="codeinput"><span class="comment">% set the state of points before removing shadow plotting to show where</span>
<span class="comment">% this view will go</span>
<span class="comment">% figure(2)</span>
<span class="comment">%  temp1=plot3(tr(1,4),tr(2,4),tr(3,4),'r*');</span>
<span class="comment">%  actual_targ=sum(unit(tr(1:3,1:3)),2)+tr(1:3,4);</span>
<span class="comment">%  hold on;</span>
<span class="comment">%  temp2=plot3(actual_targ(1),actual_targ(2),actual_targ(3),'b*');</span>
<span class="comment">%  pause(1.5)</span>
<span class="comment">%  temp3=plot3(points(:,1),points(:,2),points(:,3),'g.');</span>
<span class="comment">%  pause(1);</span>
<span class="comment">%  tr</span>
<span class="comment">%  delete(temp1);delete(temp2);delete(temp3);</span>
</pre><h2>Remove points that are beyond osticle points<a name="5"></a></h2><pre class="codeinput"><span class="comment">%put workspace and robot obstructing planes together</span>
plane_homepnts=[workspace.robotplanes.home_points; workspace.indexedobsticles_home_point];
<span class="comment">%put the equations of planes together</span>
plane_equ=[workspace.robotplanes.equ; workspace.indexedobsticles_equ];
<span class="comment">%if any are the same then probably there is some obstruction by the planes</span>
plane_index=(1:size(plane_homepnts,1))';obstructingPNTS=1;
<span class="comment">% remove points which are obscured by surfaces</span>
    <span class="comment">%scanorigin</span>
    <span class="comment">% o-------------</span>
<span class="comment">%     \ Known</span>
<span class="comment">%      \ 0\ obsticle</span>
<span class="comment">%       \XX\ unknown since behind obsticle</span>
<span class="comment">%        \XXX\</span>

<span class="comment">% firstly remove all points that we either know are free or have an obstacle</span>
points=setdiff(points,[workspace.knowncoords;workspace.indexedobsticles],<span class="string">'rows'</span>);
<span class="comment">%if we pass in the newQ then we can remove self scanning points</span>
<span class="keyword">if</span> exist(<span class="string">'newQ'</span>,<span class="string">'var'</span>)
    points=remove_self_scanning(points,newQ);
<span class="keyword">end</span>
<span class="comment">%this is just here for displaying purposes</span>
points_before_remove_shadow=points;
</pre><h2>Go through each obstacle where the home point is within the scan<a name="6"></a></h2>
         <p><img vspace="5" hspace="5" src="nbv_volume_eq4864098.png"> </p><pre class="codeinput"><span class="keyword">if</span> ~isempty(obstructingPNTS)
    <span class="comment">% showld be the same as the surfaces made when we get obsticle points</span>
    mew=workspace.mew;
    <span class="keyword">for</span> i=plane_index'
        <span class="comment">%what side are the points on of this plane?</span>
        points_sign=(plane_equ(i,1)*points(:,1)+<span class="keyword">...</span>
                     plane_equ(i,2)*points(:,2)+<span class="keyword">...</span>
                     plane_equ(i,3)*points(:,3)+<span class="keyword">...</span>
                     ones([size(points,1),1])*plane_equ(i,4))&gt;0;

        <span class="comment">%what side is the scan.origin on?</span>
        scan_origin_sign=(plane_equ(i,1)*current_scan_origin(1)+<span class="keyword">...</span>
                          plane_equ(i,2)*current_scan_origin(2)+<span class="keyword">...</span>
                          plane_equ(i,3)*current_scan_origin(3)+<span class="keyword">...</span>
                          plane_equ(i,4))&gt;0;

        <span class="comment">%All point on the same side are automatically valid</span>
        <span class="comment">%Now look at point on the opisite side of the plane</span>
        points_on_oposite_side=points(points_sign~=scan_origin_sign,:);
</pre><h2>If points on other side of this plane, ray trace, check if intersec&lt;mew<a name="7"></a></h2>
         <p><img vspace="5" hspace="5" src="nbv_volume_eq7109979.png"> </p><pre class="codeinput">        <span class="keyword">if</span> size(points_on_oposite_side,1)&gt;0
            <span class="comment">%we get the r variables for the parametric forms of a line between 2 points</span>
            r_var=[current_scan_origin(1)-points_on_oposite_side(:,1),<span class="keyword">...</span>
                   current_scan_origin(2)-points_on_oposite_side(:,2),<span class="keyword">...</span>
                   current_scan_origin(3)-points_on_oposite_side(:,3)];

            <span class="comment">%find intersection point between surface and the scan line between scan origin and point</span>
            bottomof_t_var=plane_equ(i,1)*r_var(:,1)+<span class="keyword">...</span>
                           plane_equ(i,2)*r_var(:,2)+<span class="keyword">...</span>
                           plane_equ(i,3)*r_var(:,3);
            <span class="comment">%make sure it is not 0 otherwise change it so it is simply a very small number (epsilon) so we can keep the size of matrixes</span>
            <span class="keyword">if</span> ~isempty(find(bottomof_t_var==0, 1)); bottomof_t_var(bottomof_t_var==0)=eps; <span class="keyword">end</span>
            t_var=( plane_equ(i,1)*current_scan_origin(1)+<span class="keyword">...</span>
                    plane_equ(i,2)*current_scan_origin(2)+<span class="keyword">...</span>
                    plane_equ(i,3)*current_scan_origin(3)+<span class="keyword">...</span>
                    plane_equ(i,4)<span class="keyword">...</span>
                   )./ bottomof_t_var;

            <span class="comment">% Get the intersection points</span>
            intersectionPNTs=[t_var.*-r_var(:,1)+current_scan_origin(1),<span class="keyword">...</span>
                              t_var.*-r_var(:,2)+current_scan_origin(2),<span class="keyword">...</span>
                              t_var.*-r_var(:,3)+current_scan_origin(3)];

    <span class="comment">% figure(2);hold on;view(3)</span>
    <span class="comment">% a=plot3(temp_plane_homepnts(planes_of_interest(i),1),temp_plane_homepnts(planes_of_interest(i),2),temp_plane_homepnts(planes_of_interest(i),3),'r*');</span>
    <span class="comment">% b=plot3(current_scan_origin(1),current_scan_origin(2),current_scan_origin(3),'black*');</span>
    <span class="comment">% c=plot3(points_on_oposite_side(:,1),points_on_oposite_side(:,2),points_on_oposite_side(:,3),'y.');</span>
    <span class="comment">% d=plot3(points(points_sign==scan_origin_sign,1),points(points_sign==scan_origin_sign,2),points(points_sign==scan_origin_sign,3),'g.');</span>
    <span class="comment">% delete(a);delete(b);delete(c);delete(d);</span>


            <span class="comment">%find the points which are either on the same side of the plane as the scanning point</span>
            <span class="comment">%or they are on the other side and are less than mew fmro the intersection point</span>
            points=[points(points_sign==scan_origin_sign,:);<span class="keyword">...</span>
                    points_on_oposite_side((sqrt((intersectionPNTs(:,1)-plane_homepnts(i,1)).^2+<span class="keyword">...</span>
                                                 (intersectionPNTs(:,2)-plane_homepnts(i,2)).^2+<span class="keyword">...</span>
                                                 (intersectionPNTs(:,3)-plane_homepnts(i,3)).^2)&gt;mew),:)];
           <span class="comment">%it is possible that all points have been removed so we can break</span>
           <span class="comment">%out and say no points are give (if surface is right in front)</span>
            <span class="keyword">if</span> size(points,1)==0
                <span class="keyword">break</span>
            <span class="keyword">end</span>
        <span class="keyword">end</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>


<span class="comment">% % TESING purposes for showing the shadowing effect</span>
<span class="comment">% display(strcat('Before shadow removal there were: ',num2str(size(points_before_remove_shadow,1)),...</span>
<span class="comment">%     ' points. Afterwards there were: ', num2str(size(points,1)),...</span>
<span class="comment">%     '. Hence reduced by:',num2str(size(points_before_remove_shadow,1)-size(points,1))));</span>
<span class="comment">% figure(2);global plane;plot_planes(plane,mew);plot3(current_scan_origin(1),current_scan_origin(2),current_scan_origin(3),'black*');hold on;</span>
<span class="comment">% a=plot3(points_before_remove_shadow(:,1),points_before_remove_shadow(:,2),points_before_remove_shadow(:,3),'r.');</span>
<span class="comment">% hold on;b=plot3(points(:,1),points(:,2),points(:,3),'g.');</span>
<span class="comment">% c=setdiff(points_before_remove_shadow,points,'rows');</span>
<span class="comment">% hold on;d=plot3(c(:,1),c(:,2),c(:,3),'b.');</span>
<span class="comment">% hold on; e=plot3(current_scan_origin(1),current_scan_origin(2),current_scan_origin(3),'black+');</span>
<span class="comment">% delete(a);</span>
<span class="comment">% delete(b);</span>
<span class="comment">% delete(d);</span>
<span class="comment">% delete(e);</span>
</pre><h2>FUNCTION: Basic scan<a name="8"></a></h2>
         <p>Description: this traces out the lines and gets a group of points as the basic scan</p><pre class="codeinput"><span class="keyword">function</span> points=dobasic_scan(cube_size)

<span class="keyword">global</span> scan workspace

<span class="comment">%starttime=clock;</span>

<span class="comment">%this will actually be x or y axis from end effector but not sure which</span>
<span class="comment">%have to find out which axis the 5th joint rotates around</span>
laser_pos=[0,0,0];
bear=[1,0,1]; <span class="comment">%used to be [0,0,1]</span>
tilt_rotate_vec=[0,1,0];

<span class="comment">%max range of laser</span>
las_range=scan.size;

<span class="comment">%Laser Angualar VARIABLES</span>
<span class="comment">%this is the angle either side of the bearing of the center of the scan \|/</span>
theta=scan.theta;
<span class="comment">%the increment angle used in both</span>
<span class="comment">%theta_incr=scan.theta_incr;</span>
<span class="comment">%this is the angle from the tilt, - is up, + is down, angle must be from -2pi to 2pi</span>
alpha=-scan.alpha;

<span class="comment">% %SETUP WORKSPACE</span>

<span class="comment">%since we want to know what is the max angle we can use HERE only so that</span>
<span class="comment">%at the furthest point we have resolution enough to cover our cubes at</span>
<span class="comment">%least 3 times at the point of longest laser range, so we use that angular</span>
<span class="comment">%resolution for this simulation</span>
theta_incr=atan((cube_size/3)/las_range);
<span class="comment">%we have an actual min resoltion in hardware so this is the minmum</span>
<span class="keyword">if</span> theta_incr&lt;scan.theta_incr
    theta_incr=scan.theta_incr;
<span class="keyword">end</span>
</pre><h2>Take the scan - work out end points<a name="9"></a></h2>
         <p>This is the most important vector it describes the center of the first laser pan scan we will rotate to ge the pan scan</p><pre class="codeinput">dir_vec=las_range*(bear);
<span class="comment">%this is the vector that we will pan rotate around, it is always at origin</span>
<span class="comment">%so we get cross product of the two vectors on the plane to get normal</span>
<span class="comment">%pan_rotate_vec=cross(dir_vec,tilt_rotate_vec);</span>
pan_rotate_vec=tilt_rotate_vec  * [0 -dir_vec(3) dir_vec(2);<span class="keyword">...</span>
                                   dir_vec(3) 0 -dir_vec(1);<span class="keyword">...</span>
                                   -dir_vec(2) dir_vec(1) 0];


<span class="comment">%this works out through pan rotation of the ice cream cone from the origin</span>
<span class="comment">%work out how many increments based on lasers lowest steps</span>
increments=round(2*theta/theta_incr);
single_pan=[];
<span class="keyword">for</span> j=-theta:(2*theta)/(increments-1):theta
    single_pan=[single_pan;rot_vec(dir_vec,pan_rotate_vec,j)];
<span class="keyword">end</span>
current_row=1;
ice_cream_bounds=zeros([increments^2,3]);

<span class="comment">%this tilt rotates and transforms to come form laser position</span>
<span class="keyword">for</span> i=0:alpha/(increments-1):alpha
    tilt_rot_res=rot_vec(single_pan,tilt_rotate_vec,i);
    new_current_row=current_row+size(tilt_rot_res,1);
    ice_cream_bounds(current_row:new_current_row-1,:)=[tilt_rot_res(:,1)+laser_pos(1),<span class="keyword">...</span>
        tilt_rot_res(:,2)+laser_pos(2),<span class="keyword">...</span>
        tilt_rot_res(:,3)+laser_pos(3)];
    current_row=new_current_row;
<span class="keyword">end</span>
</pre><h2>Find cubes which are intersected with and fill them with a point<a name="10"></a></h2><pre class="codeinput">markedcubes=[];

dist=sqrt((laser_pos(1)-ice_cream_bounds(:,1)).^2+<span class="keyword">...</span>
          (laser_pos(2)-ice_cream_bounds(:,2)).^2+<span class="keyword">...</span>
          (laser_pos(3)-ice_cream_bounds(:,3)).^2);
valid_rows=find(dist);

tempstarter=(ice_cream_bounds(:,1)-laser_pos(1))./(2*dist(:)/cube_size);


<span class="keyword">for</span> i=[valid_rows]'

    <span class="comment">%check each one of the segements for zero distance and fill with that planes value for inbetweens</span>
    <span class="keyword">if</span> laser_pos(1)==ice_cream_bounds(i,1)
        inbetweenpoint=[laser_pos(1)*ones([round((2*dist(i)/cube_size))+1,1])];
    <span class="keyword">else</span>
        <span class="comment">%inbetweenpoint=[(laser_pos(1):(ice_cream_bounds(i,1)-laser_pos(1))/(2*dist(i)/cube_size):ice_cream_bounds(i,1))'];</span>
        inbetweenpoint=[(laser_pos(1):tempstarter(i):ice_cream_bounds(i,1))'];

    <span class="keyword">end</span>
    <span class="keyword">if</span> laser_pos(2)==ice_cream_bounds(i,2)
        inbetweenpoint=[inbetweenpoint,(laser_pos(2)*ones([size(inbetweenpoint,1),1]))];
    <span class="keyword">else</span>
        inbetweenpoint=[inbetweenpoint,(laser_pos(2):(ice_cream_bounds(i,2)-laser_pos(2))/(size(inbetweenpoint,1)-1):ice_cream_bounds(i,2))'];
    <span class="keyword">end</span>
    <span class="keyword">if</span> laser_pos(3)==ice_cream_bounds(i,3)
        inbetweenpoint=[inbetweenpoint,(laser_pos(3)*ones([size(inbetweenpoint,1),1]))];
    <span class="keyword">else</span>
        inbetweenpoint=[inbetweenpoint,(laser_pos(3):(ice_cream_bounds(i,3)-laser_pos(3))/(size(inbetweenpoint,1)-1):ice_cream_bounds(i,3))'];
    <span class="keyword">end</span>
  <span class="comment">%end</span>
  <span class="comment">%workspace_origin</span>
  cubes_checked=floor(inbetweenpoint/cube_size);

    <span class="comment">%Note: since this may be rotated we don't want to delete potential</span>
    <span class="comment">%infomation (deleted the statement which did this</span>

    <span class="comment">%had to add this</span>
    markedcubes=[markedcubes;cubes_checked];

    <span class="comment">%this balances out with the above adding rows to a matrix</span>
    <span class="keyword">if</span> rand&gt;0.98
        markedcubes=unique(markedcubes,<span class="string">'rows'</span>);
    <span class="keyword">end</span>
<span class="comment">%  end</span>
<span class="keyword">end</span>

<span class="comment">% final step of saving the unique points</span>
<span class="keyword">if</span> size(markedcubes)&gt;0
    markedcubes=unique(markedcubes,<span class="string">'rows'</span>);
    points=markedcubes.*cube_size;
<span class="keyword">end</span>

<span class="comment">%etime(clock,starttime)</span>

<span class="comment">% %% Plot the ice cream on the pyrimid cone</span>
<span class="comment">% %This works out the bounds of the pyramid (only needed for plotting)</span>
<span class="comment">% pan_pos_max=rot_vec(dir_vec,pan_rotate_vec,theta)+laser_pos;</span>
<span class="comment">% pan_neg_max=rot_vec(dir_vec,pan_rotate_vec,-theta)+laser_pos;</span>
<span class="comment">% tilt_pos_max=rot_vec(pan_pos_max-laser_pos,tilt_rotate_vec,alpha)+laser_pos;</span>
<span class="comment">% tilt_neg_max=rot_vec(pan_neg_max-laser_pos,tilt_rotate_vec,alpha)+laser_pos;</span>
<span class="comment">%</span>
<span class="comment">% hold on;axis equal;</span>
<span class="comment">% scan_line_handles=[];</span>
<span class="comment">% for k=1:round(increments/10):increments</span>
<span class="comment">%     %col</span>
<span class="comment">%     col_lines=(k-1)*increments+(1:increments);</span>
<span class="comment">%     scan_line_handles=[scan_line_handles;...</span>
<span class="comment">%         plot3(ice_cream_bounds(col_lines,1),ice_cream_bounds(col_lines,2),ice_cream_bounds(col_lines,3));...</span>
<span class="comment">%         plot3([ice_cream_bounds(col_lines(1),1),laser_pos(1),ice_cream_bounds(col_lines(end),1)],...</span>
<span class="comment">%               [ice_cream_bounds(col_lines(1),2),laser_pos(2),ice_cream_bounds(col_lines(end),2)],...</span>
<span class="comment">%               [ice_cream_bounds(col_lines(1),3),laser_pos(3),ice_cream_bounds(col_lines(end),3)])];</span>
<span class="comment">%</span>
<span class="comment">%      %hor</span>
<span class="comment">%     row_lines=k:increments:size(ice_cream_bounds,1);</span>
<span class="comment">%     scan_line_handles=[scan_line_handles;...</span>
<span class="comment">%         plot3(ice_cream_bounds(row_lines,1),ice_cream_bounds(row_lines,2),ice_cream_bounds(row_lines,3));...</span>
<span class="comment">%         plot3([ice_cream_bounds(row_lines(1),1),laser_pos(1),ice_cream_bounds(row_lines(end),1)],...</span>
<span class="comment">%               [ice_cream_bounds(row_lines(1),2),laser_pos(2),ice_cream_bounds(row_lines(end),2)],...</span>
<span class="comment">%               [ice_cream_bounds(row_lines(1),3),laser_pos(3),ice_cream_bounds(row_lines(end),3)])];</span>
<span class="comment">%</span>
<span class="comment">% end</span>
<span class="comment">%</span>
<span class="comment">% scan_point_handles=[];</span>
<span class="comment">% scan_point_handles=[scan_point_handles;...</span>
<span class="comment">%     plot3(laser_pos(1),laser_pos(2),laser_pos(3),'r*');...</span>
<span class="comment">%     plot3(dir_vec(1)+laser_pos(1),dir_vec(2)+laser_pos(2),dir_vec(3)+laser_pos(3),'y*');...</span>
<span class="comment">%     ...</span>
<span class="comment">%     plot3(pan_pos_max(1),pan_pos_max(2),pan_pos_max(3),'b*');...</span>
<span class="comment">%     plot3(pan_neg_max(1),pan_neg_max(2),pan_neg_max(3),'b*');...</span>
<span class="comment">%     plot3([laser_pos(1),pan_pos_max(1)],[laser_pos(2),pan_pos_max(2)],[laser_pos(3),pan_pos_max(3)]);...</span>
<span class="comment">%     plot3([laser_pos(1),pan_neg_max(1)],[laser_pos(2),pan_neg_max(2)],[laser_pos(3),pan_neg_max(3)]);...</span>
<span class="comment">%     ...</span>
<span class="comment">%     plot3(tilt_pos_max(1),tilt_pos_max(2),tilt_pos_max(3),'g*');...</span>
<span class="comment">%     plot3(tilt_neg_max(1),tilt_neg_max(2),tilt_neg_max(3),'g*');...</span>
<span class="comment">%     plot3([laser_pos(1),tilt_pos_max(1)],[laser_pos(2),tilt_pos_max(2)],[laser_pos(3),tilt_pos_max(3)]);...</span>
<span class="comment">%     plot3([laser_pos(1),tilt_neg_max(1)],[laser_pos(2),tilt_neg_max(2)],[laser_pos(3),tilt_neg_max(3)])];</span>
<span class="comment">%</span>
<span class="comment">% xlabel('x - Pan around');ylabel('y - Tilt Around');zlabel('z - stream point');grid on;hold on;</span>
<span class="comment">%</span>
<span class="comment">%</span>
<span class="comment">% %mark the point of the cube as the closest point in cube to workspace origin</span>
<span class="comment">% if size(markedcubes)&gt;0</span>
<span class="comment">% figure(2)</span>
<span class="comment">% plot3(markedcubes(:,1)*cube_size,markedcubes(:,2)*cube_size,markedcubes(:,3)*cube_size,'r.');</span>
<span class="comment">% keyboard</span>
<span class="comment">% end</span>
<span class="comment">%</span>
<span class="comment">% % Delete the scan handles</span>
<span class="comment">% delete_scan_lines(scan_line_handles,scan_point_handles)</span>
<span class="comment">% clear scan_line_handles scan_point_handles</span>
</pre><h2>FUNCTION: delete_scan_lines<a name="11"></a></h2><pre class="codeinput"><span class="comment">%This cleans up the lines from a scan</span>

<span class="keyword">function</span> delete_scan_lines(scan_line_handles,scan_point_handles)

<span class="keyword">for</span> i=1:size(scan_point_handles,1)
    delete(scan_point_handles(i));
<span class="keyword">end</span>
<span class="keyword">for</span> i=1:size(scan_line_handles,1)
    delete(scan_line_handles(i));
<span class="keyword">end</span>
</pre><p class="footer"><br>
            Published with MATLAB&reg; 7.4<br></p>
      </div>
      <!--
##### SOURCE BEGIN #####
%% nbv_volume
%
% *Description:*  this function works out one scan at a given position, 
% by;
% 1) first calculate an optimal scan (once) by using the scan range, pan
% bearing and scan tilt (6th joint assumed 0 so the robot can actual move
% with the second last joint so as to maximise the scan everytime)
% 2) then (and subsequent times as long as scan pan and tilt is not changed)  
% it will shift this block of point scan to the desired position and desired bearing
% 3) then if there are any obsticles defined in the workspace it will work
% out the point to carve out these are the points obstructed because of the
% surface from the laser scan pos
% Note: setupworkspace (or something) to set workspace variables should
% have been run

%% Function Call
%
% *Inputs:* 
%
% _tr_ (4*4 double) transform in space position and orientation
%
% _newQ_ (1*6 double) the proposed newQ
%
% *Returns:* 
%
% _points_ (3*many double) point in space that will be seen at this tr

function points=nbv_volume(tr,newQ)

%% Variables
global scan workspace
  
if ~isfield(scan,'basescan')
    scan.basescan=dobasic_scan(workspace.inc_size);
    save basic_scan_data.mat -struct scan basescan;
end

%% Do the transformation shift and rotation of the points
%get the points from memory
points=scan.basescan;

%if we are using the square vectors where chosen pose goes to, else we have a legitimate tr passed in 
% Used for NBV only (leave here for now)
if tr(2,1)==0&&tr(1,2)==0 && tr(3,1)==0&&tr(1,3)==0 && tr(2,3)==0&&tr(3,2)==0
    if tr(1,1)<0
        points=[-1*points(:,1),points(:,2:3)];
    end
    %you could do for tr(2,2) but it would fip it and it issymetric around z
    %axis so the y doesn't effect it
    if tr(3,3)<0
        points=[points(:,1:2),-1*points(:,3)];
    end
    %now rotate around the y axis in direction clockwise if sign product is >0 or couterclockwise if sign product is <0
    temp_tr=makehgtform('yrotate',-sign(tr(1,1)*tr(3,3)) * pi/4);
    points=points*temp_tr(1:3,1:3);    
else %For actual NBV_beta where tr is not perfect
    points=points*tr(1:3,1:3)';
end

current_scan_origin=[tr(1,4),tr(2,4),tr(3,4)];
points=[points(:,1)+current_scan_origin(1),points(:,2)+current_scan_origin(2),points(:,3)+current_scan_origin(3)];

%put into the workspace inc size
points=round(points/workspace.inc_size)*workspace.inc_size;
% Remove points which are in the robot base position
points=points((points(:,1)<workspace.robotsize(1,1)|points(:,1)>workspace.robotsize(1,2)|...
               points(:,2)<workspace.robotsize(2,1)|points(:,2)>workspace.robotsize(2,2)|...
               points(:,3)<workspace.robotsize(3,1)|points(:,3)>workspace.robotsize(3,2)),:);
          
% works out how much of potential info is new and within boundaries
points=points((points(:,1)>=workspace.min(1) & points(:,1)<=workspace.max(1) &...
               points(:,2)>=workspace.min(2) & points(:,2)<=workspace.max(2) &...
               points(:,3)>=workspace.min(3) & points(:,3)<=workspace.max(3)),:);

%keep only unique points               
points=unique(points,'rows');

%% Temporary Display and plotting for error testing etc

% set the state of points before removing shadow plotting to show where
% this view will go 
% figure(2)
%  temp1=plot3(tr(1,4),tr(2,4),tr(3,4),'r*');
%  actual_targ=sum(unit(tr(1:3,1:3)),2)+tr(1:3,4);
%  hold on;
%  temp2=plot3(actual_targ(1),actual_targ(2),actual_targ(3),'b*');
%  pause(1.5)
%  temp3=plot3(points(:,1),points(:,2),points(:,3),'g.');
%  pause(1);
%  tr
%  delete(temp1);delete(temp2);delete(temp3);

%% Remove points that are beyond osticle points
%put workspace and robot obstructing planes together
plane_homepnts=[workspace.robotplanes.home_points; workspace.indexedobsticles_home_point];
%put the equations of planes together
plane_equ=[workspace.robotplanes.equ; workspace.indexedobsticles_equ];
%if any are the same then probably there is some obstruction by the planes
plane_index=(1:size(plane_homepnts,1))';obstructingPNTS=1;
% remove points which are obscured by surfaces
    %scanorigin
    % oREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-
%     \ Known
%      \ 0\ obsticle
%       \XX\ unknown since behind obsticle
%        \XXX\

% firstly remove all points that we either know are free or have an obstacle
points=setdiff(points,[workspace.knowncoords;workspace.indexedobsticles],'rows');
%if we pass in the newQ then we can remove self scanning points
if exist('newQ','var')
    points=remove_self_scanning(points,newQ);
end
%this is just here for displaying purposes
points_before_remove_shadow=points; 
 
%% Go through each obstacle where the home point is within the scan
% $$ \begin{array}{l}
% \mbox{PlaneEq...} ax_p+by_p+cz_p+d=0\\
% \mbox{PlaneCenter...} P_c=(x_c,y_c,z_c)\\
% \mbox{PlaneRadius...} \mu\\
% \mbox{ScanOrigin...} P_s=(x_s,y_s,z_s)\\
% \mbox{PointsOnOpSide...} P_{o(j)}=(x_o,y_o,z_o)_{j=1...m}\\
% \end{array}$$
if ~isempty(obstructingPNTS)
    % showld be the same as the surfaces made when we get obsticle points
    mew=workspace.mew; 
    for i=plane_index'           
        %what side are the points on of this plane? 
        points_sign=(plane_equ(i,1)*points(:,1)+...
                     plane_equ(i,2)*points(:,2)+...
                     plane_equ(i,3)*points(:,3)+...
                     ones([size(points,1),1])*plane_equ(i,4))>0;
                 
        %what side is the scan.origin on?
        scan_origin_sign=(plane_equ(i,1)*current_scan_origin(1)+...
                          plane_equ(i,2)*current_scan_origin(2)+...
                          plane_equ(i,3)*current_scan_origin(3)+...
                          plane_equ(i,4))>0;
                      
        %All point on the same side are automatically valid        
        %Now look at point on the opisite side of the plane
        points_on_oposite_side=points(points_sign~=scan_origin_sign,:);       
        
%% If points on other side of this plane, ray trace, check if intersec<mew
% $$ \begin{array}{l}
% r=P_s-P_o \\
% t=\frac{ax_s+by_s+cz_s+d}{ar_x+br_y+xr_z}\\
% P_{intersection}=tr+P_s=(tr_x+x_s, tr_y+y_s, tr_z+z_s)=P_{i(k)}=(x_i,y_i,z_i)_{k=1...n}\\
% \forall(n), \sqrt{(x_i-x_c)^2+(y_i-y_c)^2+(z_i-z_c)^2}>\mu 
% \rightarrow \mbox{unobscured points}
% \end{array}$$
        if size(points_on_oposite_side,1)>0
            %we get the r variables for the parametric forms of a line between 2 points
            r_var=[current_scan_origin(1)-points_on_oposite_side(:,1),...
                   current_scan_origin(2)-points_on_oposite_side(:,2),...
                   current_scan_origin(3)-points_on_oposite_side(:,3)];               

            %find intersection point between surface and the scan line between scan origin and point
            bottomof_t_var=plane_equ(i,1)*r_var(:,1)+...
                           plane_equ(i,2)*r_var(:,2)+...
                           plane_equ(i,3)*r_var(:,3);
            %make sure it is not 0 otherwise change it so it is simply a very small number (epsilon) so we can keep the size of matrixes
            if ~isempty(find(bottomof_t_var==0, 1)); bottomof_t_var(bottomof_t_var==0)=eps; end                                                                               
            t_var=( plane_equ(i,1)*current_scan_origin(1)+...
                    plane_equ(i,2)*current_scan_origin(2)+...
                    plane_equ(i,3)*current_scan_origin(3)+...
                    plane_equ(i,4)...
                   )./ bottomof_t_var;                 

            % Get the intersection points
            intersectionPNTs=[t_var.*-r_var(:,1)+current_scan_origin(1),...
                              t_var.*-r_var(:,2)+current_scan_origin(2),...
                              t_var.*-r_var(:,3)+current_scan_origin(3)];

    % figure(2);hold on;view(3)                
    % a=plot3(temp_plane_homepnts(planes_of_interest(i),1),temp_plane_homepnts(planes_of_interest(i),2),temp_plane_homepnts(planes_of_interest(i),3),'r*');
    % b=plot3(current_scan_origin(1),current_scan_origin(2),current_scan_origin(3),'black*');
    % c=plot3(points_on_oposite_side(:,1),points_on_oposite_side(:,2),points_on_oposite_side(:,3),'y.');
    % d=plot3(points(points_sign==scan_origin_sign,1),points(points_sign==scan_origin_sign,2),points(points_sign==scan_origin_sign,3),'g.');
    % delete(a);delete(b);delete(c);delete(d);


            %find the points which are either on the same side of the plane as the scanning point 
            %or they are on the other side and are less than mew fmro the intersection point       
            points=[points(points_sign==scan_origin_sign,:);...
                    points_on_oposite_side((sqrt((intersectionPNTs(:,1)-plane_homepnts(i,1)).^2+...
                                                 (intersectionPNTs(:,2)-plane_homepnts(i,2)).^2+...
                                                 (intersectionPNTs(:,3)-plane_homepnts(i,3)).^2)>mew),:)];
           %it is possible that all points have been removed so we can break
           %out and say no points are give (if surface is right in front)
            if size(points,1)==0
                break
            end
        end
    end 
end


% % TESING purposes for showing the shadowing effect
% display(strcat('Before shadow removal there were: ',num2str(size(points_before_remove_shadow,1)),...
%     ' points. Afterwards there were: ', num2str(size(points,1)),...
%     '. Hence reduced by:',num2str(size(points_before_remove_shadow,1)-size(points,1))));
% figure(2);global plane;plot_planes(plane,mew);plot3(current_scan_origin(1),current_scan_origin(2),current_scan_origin(3),'black*');hold on;
% a=plot3(points_before_remove_shadow(:,1),points_before_remove_shadow(:,2),points_before_remove_shadow(:,3),'r.');
% hold on;b=plot3(points(:,1),points(:,2),points(:,3),'g.');
% c=setdiff(points_before_remove_shadow,points,'rows');
% hold on;d=plot3(c(:,1),c(:,2),c(:,3),'b.');
% hold on; e=plot3(current_scan_origin(1),current_scan_origin(2),current_scan_origin(3),'black+');
% delete(a);
% delete(b);
% delete(d);
% delete(e);

%% FUNCTION: Basic scan
% Description: this traces out the lines and gets a group of points as the
% basic scan 
function points=dobasic_scan(cube_size)

global scan workspace

%starttime=clock;

%this will actually be x or y axis from end effector but not sure which
%have to find out which axis the 5th joint rotates around
laser_pos=[0,0,0];
bear=[1,0,1]; %used to be [0,0,1]
tilt_rotate_vec=[0,1,0];

%max range of laser
las_range=scan.size;

%Laser Angualar VARIABLES
%this is the angle either side of the bearing of the center of the scan \|/
theta=scan.theta;
%the increment angle used in both 
%theta_incr=scan.theta_incr;
%this is the angle from the tilt, - is up, + is down, angle must be from -2pi to 2pi
alpha=-scan.alpha;

% %SETUP WORKSPACE

%since we want to know what is the max angle we can use HERE only so that
%at the furthest point we have resolution enough to cover our cubes at
%least 3 times at the point of longest laser range, so we use that angular
%resolution for this simulation
theta_incr=atan((cube_size/3)/las_range);
%we have an actual min resoltion in hardware so this is the minmum
if theta_incr<scan.theta_incr
    theta_incr=scan.theta_incr;
end
    
%% Take the scan - work out end points
% This is the most important vector
% it describes the center of the first laser pan scan 
% we will rotate to ge the pan scan
dir_vec=las_range*(bear);
%this is the vector that we will pan rotate around, it is always at origin
%so we get cross product of the two vectors on the plane to get normal
%pan_rotate_vec=cross(dir_vec,tilt_rotate_vec);
pan_rotate_vec=tilt_rotate_vec  * [0 -dir_vec(3) dir_vec(2);...
                                   dir_vec(3) 0 -dir_vec(1);...
                                   -dir_vec(2) dir_vec(1) 0];


%this works out through pan rotation of the ice cream cone from the origin
%work out how many increments based on lasers lowest steps
increments=round(2*theta/theta_incr);
single_pan=[]; 
for j=-theta:(2*theta)/(increments-1):theta
    single_pan=[single_pan;rot_vec(dir_vec,pan_rotate_vec,j)];
end
current_row=1;
ice_cream_bounds=zeros([increments^2,3]);

%this tilt rotates and transforms to come form laser position
for i=0:alpha/(increments-1):alpha
    tilt_rot_res=rot_vec(single_pan,tilt_rotate_vec,i);
    new_current_row=current_row+size(tilt_rot_res,1);
    ice_cream_bounds(current_row:new_current_row-1,:)=[tilt_rot_res(:,1)+laser_pos(1),...
        tilt_rot_res(:,2)+laser_pos(2),...
        tilt_rot_res(:,3)+laser_pos(3)];
    current_row=new_current_row;    
end

%% Find cubes which are intersected with and fill them with a point
markedcubes=[];

dist=sqrt((laser_pos(1)-ice_cream_bounds(:,1)).^2+...
          (laser_pos(2)-ice_cream_bounds(:,2)).^2+...
          (laser_pos(3)-ice_cream_bounds(:,3)).^2);
valid_rows=find(dist);

tempstarter=(ice_cream_bounds(:,1)-laser_pos(1))./(2*dist(:)/cube_size);


for i=[valid_rows]'
    
    %check each one of the segements for zero distance and fill with that planes value for inbetweens  
    if laser_pos(1)==ice_cream_bounds(i,1)
        inbetweenpoint=[laser_pos(1)*ones([round((2*dist(i)/cube_size))+1,1])];
    else
        %inbetweenpoint=[(laser_pos(1):(ice_cream_bounds(i,1)-laser_pos(1))/(2*dist(i)/cube_size):ice_cream_bounds(i,1))'];
        inbetweenpoint=[(laser_pos(1):tempstarter(i):ice_cream_bounds(i,1))'];

    end
    if laser_pos(2)==ice_cream_bounds(i,2)
        inbetweenpoint=[inbetweenpoint,(laser_pos(2)*ones([size(inbetweenpoint,1),1]))];
    else
        inbetweenpoint=[inbetweenpoint,(laser_pos(2):(ice_cream_bounds(i,2)-laser_pos(2))/(size(inbetweenpoint,1)-1):ice_cream_bounds(i,2))'];
    end
    if laser_pos(3)==ice_cream_bounds(i,3)
        inbetweenpoint=[inbetweenpoint,(laser_pos(3)*ones([size(inbetweenpoint,1),1]))];
    else
        inbetweenpoint=[inbetweenpoint,(laser_pos(3):(ice_cream_bounds(i,3)-laser_pos(3))/(size(inbetweenpoint,1)-1):ice_cream_bounds(i,3))'];
    end   
  %end 
  %workspace_origin
  cubes_checked=floor(inbetweenpoint/cube_size);

    %Note: since this may be rotated we don't want to delete potential
    %infomation (deleted the statement which did this

    %had to add this
    markedcubes=[markedcubes;cubes_checked];      

    %this balances out with the above adding rows to a matrix
    if rand>0.98
        markedcubes=unique(markedcubes,'rows'); 
    end
%  end           
end

% final step of saving the unique points
if size(markedcubes)>0
    markedcubes=unique(markedcubes,'rows');
    points=markedcubes.*cube_size;
end

%etime(clock,starttime)

% %% Plot the ice cream on the pyrimid cone
% %This works out the bounds of the pyramid (only needed for plotting)
% pan_pos_max=rot_vec(dir_vec,pan_rotate_vec,theta)+laser_pos;
% pan_neg_max=rot_vec(dir_vec,pan_rotate_vec,-theta)+laser_pos;
% tilt_pos_max=rot_vec(pan_pos_max-laser_pos,tilt_rotate_vec,alpha)+laser_pos;
% tilt_neg_max=rot_vec(pan_neg_max-laser_pos,tilt_rotate_vec,alpha)+laser_pos;
% 
% hold on;axis equal;
% scan_line_handles=[];
% for k=1:round(increments/10):increments
%     %col
%     col_lines=(k-1)*increments+(1:increments);       
%     scan_line_handles=[scan_line_handles;...
%         plot3(ice_cream_bounds(col_lines,1),ice_cream_bounds(col_lines,2),ice_cream_bounds(col_lines,3));...
%         plot3([ice_cream_bounds(col_lines(1),1),laser_pos(1),ice_cream_bounds(col_lines(end),1)],...
%               [ice_cream_bounds(col_lines(1),2),laser_pos(2),ice_cream_bounds(col_lines(end),2)],...
%               [ice_cream_bounds(col_lines(1),3),laser_pos(3),ice_cream_bounds(col_lines(end),3)])];
%     
%      %hor
%     row_lines=k:increments:size(ice_cream_bounds,1);    
%     scan_line_handles=[scan_line_handles;...
%         plot3(ice_cream_bounds(row_lines,1),ice_cream_bounds(row_lines,2),ice_cream_bounds(row_lines,3));...    
%         plot3([ice_cream_bounds(row_lines(1),1),laser_pos(1),ice_cream_bounds(row_lines(end),1)],...
%               [ice_cream_bounds(row_lines(1),2),laser_pos(2),ice_cream_bounds(row_lines(end),2)],...
%               [ice_cream_bounds(row_lines(1),3),laser_pos(3),ice_cream_bounds(row_lines(end),3)])];
% 
% end
% 
% scan_point_handles=[];
% scan_point_handles=[scan_point_handles;...
%     plot3(laser_pos(1),laser_pos(2),laser_pos(3),'r*');...
%     plot3(dir_vec(1)+laser_pos(1),dir_vec(2)+laser_pos(2),dir_vec(3)+laser_pos(3),'y*');...
%     ...
%     plot3(pan_pos_max(1),pan_pos_max(2),pan_pos_max(3),'b*');...
%     plot3(pan_neg_max(1),pan_neg_max(2),pan_neg_max(3),'b*');...
%     plot3([laser_pos(1),pan_pos_max(1)],[laser_pos(2),pan_pos_max(2)],[laser_pos(3),pan_pos_max(3)]);...
%     plot3([laser_pos(1),pan_neg_max(1)],[laser_pos(2),pan_neg_max(2)],[laser_pos(3),pan_neg_max(3)]);...
%     ...
%     plot3(tilt_pos_max(1),tilt_pos_max(2),tilt_pos_max(3),'g*');...
%     plot3(tilt_neg_max(1),tilt_neg_max(2),tilt_neg_max(3),'g*');...
%     plot3([laser_pos(1),tilt_pos_max(1)],[laser_pos(2),tilt_pos_max(2)],[laser_pos(3),tilt_pos_max(3)]);...
%     plot3([laser_pos(1),tilt_neg_max(1)],[laser_pos(2),tilt_neg_max(2)],[laser_pos(3),tilt_neg_max(3)])];
% 
% xlabel('x - Pan around');ylabel('y - Tilt Around');zlabel('z - stream point');grid on;hold on;
% 
% 
% %mark the point of the cube as the closest point in cube to workspace origin 
% if size(markedcubes)>0 
% figure(2)
% plot3(markedcubes(:,1)*cube_size,markedcubes(:,2)*cube_size,markedcubes(:,3)*cube_size,'r.');
% keyboard
% end  
% 
% % Delete the scan handles
% delete_scan_lines(scan_line_handles,scan_point_handles)
% clear scan_line_handles scan_point_handles


%% FUNCTION: delete_scan_lines
%This cleans up the lines from a scan

function delete_scan_lines(scan_line_handles,scan_point_handles)

for i=1:size(scan_point_handles,1)
    delete(scan_point_handles(i));
end
for i=1:size(scan_line_handles,1)
    delete(scan_line_handles(i));
end

##### SOURCE END #####
-->
   </body>
</html>