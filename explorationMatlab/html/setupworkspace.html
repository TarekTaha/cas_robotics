
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN">
<html xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   
      <!--
This HTML is auto-generated from an M-file.
To make changes, update the M-file and republish this document.
      -->
      <title>setupworkspace</title>
      <meta name="generator" content="MATLAB 7.4">
      <meta name="date" content="2007-10-05">
      <meta name="m-file" content="setupworkspace"><style>

body {
  background-color: white;
  margin:10px;
}

h1 {
  color: #990000; 
  font-size: x-large;
}

h2 {
  color: #990000;
  font-size: medium;
}

/* Make the text shrink to fit narrow windows, but not stretch too far in 
wide windows. */ 
p,h1,h2,div.content div {
  max-width: 600px;
  /* Hack for IE6 */
  width: auto !important; width: 600px;
}

pre.codeinput {
  background: #EEEEEE;
  padding: 10px;
}
@media print {
  pre.codeinput {word-wrap:break-word; width:100%;}
} 

span.keyword {color: #0000FF}
span.comment {color: #228B22}
span.string {color: #A020F0}
span.untermstring {color: #B20000}
span.syscmd {color: #B28C00}

pre.codeoutput {
  color: #666666;
  padding: 10px;
}

pre.error {
  color: red;
}

p.footer {
  text-align: right;
  font-size: xx-small;
  font-weight: lighter;
  font-style: italic;
  color: gray;
}

  </style></head>
   <body>
      <div class="content">
         <h1>setupworkspace</h1>
         <introduction>
            <p><b>Description:</b> This sets the variables for the workspace with their different weightings and it draws this up in the main figure the robot
               (r) must be previously setup
            </p>
         </introduction>
         <h2>Contents</h2>
         <div>
            <ul>
               <li><a href="#1">Function Call</a></li>
               <li><a href="#2">Variables</a></li>
               <li><a href="#3">Adding floor obstacles for safety</a></li>
               <li><a href="#4">Setup the unknown workspace</a></li>
               <li><a href="#5">Plot the main unknown graph</a></li>
            </ul>
         </div>
         <h2>Function Call<a name="1"></a></h2>
         <p><b>Inputs:</b></p>
         <p><i>showunknownpnts</i> (bin) whether or not to display unknown points
         </p>
         <p><b>Returns:</b> NULL
         </p><pre class="codeinput"><span class="keyword">function</span> setupworkspace(showunknownpnts)
</pre><h2>Variables<a name="2"></a></h2><pre class="codeinput"><span class="comment">%Declare global variables</span>
<span class="keyword">global</span> workspace r Q guiglobal;

<span class="comment">% Check Inputs: default is not to show the points</span>
<span class="keyword">if</span> nargin&lt;1
    display(<span class="string">'You should tell me wether you want to show the weighted unknown poitns'</span>);
    showunknownpnts=false;
<span class="keyword">end</span>

<span class="comment">%The voxel increment size</span>
workspace.inc_size=0.09;

<span class="comment">%The only point known is where the robot arm is</span>
initialpoint=fkine(r,Q);
workspace.knowncoords=[initialpoint(1:3,4)]';
<span class="comment">% make it fit to the grid</span>
workspace.knowncoords=(round(workspace.knowncoords./workspace.inc_size))*workspace.inc_size;

<span class="comment">%The min and max of the workspace</span>
workspace.min=[-1.6,-1.6,-workspace.inc_size/2];
workspace.max=[1.6,1.6,2.5];
<span class="comment">%make it fit to the grid</span>
workspace.min=workspace.inc_size.*round(workspace.min/workspace.inc_size);
workspace.max=workspace.inc_size.*round(workspace.max/workspace.inc_size);

<span class="comment">%holds the radius size for surfaces for exploration</span>
workspace.mew=0.30;

<span class="comment">%holds the robot basic unmovable size which takes points away from expecting scans</span>
workspace.robotsize=[-0.45,0.45;
                     -0.45,0.45;
                        0,0.89];

<span class="comment">%These are the home point of the disk planes that are at 0,0,0 and halfway</span>
<span class="comment">%up the robot: this stops the robot trying to self scan since it will not</span>
<span class="comment">%see anothing looking through itself, THESE HAVE ALSO BEEN INDEXED</span>
workspace.robotplanes.home_points=round([zeros([3,3]);<span class="keyword">...</span>
    ones([3,1])*[0,0,sum(workspace.robotsize(3,:))/2]]./workspace.inc_size)*workspace.inc_size;
<span class="comment">%These are the equations of the planes</span>
workspace.robotplanes.equ=[1,0,0,0; 0,1,0,0; 0,0,1,0;
                           1,0,0,0; 0,1,0,0; 0,0,1,sum(workspace.robotsize(3,:))/2];

<span class="comment">%this will hold the points which are obsticles and obviously known</span>
workspace.obsticlepoints=[];
<span class="comment">%this will hold the obstacles in voxeles (using inc_size)</span>
workspace.indexedobsticles=[];

<span class="comment">%this makes nbv_volume quicker by indexing the home points</span>
workspace.indexedobsticles_home_point=[];
workspace.indexedobsticles_equ=[];

<span class="comment">% There are 4 bands</span>
<span class="comment">% 1) robot workspace</span>
<span class="comment">% 2) max blast</span>
<span class="comment">% 3) blast danger</span>
<span class="comment">% 4) all else don't care about</span>
<span class="comment">%*level 1* is where the robot can move</span>
workspace.impLev(1).x=[-1.1,1.2];
workspace.impLev(1).y=[-1.2,1.2];
workspace.impLev(1).z=[2*workspace.inc_size,1.5];
<span class="comment">%*level 2* is where the robot can blast but not move</span>
workspace.impLev(2).x=[-1.4,1.5];
workspace.impLev(2).y=[-1.4,1.5];
workspace.impLev(2).z=[0,2.1];
<span class="comment">%*level 3* is where the robot can shoot sand but not blast and not move</span>
workspace.impLev(3).x=[workspace.min(1),workspace.max(1)];
workspace.impLev(3).y=[workspace.min(2),workspace.max(2)];
workspace.impLev(3).z=[workspace.min(3),workspace.max(3)];

<span class="comment">% This is the weight given to info in each of the levels</span>
<span class="comment">% *Note* points in level 1 are also in level 2 and 3 so they get weights for</span>
<span class="comment">% each (1), points in level 2 are also in 3 so they get both</span>
workspace.dotweight=[0.5,0.3,0.05];
<span class="comment">%used in NBV so say if all info is in top bracket then what would the weight be?</span>
workspace.dotweight_Sum=sum(workspace.dotweight);
<span class="comment">%so as it would be smaller increments</span>
workspace.unknowncoords=zeros([round(((workspace.max(1)-workspace.min(1))*<span class="keyword">...</span>
                                      (workspace.max(2)-workspace.min(2))*<span class="keyword">...</span>
                                      (workspace.max(3)-workspace.min(3)))/<span class="keyword">...</span>
                                      workspace.inc_size^3),3]);
</pre><h2>Adding floor obstacles for safety<a name="3"></a></h2><pre class="codeinput">points=[];
<span class="comment">% __Old Method to add points from a point cloud</span>
<span class="comment">% uiwait(msgbox('inputting worksace from memory (pointsCloud.mat) and div by 1, then only using points within range, also index (inc_size) here is halved but this will change with gathering of more points'));</span>
<span class="comment">% load pointsCloud.mat;</span>
<span class="comment">% points=points(find(points(:,1)&lt;.6 &amp; points(:,1)&gt;-.6),:);</span>
<span class="comment">% points=points(find(points(:,2)&lt;1 &amp; points(:,2)&gt;-1),:);</span>

<span class="comment">% Add a floor layer</span>
uiwait(msgbox(<span class="string">'Adding a floor layer only'</span>));
tempx=[];tempy=[];
tempInc=workspace.inc_size;
<span class="keyword">for</span> i=-.65:tempInc:.65
    tempx=[tempx;i*ones(length(-.65:tempInc:.65),1)];
    tempy=[tempy;(-.65:tempInc:.65)'];
<span class="keyword">end</span>
tempz=workspace.impLev(1).z(1)*ones([size(tempx,1),1]);
points=[points;[tempx,tempy,tempz]];

<span class="comment">% Only use points within the correct range</span>
level1=GetImpLevInfo(points);
points=points(level1,:);
workspace.obsticlepoints=points;
workspace.indexedobsticles=unique(floor(workspace.obsticlepoints/tempInc)*(tempInc),<span class="string">'rows'</span>);

<span class="comment">% Could also load up freespace variable</span>
<span class="comment">% a=load('workspace.mat');</span>
<span class="comment">% workspace.knowncoords=a.workspace.knowncoords;</span>
</pre><h2>Setup the unknown workspace<a name="4"></a></h2><pre class="codeinput">current_row=1;

temp_vals=round([workspace.min(3)-workspace.inc_size:workspace.inc_size:workspace.max(3)+workspace.inc_size]'./workspace.inc_size)*workspace.inc_size;
length_temp_vals=length(temp_vals);

<span class="keyword">for</span> x=workspace.min(1)-workspace.inc_size:workspace.inc_size:workspace.max(1)+workspace.inc_size
    <span class="keyword">for</span> y=workspace.min(2)-workspace.inc_size:workspace.inc_size:workspace.max(2)+workspace.inc_size
        workspace.unknowncoords(current_row:current_row+length_temp_vals-1,:)=[x*ones([length_temp_vals,1]),y*ones([length_temp_vals,1]),temp_vals];
        current_row=current_row+length_temp_vals;
    <span class="keyword">end</span>;
<span class="keyword">end</span>;

<span class="comment">%round to the correct index</span>
workspace.unknowncoords=round(workspace.unknowncoords/workspace.inc_size)*workspace.inc_size;

<span class="comment">%find point that are not in the robotsize space</span>
index=find((workspace.unknowncoords(:,1)&lt;workspace.robotsize(1,2) &amp; workspace.unknowncoords(:,1)&gt;workspace.robotsize(1,1)) &amp;<span class="keyword">...</span>
           (workspace.unknowncoords(:,2)&lt;workspace.robotsize(2,2) &amp; workspace.unknowncoords(:,2)&gt;workspace.robotsize(2,1)) &amp;<span class="keyword">...</span>
           (workspace.unknowncoords(:,3)&lt;workspace.robotsize(3,2) &amp; workspace.unknowncoords(:,3)&gt;workspace.robotsize(3,1)));
newindex=setdiff([1:size(workspace.unknowncoords,1)]',index);
workspace.unknowncoords=workspace.unknowncoords(newindex,:);

<span class="comment">%make sure all points are within the workspace</span>
[nothing1,nothing1,level3_un]=GetImpLevInfo(workspace.unknowncoords);
workspace.unknowncoords=workspace.unknowncoords(level3_un,:);
workspace.lev1unknown=GetImpLevInfo(workspace.unknowncoords);
</pre><h2>Plot the main unknown graph<a name="5"></a></h2><pre class="codeinput">hold <span class="string">on</span>;

xlabel(<span class="string">'x axis'</span>);ylabel(<span class="string">'y axis'</span>);zlabel(<span class="string">'z axis'</span>);
axis([workspace.min(1) workspace.max(1) workspace.min(2) workspace.max(2) workspace.min(3) workspace.max(3)]);
drawnow

<span class="comment">%if we are going to show the different levels of importance</span>
<span class="keyword">if</span> showunknownpnts
    level1=GetImpLevInfo(workspace.unknowncoords);
<span class="comment">%     _Old_ Gives the ability to plot all 3 levels of unknown</span>
<span class="comment">%     [level1,level2,level3]=GetImpLevInfo(workspace.unknowncoords);</span>
<span class="comment">%     level1=intersect(level2,level1);</span>
<span class="comment">%     level2=setdiff(level2,level1);</span>
<span class="comment">%     level3=setdiff(level3,union(level1,level2));</span>

   <span class="comment">% Plots for different weightings a different color</span>
   guiglobal.unknownplot=plot3(workspace.unknowncoords(level1,1),<span class="keyword">...</span>
                               workspace.unknowncoords(level1,2),<span class="keyword">...</span>
                               workspace.unknowncoords(level1,3),<span class="keyword">...</span>
                               <span class="string">'.'</span>,<span class="string">'Color'</span>,[1-workspace.dotweight(1) 1-workspace.dotweight(1) 1]);
<span class="comment">%     _Old_ Gives the ability to plot all 3 levels of unknown</span>
<span class="comment">%    plot3(workspace.unknowncoords(level2,1),workspace.unknowncoords(level2,2),workspace.unknowncoords(level2,3),'.','Color',[1-workspace.dotweight(2) 1-workspace.dotweight(2) 1])</span>
<span class="comment">%    plot3(workspace.unknowncoords(level3,1),workspace.unknowncoords(level3,2),workspace.unknowncoords(level3,3),'.','Color',[1-workspace.dotweight(3) 1-workspace.dotweight(3) 1])</span>
<span class="keyword">end</span>
</pre><p class="footer"><br>
            Published with MATLAB&reg; 7.4<br></p>
      </div>
      <!--
##### SOURCE BEGIN #####
%% setupworkspace
%
% *Description:* This sets the variables for the workspace with their
% different weightings and it draws this up in the main figure the robot
% (r) must be previously setup

%% Function Call
% 
% *Inputs:* 
%
% _showunknownpnts_ (bin) whether or not to display unknown points
%
% *Returns:* NULL
function setupworkspace(showunknownpnts)

%% Variables
%Declare global variables
global workspace r Q guiglobal;

% Check Inputs: default is not to show the points
if nargin<1
    display('You should tell me wether you want to show the weighted unknown poitns');
    showunknownpnts=false;
end

%The voxel increment size
workspace.inc_size=0.09;

%The only point known is where the robot arm is
initialpoint=fkine(r,Q);
workspace.knowncoords=[initialpoint(1:3,4)]';
% make it fit to the grid
workspace.knowncoords=(round(workspace.knowncoords./workspace.inc_size))*workspace.inc_size;

%The min and max of the workspace
workspace.min=[-1.6,-1.6,-workspace.inc_size/2];
workspace.max=[1.6,1.6,2.5];
%make it fit to the grid
workspace.min=workspace.inc_size.*round(workspace.min/workspace.inc_size);
workspace.max=workspace.inc_size.*round(workspace.max/workspace.inc_size);

%holds the radius size for surfaces for exploration
workspace.mew=0.30;

%holds the robot basic unmovable size which takes points away from expecting scans
workspace.robotsize=[-0.45,0.45;
                     -0.45,0.45;
                        0,0.89];

%These are the home point of the disk planes that are at 0,0,0 and halfway
%up the robot: this stops the robot trying to self scan since it will not
%see anothing looking through itself, THESE HAVE ALSO BEEN INDEXED
workspace.robotplanes.home_points=round([zeros([3,3]);...
    ones([3,1])*[0,0,sum(workspace.robotsize(3,:))/2]]./workspace.inc_size)*workspace.inc_size;                               
%These are the equations of the planes
workspace.robotplanes.equ=[1,0,0,0; 0,1,0,0; 0,0,1,0;
                           1,0,0,0; 0,1,0,0; 0,0,1,sum(workspace.robotsize(3,:))/2];

%this will hold the points which are obsticles and obviously known
workspace.obsticlepoints=[];
%this will hold the obstacles in voxeles (using inc_size)
workspace.indexedobsticles=[];

%this makes nbv_volume quicker by indexing the home points
workspace.indexedobsticles_home_point=[];
workspace.indexedobsticles_equ=[];

% There are 4 bands 
% 1) robot workspace
% 2) max blast
% 3) blast danger
% 4) all else don't care about
%*level 1* is where the robot can move
workspace.impLev(1).x=[-1.1,1.2];
workspace.impLev(1).y=[-1.2,1.2];
workspace.impLev(1).z=[2*workspace.inc_size,1.5];
%*level 2* is where the robot can blast but not move
workspace.impLev(2).x=[-1.4,1.5];
workspace.impLev(2).y=[-1.4,1.5];
workspace.impLev(2).z=[0,2.1];
%*level 3* is where the robot can shoot sand but not blast and not move
workspace.impLev(3).x=[workspace.min(1),workspace.max(1)];
workspace.impLev(3).y=[workspace.min(2),workspace.max(2)];
workspace.impLev(3).z=[workspace.min(3),workspace.max(3)];

% This is the weight given to info in each of the levels
% *Note* points in level 1 are also in level 2 and 3 so they get weights for
% each (1), points in level 2 are also in 3 so they get both
workspace.dotweight=[0.5,0.3,0.05];
%used in NBV so say if all info is in top bracket then what would the weight be?
workspace.dotweight_Sum=sum(workspace.dotweight);
%so as it would be smaller increments
workspace.unknowncoords=zeros([round(((workspace.max(1)-workspace.min(1))*...
                                      (workspace.max(2)-workspace.min(2))*...
                                      (workspace.max(3)-workspace.min(3)))/...
                                      workspace.inc_size^3),3]);
%% Adding floor obstacles for safety
points=[];
% __Old Method to add points from a point cloud
% uiwait(msgbox('inputting worksace from memory (pointsCloud.mat) and div by 1, then only using points within range, also index (inc_size) here is halved but this will change with gathering of more points'));
% load pointsCloud.mat;
% points=points(find(points(:,1)<.6 & points(:,1)>-.6),:);
% points=points(find(points(:,2)<1 & points(:,2)>-1),:);

% Add a floor layer
uiwait(msgbox('Adding a floor layer only'));
tempx=[];tempy=[]; 
tempInc=workspace.inc_size;
for i=-.65:tempInc:.65
    tempx=[tempx;i*ones(length(-.65:tempInc:.65),1)];
    tempy=[tempy;(-.65:tempInc:.65)'];
end
tempz=workspace.impLev(1).z(1)*ones([size(tempx,1),1]);
points=[points;[tempx,tempy,tempz]];

% Only use points within the correct range
level1=GetImpLevInfo(points);
points=points(level1,:);
workspace.obsticlepoints=points;
workspace.indexedobsticles=unique(floor(workspace.obsticlepoints/tempInc)*(tempInc),'rows');

% Could also load up freespace variable 
% a=load('workspace.mat');
% workspace.knowncoords=a.workspace.knowncoords;                                  

%% Setup the unknown workspace 
current_row=1;

temp_vals=round([workspace.min(3)-workspace.inc_size:workspace.inc_size:workspace.max(3)+workspace.inc_size]'./workspace.inc_size)*workspace.inc_size;
length_temp_vals=length(temp_vals);

for x=workspace.min(1)-workspace.inc_size:workspace.inc_size:workspace.max(1)+workspace.inc_size  
    for y=workspace.min(2)-workspace.inc_size:workspace.inc_size:workspace.max(2)+workspace.inc_size
        workspace.unknowncoords(current_row:current_row+length_temp_vals-1,:)=[x*ones([length_temp_vals,1]),y*ones([length_temp_vals,1]),temp_vals];
        current_row=current_row+length_temp_vals;
    end; 
end;

%round to the correct index
workspace.unknowncoords=round(workspace.unknowncoords/workspace.inc_size)*workspace.inc_size;

%find point that are not in the robotsize space
index=find((workspace.unknowncoords(:,1)<workspace.robotsize(1,2) & workspace.unknowncoords(:,1)>workspace.robotsize(1,1)) &...
           (workspace.unknowncoords(:,2)<workspace.robotsize(2,2) & workspace.unknowncoords(:,2)>workspace.robotsize(2,1)) &...
           (workspace.unknowncoords(:,3)<workspace.robotsize(3,2) & workspace.unknowncoords(:,3)>workspace.robotsize(3,1)));
newindex=setdiff([1:size(workspace.unknowncoords,1)]',index);
workspace.unknowncoords=workspace.unknowncoords(newindex,:);

%make sure all points are within the workspace
[nothing1,nothing1,level3_un]=GetImpLevInfo(workspace.unknowncoords);
workspace.unknowncoords=workspace.unknowncoords(level3_un,:);
workspace.lev1unknown=GetImpLevInfo(workspace.unknowncoords);

%% Plot the main unknown graph
hold on;

xlabel('x axis');ylabel('y axis');zlabel('z axis');
axis([workspace.min(1) workspace.max(1) workspace.min(2) workspace.max(2) workspace.min(3) workspace.max(3)]);
drawnow

%if we are going to show the different levels of importance
if showunknownpnts
    level1=GetImpLevInfo(workspace.unknowncoords);
%     _Old_ Gives the ability to plot all 3 levels of unknown
%     [level1,level2,level3]=GetImpLevInfo(workspace.unknowncoords);
%     level1=intersect(level2,level1);
%     level2=setdiff(level2,level1);
%     level3=setdiff(level3,union(level1,level2));
   
   % Plots for different weightings a different color
   guiglobal.unknownplot=plot3(workspace.unknowncoords(level1,1),...
                               workspace.unknowncoords(level1,2),...
                               workspace.unknowncoords(level1,3),...
                               '.','Color',[1-workspace.dotweight(1) 1-workspace.dotweight(1) 1]);
%     _Old_ Gives the ability to plot all 3 levels of unknown
%    plot3(workspace.unknowncoords(level2,1),workspace.unknowncoords(level2,2),workspace.unknowncoords(level2,3),'.','Color',[1-workspace.dotweight(2) 1-workspace.dotweight(2) 1])
%    plot3(workspace.unknowncoords(level3,1),workspace.unknowncoords(level3,2),workspace.unknowncoords(level3,3),'.','Color',[1-workspace.dotweight(3) 1-workspace.dotweight(3) 1])
end
##### SOURCE END #####
-->
   </body>
</html>