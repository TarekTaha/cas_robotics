
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN">
<html xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   
      <!--
This HTML is auto-generated from an M-file.
To make changes, update the M-file and republish this document.
      -->
      <title>Pose Selection To Classify Unknown - Implementation Ver</title>
      <meta name="generator" content="MATLAB 7.4">
      <meta name="date" content="2008-05-07">
      <meta name="m-file" content="poseclassunknown_Imp"><style>

body {
  background-color: white;
  margin:10px;
}

h1 {
  color: #990000; 
  font-size: x-large;
}

h2 {
  color: #990000;
  font-size: medium;
}

/* Make the text shrink to fit narrow windows, but not stretch too far in 
wide windows. */ 
p,h1,h2,div.content div {
  max-width: 600px;
  /* Hack for IE6 */
  width: auto !important; width: 600px;
}

pre.codeinput {
  background: #EEEEEE;
  padding: 10px;
}
@media print {
  pre.codeinput {word-wrap:break-word; width:100%;}
} 

span.keyword {color: #0000FF}
span.comment {color: #228B22}
span.string {color: #A020F0}
span.untermstring {color: #B20000}
span.syscmd {color: #B28C00}

pre.codeoutput {
  color: #666666;
  padding: 10px;
}

pre.error {
  color: red;
}

p.footer {
  text-align: right;
  font-size: xx-small;
  font-weight: lighter;
  font-style: italic;
  color: gray;
}

  </style></head>
   <body>
      <div class="content">
         <h1>Pose Selection To Classify Unknown - Implementation Ver</h1>
         <introduction>
            <p>Description: This function is used to identiy areas which have unknown classification and attempt to look at them in such
               a way that we can do a classification function poseclassunknown_Imp()
            </p>
         </introduction>
         <h2>Contents</h2>
         <div>
            <ul>
               <li><a href="#1">Setup and Variables</a></li>
               <li><a href="#2">Load data or classify a scan</a></li>
               <li><a href="#3">More Vars</a></li>
               <li><a href="#4">put classification data in one big matrix</a></li>
               <li><a href="#5">plot and make surfaces out of these</a></li>
               <li><a href="#6">Find the planes covering most unknown points</a></li>
               <li><a href="#7">Go through the number of planese we are interested in</a></li>
            </ul>
         </div>
         <h2>Setup and Variables<a name="1"></a></h2><pre class="codeinput">close <span class="string">all</span>
<span class="keyword">global</span> r Q PointData RangeData IntensityData

figure(1)
<span class="comment">% plot_planes(plane,mew);</span>
axis([-1,1,-1,1,0,1.5]);
<span class="comment">% axis equal</span>
camlight
</pre><img vspace="5" hspace="5" src="poseclassunknown_Imp_01.png"> <h2>Load data or classify a scan<a name="2"></a></h2><pre class="codeinput">NOhandleOPTIONS.useRealRobot=false;
NOhandleOPTIONS.show_robot=true;
NOhandleOPTIONS.animate_move=false;
NOhandleOPTIONS.remv_unkn_in_mv=false;

<span class="comment">%take one scan from an initial pose</span>
newQ=[0,-88*pi/180,140*pi/180,0,0*pi/180,0];
<span class="comment">%move to the next place</span>
movetonewQ(0,rad2deg(newQ),[],NOhandleOPTIONS);
Q=newQ;

<span class="comment">% and do a scan to classify</span>
<span class="keyword">if</span> NOhandleOPTIONS.useRealRobot
    <span class="keyword">try</span> use_real_robot_SCAN(90); <span class="keyword">catch</span>; display(<span class="string">'Couldnt scan'</span>);<span class="keyword">end</span>
<span class="keyword">end</span>

<span class="keyword">try</span> [ClassifiedData] = Block_Classifier(PointData, IntensityData, RangeData); <span class="keyword">catch</span>; display(<span class="string">'Couldnt classify'</span>);<span class="keyword">end</span>
</pre><pre class="codeoutput">Handles not passed in so not updating the GUI
Already at destination
Couldnt classify
</pre><img vspace="5" hspace="5" src="poseclassunknown_Imp_02.png"> <h2>More Vars<a name="3"></a></h2><pre class="codeinput">class_cubesize=0.045;

<span class="comment">%minimum number of classifications in voxel to make it valid</span>
minclassifications=60;
<span class="comment">% minimmum majority classification to make it useful</span>
classfierthreshhold=1.5;

<span class="comment">% the classifier reterns a classification of this number is unknown</span>
unknownclass=8;
<span class="comment">%size of the surfaces which is 1/2 of 20' scan at ideal distance 0.5*tan(20*pi/180)</span>
mew=0.1;
<span class="comment">% This is how many sets of data we will classify</span>
numofintplanes=1;
<span class="comment">%how many solutions and failures</span>
solsfound=0;
noposefound=0;



<span class="comment">%optimisataion variables</span>
<span class="keyword">global</span> classunkn_optimise
classunkn_optimise.minSurfToEF=0.3;
classunkn_optimise.maxSurfToEF=0.8;
classunkn_optimise.distAwayfromTarget=0.45;
classunkn_optimise.maxAngle=30*pi/180;

classunkn_optimise.iLimit=200;
classunkn_optimise.stol=1e-5;
</pre><h2>put classification data in one big matrix<a name="4"></a></h2>
         <p>some text to dwescribe</p><pre class="codeinput">display(<span class="string">'TEMP LOADING DATA'</span>);load <span class="string">GavData</span>;ClassifiedData=ClassifiedDatawEdges;
pointswithclass=zeros([size(PointData,1)*size(PointData,2),4]);
<span class="keyword">for</span> i=1:size(PointData,1);
    pointswithclass((i-1)*size(PointData,2)+1:i*size(PointData,2),:)=[squeeze(PointData(i,:,:)),ClassifiedData(i,:)'];
<span class="keyword">end</span>;

<span class="comment">%discreatise into grid</span>
class_ocgrid=[round(pointswithclass(:,1:3)/class_cubesize),pointswithclass(:,4)];
<span class="comment">% hold on;plot3(class_ocgrid(:,1)*class_cubesize,class_ocgrid(:,2)*class_cubesize,class_ocgrid(:,3)*class_cubesize,'y.','markersize',2)</span>


<span class="comment">% pnts=[-7,10,26;-9,3,30;-8,-13,27];</span>
<span class="comment">% pause</span>
<span class="comment">% for i=1:3</span>
<span class="comment">%     pnt=pnts(i,:);</span>
<span class="comment">%     text(pnt(1)*class_cubesize,pnt(2)*class_cubesize,pnt(3)*class_cubesize,num2str(i));</span>
<span class="comment">%     figure;hist(class_ocgrid(find(class_ocgrid(:,1)==pnt(1) &amp; class_ocgrid(:,2)==pnt(2) &amp; class_ocgrid(:,3)==pnt(3)),4))</span>
<span class="comment">%     pause</span>
<span class="comment">% end</span>
ocgrid=unique(class_ocgrid(:,1:3),<span class="string">'rows'</span>);
ocgrid=[ocgrid,zeros([size(ocgrid,1),3])];
<span class="keyword">for</span> i=1:size(ocgrid,1)
    tempdata=class_ocgrid(class_ocgrid(:,1)==ocgrid(i,1) &amp; class_ocgrid(:,2)==ocgrid(i,2) &amp; class_ocgrid(:,3)==ocgrid(i,3),4);
    metalnum=size(find(tempdata&lt;=5),1);
    woodnum=size(find(tempdata&gt;=6 &amp; tempdata&lt;=7),1);
    unknownnum=size(find(tempdata&gt;=8),1);
    ocgrid(i,4)=ocgrid(i,4)+metalnum;
    ocgrid(i,5)=ocgrid(i,5)+woodnum;
    ocgrid(i,6)=ocgrid(i,6)+unknownnum;
<span class="keyword">end</span>


<span class="comment">% figure(2)</span>
sumofclass=ocgrid(:,4)+ocgrid(:,5);
classifiedvoxels=find(sumofclass&gt;=minclassifications &amp; (ocgrid(:,4)./ocgrid(:,5)&gt;classfierthreshhold | ocgrid(:,5)./ocgrid(:,4)&gt;classfierthreshhold));
UNclassifiedvoxels=find(sumofclass&lt;minclassifications | (ocgrid(:,4)./ocgrid(:,5)&lt;=classfierthreshhold &amp; ocgrid(:,5)./ocgrid(:,4)&lt;=classfierthreshhold));
hold <span class="string">on</span>;plot3(ocgrid(UNclassifiedvoxels,1)*class_cubesize,ocgrid(UNclassifiedvoxels,2)*class_cubesize,ocgrid(UNclassifiedvoxels,3)*class_cubesize,<span class="string">'y.'</span>);
<span class="comment">%plot metal and wood voxels</span>

metalvoxels=ocgrid(classifiedvoxels(ocgrid(classifiedvoxels,4)&gt;ocgrid(classifiedvoxels,5)),1:3);
plot3(metalvoxels(:,1)*class_cubesize,metalvoxels(:,2)*class_cubesize,metalvoxels(:,3)*class_cubesize,<span class="string">'r.'</span>);

woodvoxels=ocgrid(classifiedvoxels(ocgrid(classifiedvoxels,4)&lt;ocgrid(classifiedvoxels,5)),1:3);
plot3(woodvoxels(:,1)*class_cubesize,woodvoxels(:,2)*class_cubesize,woodvoxels(:,3)*class_cubesize,<span class="string">'b.'</span>);


<span class="comment">%find unknown points</span>
<span class="comment">% unknownindex=find(pointswithclass(:,4)==unknownclass);</span>
</pre><pre class="codeoutput">TEMP LOADING DATA
</pre><img vspace="5" hspace="5" src="poseclassunknown_Imp_03.png"> <h2>plot and make surfaces out of these<a name="5"></a></h2>
         <p>plot3(pointswithclass(unknownindex,1),pointswithclass(unknownindex,2),pointswithclass(unknownindex,3),'r.')</p><pre class="codeinput">surface_making_simple(ocgrid(UNclassifiedvoxels,:)*class_cubesize,mew)
<span class="keyword">global</span> plane
</pre><h2>Find the planes covering most unknown points<a name="6"></a></h2>
         <p>these are desirable places to look</p><pre class="codeinput">sizemat=zeros([length(plane),1]);
<span class="keyword">for</span> i=1:length(plane)
    sizemat(i)=size(plane(i).points,1);
<span class="keyword">end</span>

<span class="comment">% order these</span>
[nothing,index]=sort(sizemat,<span class="string">'descend'</span>);
<span class="comment">%make sure we have at max, the specified numofintplanes</span>
<span class="keyword">if</span> length(index)&lt;numofintplanes
    numofintplanes=index;
<span class="keyword">end</span>
</pre><h2>Go through the number of planese we are interested in<a name="7"></a></h2><pre class="codeinput"><span class="keyword">for</span> i=1:numofintplanes

<span class="comment">% plot plane and points</span>
    <span class="keyword">try</span> <span class="keyword">for</span> j=1:length(planeplotHa);  delete(planeplotHa(j));<span class="keyword">end</span>; <span class="keyword">end</span>
    planeplotHa=plot_planes(plane(index(i)),mew);

    hold <span class="string">on</span>;
    planeplotHa(2)=plot3(plane(index(i)).home_point(1),plane(index(i)).home_point(2),plane(index(i)).home_point(3),<span class="string">'b*'</span>);
    planeplotHa(3)=plot3([plane(index(i)).home_point(1),plane(index(i)).home_point(1)+plane(index(i)).normal_by_eigenval(1)/10],<span class="keyword">...</span>
                         [plane(index(i)).home_point(2),plane(index(i)).home_point(2)+plane(index(i)).normal_by_eigenval(2)/10],<span class="keyword">...</span>
                         [plane(index(i)).home_point(3),plane(index(i)).home_point(3)+plane(index(i)).normal_by_eigenval(3)/10],<span class="string">'b'</span>);



    pt=plane(index(i)).home_point;
    plane_equ=plane(index(i)).equ;

    <span class="keyword">try</span> [newQ,solutionvalid,dist_val,targetdist]=classunk_posesel(pt, plane_equ, Q);
        <span class="keyword">if</span> solutionvalid
            solsfound=solsfound+1;
            display([<span class="string">'Solution found = '</span>,num2str(solsfound)]);
            title([<span class="string">'Solution found = '</span>,num2str(solsfound)]);
            <span class="comment">%make sure vector is correct</span>
            newQ=newQ(:)';

            <span class="comment">%move to the next place</span>
            movetonewQ(0,rad2deg(newQ),[],NOhandleOPTIONS);
            <span class="comment">% and do a scan to classify</span>
            <span class="keyword">if</span> NOhandleOPTIONS.useRealRobot
                <span class="comment">%try and move through a complete scan so we have to make newQ standard</span>
                newQ=[newQ(1:4)',-15*pi/180,0];
                movetonewQ(0,rad2deg(newQ),[],NOhandleOPTIONS);
                <span class="keyword">try</span> use_real_robot_SCAN(90); <span class="keyword">catch</span>; display(<span class="string">'Could do anything'</span>);<span class="keyword">end</span>
            <span class="keyword">end</span>

<span class="comment">%             try [ClassifiedData] = Block_Classifier(PointData, IntensityData, RangeData);end</span>

            Q=newQ;
        <span class="keyword">else</span>
            noposefound=noposefound+1;
            display([<span class="string">'no pose found = '</span>, num2str(noposefound)]);
            title([<span class="string">'no pose found = '</span>, num2str(noposefound)]);
        <span class="keyword">end</span>
    <span class="keyword">catch</span>
        noposefound=noposefound+1;
        display(<span class="string">'Some error'</span>);
        title([<span class="string">'Some error:no pose found = '</span>, num2str(noposefound)]);
    <span class="keyword">end</span>
<span class="keyword">end</span>
</pre><pre class="codeoutput">End Effector is TOO FAR AWAY from aimed at point
close enough without moving 4 or 5
The actual INTERSECTION point shot is TOO FAR AWAY from aimed at point
no pose found = 1
</pre><img vspace="5" hspace="5" src="poseclassunknown_Imp_04.png"> <p class="footer"><br>
            Published with MATLAB&reg; 7.4<br></p>
      </div>
      <!--
##### SOURCE BEGIN #####
%% Pose Selection To Classify Unknown - Implementation Ver
% Description: This function is used to identiy areas which have unknown
% classification and attempt to look at them in such a way that we can do a
% classification
% function poseclassunknown_Imp()

%% Setup and Variables
close all
global r Q PointData RangeData IntensityData

figure(1)
% plot_planes(plane,mew);
axis([-1,1,-1,1,0,1.5]);
% axis equal
camlight

%% Load data or classify a scan

NOhandleOPTIONS.useRealRobot=false;
NOhandleOPTIONS.show_robot=true;
NOhandleOPTIONS.animate_move=false;
NOhandleOPTIONS.remv_unkn_in_mv=false;    

%take one scan from an initial pose
newQ=[0,-88*pi/180,140*pi/180,0,0*pi/180,0];
%move to the next place
movetonewQ(0,rad2deg(newQ),[],NOhandleOPTIONS);
Q=newQ;

% and do a scan to classify
if NOhandleOPTIONS.useRealRobot
    try use_real_robot_SCAN(90); catch; display('Couldnt scan');end
end
            
try [ClassifiedData] = Block_Classifier(PointData, IntensityData, RangeData); catch; display('Couldnt classify');end
            

%% More Vars
class_cubesize=0.045;

%minimum number of classifications in voxel to make it valid
minclassifications=60;
% minimmum majority classification to make it useful
classfierthreshhold=1.5;

% the classifier reterns a classification of this number is unknown
unknownclass=8;
%size of the surfaces which is 1/2 of 20' scan at ideal distance 0.5*tan(20*pi/180)
mew=0.1;
% This is how many sets of data we will classify
numofintplanes=1;
%how many solutions and failures
solsfound=0;
noposefound=0;



%optimisataion variables
global classunkn_optimise
classunkn_optimise.minSurfToEF=0.3;
classunkn_optimise.maxSurfToEF=0.8;
classunkn_optimise.distAwayfromTarget=0.45;
classunkn_optimise.maxAngle=30*pi/180;

classunkn_optimise.iLimit=200;
classunkn_optimise.stol=1e-5;

%% put classification data in one big matrix
% some text to dwescribe
display('TEMP LOADING DATA');load GavData;ClassifiedData=ClassifiedDatawEdges;
pointswithclass=zeros([size(PointData,1)*size(PointData,2),4]);
for i=1:size(PointData,1);
    pointswithclass((i-1)*size(PointData,2)+1:i*size(PointData,2),:)=[squeeze(PointData(i,:,:)),ClassifiedData(i,:)'];
end;

%discreatise into grid
class_ocgrid=[round(pointswithclass(:,1:3)/class_cubesize),pointswithclass(:,4)];
% hold on;plot3(class_ocgrid(:,1)*class_cubesize,class_ocgrid(:,2)*class_cubesize,class_ocgrid(:,3)*class_cubesize,'y.','markersize',2)


% pnts=[-7,10,26;-9,3,30;-8,-13,27];
% pause
% for i=1:3
%     pnt=pnts(i,:);
%     text(pnt(1)*class_cubesize,pnt(2)*class_cubesize,pnt(3)*class_cubesize,num2str(i));
%     figure;hist(class_ocgrid(find(class_ocgrid(:,1)==pnt(1) & class_ocgrid(:,2)==pnt(2) & class_ocgrid(:,3)==pnt(3)),4))
%     pause
% end
ocgrid=unique(class_ocgrid(:,1:3),'rows');
ocgrid=[ocgrid,zeros([size(ocgrid,1),3])];
for i=1:size(ocgrid,1)
    tempdata=class_ocgrid(class_ocgrid(:,1)==ocgrid(i,1) & class_ocgrid(:,2)==ocgrid(i,2) & class_ocgrid(:,3)==ocgrid(i,3),4);
    metalnum=size(find(tempdata<=5),1);
    woodnum=size(find(tempdata>=6 & tempdata<=7),1);
    unknownnum=size(find(tempdata>=8),1);
    ocgrid(i,4)=ocgrid(i,4)+metalnum;
    ocgrid(i,5)=ocgrid(i,5)+woodnum;
    ocgrid(i,6)=ocgrid(i,6)+unknownnum;
end


% figure(2)
sumofclass=ocgrid(:,4)+ocgrid(:,5);
classifiedvoxels=find(sumofclass>=minclassifications & (ocgrid(:,4)./ocgrid(:,5)>classfierthreshhold | ocgrid(:,5)./ocgrid(:,4)>classfierthreshhold));
UNclassifiedvoxels=find(sumofclass<minclassifications | (ocgrid(:,4)./ocgrid(:,5)<=classfierthreshhold & ocgrid(:,5)./ocgrid(:,4)<=classfierthreshhold));
hold on;plot3(ocgrid(UNclassifiedvoxels,1)*class_cubesize,ocgrid(UNclassifiedvoxels,2)*class_cubesize,ocgrid(UNclassifiedvoxels,3)*class_cubesize,'y.');
%plot metal and wood voxels

metalvoxels=ocgrid(classifiedvoxels(ocgrid(classifiedvoxels,4)>ocgrid(classifiedvoxels,5)),1:3);
plot3(metalvoxels(:,1)*class_cubesize,metalvoxels(:,2)*class_cubesize,metalvoxels(:,3)*class_cubesize,'r.');

woodvoxels=ocgrid(classifiedvoxels(ocgrid(classifiedvoxels,4)<ocgrid(classifiedvoxels,5)),1:3);
plot3(woodvoxels(:,1)*class_cubesize,woodvoxels(:,2)*class_cubesize,woodvoxels(:,3)*class_cubesize,'b.');


%find unknown points
% unknownindex=find(pointswithclass(:,4)==unknownclass);

%% plot and make surfaces out of these
% plot3(pointswithclass(unknownindex,1),pointswithclass(unknownindex,2),pointswithclass(unknownindex,3),'r.')

surface_making_simple(ocgrid(UNclassifiedvoxels,:)*class_cubesize,mew)
global plane



%% Find the planes covering most unknown points
% these are desirable places to look
sizemat=zeros([length(plane),1]);
for i=1:length(plane)
    sizemat(i)=size(plane(i).points,1);
end

% order these
[nothing,index]=sort(sizemat,'descend');
%make sure we have at max, the specified numofintplanes
if length(index)<numofintplanes
    numofintplanes=index;
end

%% Go through the number of planese we are interested in
for i=1:numofintplanes

% plot plane and points 
    try for j=1:length(planeplotHa);  delete(planeplotHa(j));end; end
    planeplotHa=plot_planes(plane(index(i)),mew);    

    hold on;
    planeplotHa(2)=plot3(plane(index(i)).home_point(1),plane(index(i)).home_point(2),plane(index(i)).home_point(3),'b*');
    planeplotHa(3)=plot3([plane(index(i)).home_point(1),plane(index(i)).home_point(1)+plane(index(i)).normal_by_eigenval(1)/10],...
                         [plane(index(i)).home_point(2),plane(index(i)).home_point(2)+plane(index(i)).normal_by_eigenval(2)/10],...
                         [plane(index(i)).home_point(3),plane(index(i)).home_point(3)+plane(index(i)).normal_by_eigenval(3)/10],'b');    
                     
    
     
    pt=plane(index(i)).home_point;
    plane_equ=plane(index(i)).equ;
    
    try [newQ,solutionvalid,dist_val,targetdist]=classunk_posesel(pt, plane_equ, Q);
        if solutionvalid
            solsfound=solsfound+1;
            display(['Solution found = ',num2str(solsfound)]);
            title(['Solution found = ',num2str(solsfound)]);
            %make sure vector is correct
            newQ=newQ(:)';
                       
            %move to the next place
            movetonewQ(0,rad2deg(newQ),[],NOhandleOPTIONS);
            % and do a scan to classify
            if NOhandleOPTIONS.useRealRobot
                %try and move through a complete scan so we have to make newQ standard
                newQ=[newQ(1:4)',-15*pi/180,0];
                movetonewQ(0,rad2deg(newQ),[],NOhandleOPTIONS);
                try use_real_robot_SCAN(90); catch; display('Could do anything');end
            end
            
%             try [ClassifiedData] = Block_Classifier(PointData, IntensityData, RangeData);end

            Q=newQ;
        else
            noposefound=noposefound+1;            
            display(['no pose found = ', num2str(noposefound)]);
            title(['no pose found = ', num2str(noposefound)]);
        end
    catch   
        noposefound=noposefound+1;
        display('Some error');
        title(['Some error:no pose found = ', num2str(noposefound)]);
    end
end






##### SOURCE END #####
-->
   </body>
</html>