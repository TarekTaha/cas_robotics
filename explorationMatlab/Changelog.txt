8/8/2007 Wednesday
- Removed the talk2c() functionality which previous versions had
- Used a modified version of the surface making algorithm that Nathan program will use as 
the new contained surface maker so that we don't have to use the other from the other directory
This was in files organise_data.m and exGui.m
- Removed %ratioOfScansToUse=2; from the organise_data, this was commented out anyway
- Removed the commented out section %clear global PointData RangeData; of organise_data since it was not helping
- Removed %numpntsInCube=0.5; % this can be anything greater than 0, a value of 0.5 would mean 1 point in every 2 cubes at the max scan value
from organise_data.m
- readded the global plane to surface_making_simple
also the "clear global plane"
- Removed the file dijkstra.m which is in older folders, still keeping the new version
- trying to change all stream ontos to be streamOnto_mine_manystarts.m removing the check_robot.m function, 
this  exists in previous folders. 
- removing the original streamOnto_mine.m file
%[valid_pose,Q_temp]=check_robot([x,y,z],scan.chosenview);
[Q_temp,valid_pose]=streamOnto_mine_manystarts(r,[x,y,z],scan.chosenview,Q);
- Removed talk2c from explore.m
%% Send Data to C sim
%send the new joint coords
talk2c(1,rand(1,6)*360-180);
%send the new points to add to the workspace
talk2c(2,workspace.newestknownledge);



9/8/2007 Thursday
- Removed 2 instances of  %[valid_pose,Q_temp]=check_robot([x,y,z],scan.chosenview);
and replaced with the streamOnto_mine_manystarts
- Removed a large section of the pathplanner where the old streamOnto_mine_withCD still was
	%alternate_newQ=[streamOnto_mine_withCD(r,requiredT(1:3,4),requiredT(1:3,3),Q)]';
It then went through and rtied different ways of getting to the end
%         %check that the solution found is close enough to be considered valid
%         pnt=fkine(r,alternate_newQ);
%         if optimise.minAccepDis<sqrt(sum((requiredT(1:3,4)'-pnt(1:3,4)').^2)) ||  length(find(alternate_newQ'<qlimits(:,1)))>0 || length(find(alternate_newQ'>qlimits(:,2)))>0
%             if disON; display('Did not find a valid solution from current starting pos, trying Q all zeros');end
%             alternate_newQ=[streamOnto_mine_withCD(r,requiredT(1:3,4),requiredT(1:3,3))]';
%             pnt=fkine(r,alternate_newQ);    
%             %if it wasn't close enough 
%             if optimise.minAccepDis<sqrt(sum((requiredT(1:3,4)'-pnt(1:3,4)').^2)) ||  length(find(alternate_newQ'<qlimits(:,1)))>0 || length(find(alternate_newQ'>qlimits(:,2)))>0
%                 if disON; display('Still could not find a valid pose with this end effector pose - Halving num of itterations');end
%                 %don't use the alternate solution
%                 tryalternate=0; 
%                 %we only want to go through 1/2 the amount of times since not using alternate
%                 numofPPiterations=numofPPiterations/2;
%             end  
%         end
This is all deleted. It exists in previous versions. THIS NEW STUFF HASN'T BEEN TESTED
- Deleted the streamOnto_mine_withCD file



10/8/2007 Friday
- Changed pathplanner so that the tempQ returned was saved to the correct variable alternate_Q
- in stream onto mine many starts, went through and changed qt so that it was a 1*6 matrix


13/8/2007 Monday
- There was a problem with the prediction, we have changed the transformation of preformulated points
so that 
if tr(1,1)>0
%if tr(1,1)<0
    points=[-1*points(:,1),points(:,2:3)];
end
....AND.....
if tr(3,3)>0
%if tr(3,3)<0
    points=[points(:,1:2),-1*points(:,3)];
end
This way we are getting the correct transformation for the guess
- Found a BIG problem with the transforming of point tr. We are currently using it like 1 vector
made up by adding all the vectors together, however we should be thinking about it as just the z 
vector part of tr, in other words tr(1:3,3)
- Adding this to nbv_volume() 
points=points*[zeros([3,2]),tr(1:3,3)];

and to NBV which calls it

%         tr=[chosenview_array(currentview).val(1),0,0,scan_origin(1);
%             0,chosenview_array(currentview).val(2),0,scan_origin(2);
%             0,0,chosenview_array(currentview).val(3),scan_origin(3);
%             0,0,0,1];
        tr=[0,0,chosenview_array(currentview).val(1),scan_origin(1);
            0,0,chosenview_array(currentview).val(2),scan_origin(2);
            0,0,chosenview_array(currentview).val(3),scan_origin(3);
            0,0,0,1];

-IGNORING THIS- since it is not correct to use this as the transform, just have to be careful about how it is used
Adding this check to nbv_volume so that if we are using the normal method it will be simply changed, but if an actual tr 
is passed in (IE one where the actual head of the robot isgive we can use the proper transformation function *tr(1:3,1:3)
if tr(2,1)==0&&tr(1,2)==0 && tr(3,1)==0&&tr(1,3)==0 && tr(2,3)==0&&tr(3,2)==0

- Added another check in the streamOnto_mine_manystarts
 && length(find(residual>1))==0
Since it seems that some "solutions" are not valid because of their direction and this is being allowed
- Changed function doscan(newQ) so that it takes the newQ since before it was trying to use the global Q and this isn't helpful 
since this is where the robot currently is
- Removed the "return" statement from the scan_through_pushbutton_Callback function in exGUI so that it can get further on, What is here is pretty shitt
- Added some extra functionality in the explore() function when we are not using a real robot
- CAREFUL, since you are checking for a path as part of validating a NBV, however the steps will be from the current Q, so if you click on more than one of these
suggested NBVs and then use the path that is pre-generated then there will be a problem with the path since the start Q IS DIFFERENT
- Moved num_bestviews and valid_max from scan global to optimise global, they are only used in NBV anyway
%this is how many views to save for the NBV
optimise.num_bestviews=30;
optimise.valid_max=10; %only need 10 valid best views and thats enough
- Changed pose sel op to be 100 iterations


14/8/2007 Tuesday
- In nbv_volume you are only using planes where the home point is inside the importance level 1, this increases speed but it means that planes just outside are not included!!
THIS HAS TO BE FIXED, should make it at least importance level 2 as well
ADDED these 2 lines so that we are comparing points and plane home points from within imp level2
[nothing,planes_of_interest]=getImpLevInfo(temp_plane_homepnts);
[nothing,Implev2]=getImpLevInfo(points);

- I don't think that this line is working properly 
[obstructingPNTS,plane_index,point_index]=intersect(temp_plane_homepnts(planes_of_interest,:),...
                                                    points(getImpLevInfo(points),:),'rows');
I think it is trying to find out if any plane home points are at the same point as points from the new scan, if they are then it will work 
out how some may be shadowed
- Added a "quickver" quick version option in the stream_onto_manystarts so it only goes through 2 starts

15/8/2007 Wednesday
- if there is no valid distance then it will now return dist_val==inf rather than -1, generally this does not happen as it finds a distance but it is too far
- In the least sqared optimisation I just found that the residual returned does not correspond with the best (most optimial solution retunred), it seems to usually be the second last
removed this from the fuinction return call "resnorm,residual,exitFlag,output,lambda,jacobian"
[dq,resnorm,residual,exitFlag,output,lambda,jacobian] = lsqnonlin(@costComponents, xGuess, lb, ub, options);
since it isn't used (and shouldn't be)

17/8/2007 Friday
- Removed this check and lines from use_real_robot_SCAN since I can't see it doing anything else, no other programs or file refer to scan.width, this is instead called scan.theta probably
if ~isfield (scan,'width')
    warning('The global variable scan has not been set which specifies the width has not been set, now setting to 120deg either side');
    scan.width=120*pi/180;
end    
-Changed the check in organise_data.m so that it checked how many obsticles rather than the num of cols in array
FROM
try if size(ice_cream_bounds_NOSELF,2)>1
TO 
try if size(ice_cream_bounds_NOSELF,1)>1
- Added this check to organise_data.m because I was getting a divide by zero error since size(inbetweenpoint,1)==0
  %check that it is valid, this isn't a fix only a check so there are no error
    if size(inbetweenpoint,1)==0; keyboard; end
- Added this FIX to fix the above problem, also eventually removed check with keyboard
        %check that it is valid, this isn't a fix only a check so there are no divide by zero error
        if size(inbetweenpoint,1)<=1
            inbetweenpoint=[laser_pos(1)*ones([round((2*dist(i)/workspace.inc_size))+1,1])];
        end

-There is something seriousl;y fucked about the scan and move commands, there is no stopping anymore, it just won't do it


20/8/2007 Monday
- Added a try/catch keyboard statement combo every time explore() is called so that if the laser fucks up it dosen't completely stuff up the the state
- Need a way to make sure the laser is really plugged in (like ping it etc)
- Changed the robotcomms.ini file to speed up the laser coms
#baud=19200
baud=115200 


21/8/2007 Tuesday
- Added this check to movetonewQ so that we didn't wast time trying to go to a place which is the same except has some tiny rounding error
if length(find(Q-newQ>eps))==0; return;end
- Added 2 new variable into setupscanner so that the robot will not move the scanning into itself (only seems to happen when the 3rd joint is greater than 150'
scan.alpha_limited_condition & scan.alpha_limited
- Added this code to explorer. THIS MAKES IT SIGNIFICANTLY DIFFERENT, it will now try and only move beteen min and max alpha which depends upon the current pose.
It will then change the newQ to be 1/2 of alpha from where it is now then scan to the min or max depending upon which way the chosen view is

    qlimits=r.qlim;
    minimum_alpha=qlimits(5,1);
    if Q(3)>scan.alpha_limited_condition
        maximum_alpha=scan.alpha_limited;
    else 
        maximum_alpha=scan.alpha;
    end

    if scan.chosenview(3)>0
        newQ(5)=min(maximum_alpha,newQ(5)+scan.alpha/2)
        tilt_scan_range=minimum_alpha-newQ(5);
    else
        newQ(5)=max(maximum_alpha,newQ(5)-scan.alpha/2);
        tilt_scan_range=maximum_alpha-newQ(5);
    end
    movetonewQ(h,newQ*180/pi)
- Also changed the min qlim on this to only go to 90% of it since it dosne't want to go to the limit
minimum_alpha=qlimits(5,1)*0.9;
- Changed this if we are scanning in the negative direction
newQ(5)=max(minimum_alpha,newQ(5)-scan.alpha/2); since if possible we want to go from 50' either side but this may mean going to a too small andgl (minus) so we have ot limit it to the max angle of these two choicees

22/8/2007 Wednesday
- Put a pause before sending the stopabsjoint movement in the use_real_robot_MOVE since apparently it was clearing the buffer on the com port and since matlab sent the commands at the same time it wasn't properly 
releasing the semifore for the arm and hence it was getting stuck waiting for it.
- Added a try and catch to the organise_data in the bit where it works out the cubes that have been passed through, since there are too many errors in this section
- Added a removeselfsacnning call on the indexedobsticles as soon as they are created because the indexing seems to puting htem back inside the elipsoids of the arm making false obsticles
- Since in exGUI if there is a problem that is caught from explore.m it assumes it is still at the place it was at before we moved however it has already moved
- Added a test to see if we can use any of the other NBVs that have been worked out, if they will still give 90% of what was originally predicted then we will use it

23/8/2007 Thursday
- Made a new NBV algorithm, this one goes through all the joinbt poses and tries to find the one which shows the most new info then we rty and get a path to the top 10 of these 
- We are getting a DBZ warning in checkdirectpath since num_inc seems to be 0, sao added another check for debug of
if num_inc==0
	keyboard
end
- Added a new function call calculate_NBV_overallweight(cur_view)
and here the calculation of the weight of movement and the weight of additional info is weighed up. This should be proven somhow by working out the time to travel vs additional weighted info
- You really want the joints to be the final decidng factor then the new info is close, but you don't want it to be the primary decision maker, so we want it on average to be about 10% of the average aditional weight 
so it will make a difference but not the overall decision
- Playing round with the numbers for the weighting because before the new infor was about 1000 times more important than the movement of the joints, trying to make it so they both have an effect by watching the weighting graphs
- thought about :::%we can calculate the weighting each time, we want the average joint weight %to be 10% of the average additional weight
however this seemed too tedious we just want a guess is good enough
- Since we are still sometimes breaking the soft limits I put this formula check in 
(current_step_DEG(3)<-7/3*current_step_DEG(2)-130) based upon experimental results for moving and it failing
- removed the try and catch from organise_data becuase it dosen't do anything when there are only warnings
- A problem in NBV_beta means that it keeps on getting the same pose

24/8/2007 Friday
- Changed the formula for the weighted joint in calculate_NBV_overallweight.m
since before the angles that changed only a tiny bit had a massive influence overthe result, we want them to have some bearing but only on average 10% of the average of the other
bestviews(cur_view).jointmoveweight=...
        optimise.jointmoveweight*...
        exp(-1*...
            sum(...
                abs((Q-bestviews(cur_view).Q))...
                )...
            /length(Q)...
           );
-Also changed optimise.jointmoveweight so that the resulting influence was on average 10% of the overall
- Created a separate funciotn for ordering views since it is used in NBV and NBV_beta and maybe in exGUI after the first best view has been done
%% Order bestviews
% Using both their additional information and their joint movement from Q
% determine which is more desirable, give weightings to both joint movement
- Once a bestview has been done we set it to -2 so that it won't be used again
- Changed the formula for the additional weight since often all verws are very high and we don't want to make the final too small, so delete the average of these
- Now we deleted average_addinfo since when we have only a few (20) they are all similar in add info and hence the deleting the average makes it end tiny
    bestviews(cur_view).addinfoweight=...
        optimise.addinfoweight*...
        (bestviews(cur_view).addinfo);

function order_bestviews()
- look at this figure
figure showing diff between NBV and NBV beta, beta is better.fig
It shows how much better the NBV_beta is at find views because it is more exaustive so the best ones are way better than the other ones.
We should hopefully be able to show that the random poses that are gained (or points in space without thinking about where its looking and removing shodowing will be be much worst and also will take more poses and overall time to explore
keep in mind with this graph that the NBV_beta hasn't actually got paths to all of these but it should be able to find path on average 95%+ of the time so we can assume that it is the same.
- What you are trying to show by the improvment in beta is that most of the poses can be got to since we know the joint angles rather than where we know the point but not the angles, this makes it much harder to find all of these,
- Added the abs to this statement in organise_data
tempstarter=abs(ice_cream_bounds(:,1)-laser_pos(1))./(2*dist(:)/workspace.inc_size);
- Check to see if size(inbetweenpoint,1)<=1 and if it is it is the same as if we are at the same point (laser_pos and ice_cream_bounds)

-----UPGRADED TO MATLAB2007a---
- there are some diferences that are now syntax errors, like catch must have a line after it or a semi colon where it didn't previously need this
- Changed exGUI so it will go through 
while size(bestviews,2)>optimise.valid_max/4
so this is 5 times
- we were going past joint limits so added this
for J3=qlimit(3,1)+pi/180:(qlimit(3,2)-qlimit(3,1))/numNBVanglesteps:qlimit(3,2)-pi/180
for J1,2,3 so that they don't go to these extrememes

27/8/2007 Monday
- Found a big problem in nbv_volume where I was doing points=points*tr(1:3,1:3); when actually it looks much better to transform the base scan in this way 
points=points*tr(1:3,1:3)'; with the transform matrix inversed. THIC COULD EFFECT SIMULATION RESULTS WHERE THIS SEEMED TO WORK PROPERLY
Since in sim it uses this function doscan.m and does potentiallyknown=nbv_volume(tr); 
Adding a comment here to this effect
-Commented out this line in setupscanner since it seems that the points are all back to front
scan.basescan=-1*basic_scan_data;
-Making the nbv_volume scanner so that it points to the center of a scan 45' from normal and it scans through -alpha, this means that when transformed with tr=[1,0,0;0,1,0;0,0,1] (or the inverse) will be inverse always
- I had previously added an abs statement in organise_data when I was trying to work out the problem THIS HAS NOW BEEN REMOVED BECAUSE IT FUCKED UP THE inbetween code which needs to have steps which are both positive and negative depending upon which way it is stepping
tempstarter=(ice_cream_bounds(:,1)-laser_pos(1))./(2*dist(:)/workspace.inc_size);
- Removed this line from organise_data.m
workspace.indexedobsticles_home_point=[];
since it was reseting to empty the home_points which we are using to shadow, this should only be done in the setupworkspace.m file and not cleared anywhere else, it has to be able to grow
- In NBV_volume changed 2 separate statements to isempty rather than find length greater than 0
also with this statement we just find the first example of bottomof_t_var==0 and then if there are any we go through and change them all
if ~isempty(find(bottomof_t_var==0, 1))
- I added some cool shadowing plotting into NBV_volume but this is currently commented out, uncomment for when you want some examples of it working out the shadowing effect based upon the current scan data
- Changed the move joint absolution in use_real_robot_MOVE so that it has the more acurate checked for soft limits
        if (rob_h.JointState(2)<-60 || tempQ(6)<-60)
            if (rob_h.JointState(2)<-7/3*rob_h.JointState(3)-130 || tempQ(2)<-7/3*tempQ(3)-130)
Also added a keyboard command after this similar check in the drive robot along the steps part. It seems to be getting a fair way through and then failing due to future joint states but it looks ok
- Added this line into the check_path_for_col
%this is the formula for joints 2 and 3's soft motion limit
if ~isempty(find(all_steps(:,3)*180/pi<-7/3*all_steps(:,2)*180/pi-130,1))
    pathfound=0;
end
- In NBV_beta got rid of the simple joints check and changed to the check_path_for_col since it checks the soft motion function
%             if (J2<-60*pi/180 &&  J3<-5*pi/180) || 
            if ~check_path_for_col([J1,J2,J3,0,0,0])
- Since that (above) check happens earlier we have commented out the one below, it just wastes time without adding value
%                         valid=check_path_for_col(newQ);
also remove the if valid statement after this
- Changed the showunknownpnts=false; from it was comparing it as a boolean == when actually I wanted to set it
- Changed the inc_size to be 0.11 rather than 1/9
- since the "newestknowledge" was  simply everything from the newestscan wether it was new or not, I have changed it to be frmo the commented out line to the one underneath
% workspace.newestknownledge=points;
workspace.newestknownledge=setdiff(points,workspace.knowncoords,'rows');


28/8/2007 Tuesday
-Sometimes the laser doesn't work and needs to be physically powercycled.
- Changed the bellow commented out code to the new one
%     uiwait(msgbox('There is some problem with the laser, no data has been returned - you have control'));keyboard
    error('There is some problem with the laser, no data has been returned');
- There is a problem with organise data because with the in between points, it seems that sometimes probably due to a rounding error with the inbetween term
it doesn't generate the correct number of steps between start and finish, this needs to be fixed so it does

29/8/2007 Wednesday
- Changed the position of the newest knowledge variable being decalred since we are looking for the difference between what is already known and the new points and if we have already added points to what is already known
then of cource there will be no difference so we go 1 then 2
1) workspace.newestknownledge=setdiff(points,workspace.knowncoords,'rows');
2) workspace.knowncoords=unique([workspace.knowncoords;points],'rows');
- the shadowing is only using the closest planes and hence missing heaps so changing this to use the planes in implev3 space  FOR A TEST
%get INDEXed plane home points and INDEXed point inside imp level 2 area
% [nothing,planes_of_interest]=GetImpLevInfo(temp_plane_homepnts);
% [nothing,Implev2]=GetImpLevInfo(points);
%get INDEXed plane home points and INDEXed point inside imp level 3 area
[nothing,nothing,planes_of_interest]=GetImpLevInfo(temp_plane_homepnts);
[nothing,nothing,Implev3]=GetImpLevInfo(points);
%if any are the same then probably there is some obstruction by the planesso check this out
[obstructingPNTS,plane_index,point_index]=intersect(temp_plane_homepnts(planes_of_interest,:),...
                                                    points(Implev3,:),'rows');
- Added a new option in remove_self_scanning so you can pass in a newQ and remove the points from around that pose
function points=remove_self_scanning(points,newQ)
- Can now pass in the newQ into
function points=nbv_volume(tr,newQ)
- Also added toi use newQ this which removes self scanning
%if we pass in the newQ then we can remove self scanning points
if exist('newQ','var')
    points=remove_self_scanning(points,newQ);
end
- Changed tilt speed in use_real_robot to 
robscan_h.TiltSpeed=10; which is 10% of the currently generally used 50%
- Changed the use_real_robot_move speed to be 60% and also changed the pause to pause(0.2); in between steps
- Changed the workspace min and max and the level 2 since level 2 used to be more than min and max
workspace.min=[-1.6,-1.6,-workspace.inc_size/2];
workspace.max=[1.6,1.6,2.5];
%level 2 is where the robot can blast but not move
workspace.impLev(2).x=[-1.4,1.5];
workspace.impLev(2).y=[-1.4,1.5];
workspace.impLev(2).z=[0,2.1];
- Tried adding a random check for NBV_beta to miss some and speed it up however the more exhastive search found better results but took 8 times as long
but the improvement was about 1.5 times as much
%we are going to compare this to a rand num, if larger we will test the
%point to see additional knowledge, else skip it
end_value_damper_weight=0.5*size(indexed_knowncoords,1)/size(workspace.lev1unknown,1);
- Added the remove self scanning from the NBV once a pose has been found
- Removed the commented out graphing stuff from NBV after a pose has been found, if you want to see it where it was go to a previous version
% %plot the possibilities, these will be removed at the next iter
% temp1=plot3(bestviews(cur_view).scanorigin(1),...
%       bestviews(cur_view).scanorigin(2),...
%       bestviews(cur_view).scanorigin(3),'r*');
%   hold on;
% temp2=plot3(bestviews(cur_view).chosenview(1),bestviews(cur_view).chosenview(2),bestviews(cur_view).chosenview(3),'b*');
% hold on;                    
% temp3=plot3(bestviews(cur_view).expectedaddinfo(:,1),bestviews(cur_view).expectedaddinfo(:,2),bestviews(cur_view).expectedaddinfo(:,3),'g.');                    
% plotdenso(r,bestviews(cur_view).Q);
% delete(temp1);delete(temp2);delete(temp3);

- Delete thecommented out display message at the end of NBV look at versions prior to this date to find usage of this
% display('The best views and their info are:');
% if valid_count>0
%     for cur_view=1:valid_count
%         display(strcat('Rank:',num2str(cur_view),'. Details: from (',num2str(bestviews(cur_view).scanorigin),...
%             ') and pose of: ',num2str(bestviews(cur_view).chosenview),' gives:',num2str(bestviews(cur_view).addinfo),' units additional info'))
%     end
% end
- NBV tr estimations are around the wrong way
- Since NBV was looking at completely wrong way round now that we have changed the base_scan have added this code to make it be the correct way around
and to rotate 45' so that it will point at the middle of the desired scan
    if tr(1,1)<0
        points=[-1*points(:,1),points(:,2:3)];
    end
    %you could do for tr(2,2) but it would fip it and it issymetric around z
    %axis so the y doesn't effect it
    if tr(3,3)<0
        points=[points(:,1:2),-1*points(:,3)];
    end
    %now rotate around the y axis in direction clockwise if sign product is >0 or couterclockwise if sign product is <0
    temp_tr=makehgtform('yrotate',-sign(tr(1,1)*tr(3,3)) * pi/4);
    points=points*temp_tr(1:3,1:3);
-Updated NBV.m since the new found pose was not updating the correct best view and also the actual tr was different from the predicted one
                %work out the actual direction
                tr=fkine(r,bestviews(cur_view).Q);
                bestviews(valid_count).tr=tr;
                %update the expected info removing selfscanning points and with new tr
                bestviews(cur_view).expectedaddinfo=setdiff(nbv_volume(tr,newQ), workspace.knowncoords,'rows');
                %update the weighted addinfo give new expectedaddinfo
                bestviews(cur_view).addinfo=getweighted_addinfo(bestviews(cur_view).expectedaddinfo)/unknownweight;               

30/8/2007 Thursday
- Deleted some unused variables in exGUI.m
- Deleted heaps of commented out stuff from the GO pushbutton
- The reason why the addinfo weight was so far off in the NBV.m file was because I was dividing by the unknownweight twice. so deleted this line which is what I used to use
%% Calculate current weight of unknown areas
for cur_view=1:valid_count
    bestviews(cur_view).addinfo=(bestviews(cur_view).addinfo/unknownweight);
end

31/8/2007 Friday
- Found that it is about 20% quicker not to use find but just use the logical indexes like in the following code taken from nbv_volume
        points1=points(find(sqrt((intersectionPNTs(:,1)-temp_plane_homepnts(planes_of_interest(i),1)).^2+...
                                (intersectionPNTs(:,2)-temp_plane_homepnts(planes_of_interest(i),2)).^2+...
                                (intersectionPNTs(:,3)-temp_plane_homepnts(planes_of_interest(i),3)).^2)>mew |...
                            points_sign==scan_origin_sign),...
                       :);                   
        points2=points((sqrt((intersectionPNTs(:,1)-temp_plane_homepnts(planes_of_interest(i),1)).^2+...
                                (intersectionPNTs(:,2)-temp_plane_homepnts(planes_of_interest(i),2)).^2+...
                                (intersectionPNTs(:,3)-temp_plane_homepnts(planes_of_interest(i),3)).^2)>mew |...
                            points_sign==scan_origin_sign),...
                       :);
- However these have been deleted because it was found that this could be done quicker again by only doing the dist calcumlation on the point on the different side of the plane
                   trueindex=points_sign==scan_origin_sign;
                   falseindex=points_sign~=scan_origin_sign;
                   
       points2=[points(trueindex,:);
           points((sqrt((intersectionPNTs(falseindex,1)-temp_plane_homepnts(planes_of_interest(i),1)).^2+...
                        (intersectionPNTs(falseindex,2)-temp_plane_homepnts(planes_of_interest(i),2)).^2+...
                        (intersectionPNTs(falseindex,3)-temp_plane_homepnts(planes_of_interest(i),3)).^2)>mew),:)];                                      
- in remove_self_scanning removed the find and just use the logical index, so from the TOP statement we now use the bottom one
    pointstemp=points(find(((translated_points(:,1)-densoobj(i+1).ellipse.center(1)).^2)/densoobj(i+1).ellipse.params(1)^2+...
                       ((translated_points(:,2)-densoobj(i+1).ellipse.center(2)).^2)/densoobj(i+1).ellipse.params(2)^2+...
                       ((translated_points(:,3)-densoobj(i+1).ellipse.center(3)).^2)/densoobj(i+1).ellipse.params(3)^2>3),:);
    
   points=points((((translated_points(:,1)-densoobj(i+1).ellipse.center(1)).^2)/densoobj(i+1).ellipse.params(1)^2+...
                       ((translated_points(:,2)-densoobj(i+1).ellipse.center(2)).^2)/densoobj(i+1).ellipse.params(2)^2+...
                       ((translated_points(:,3)-densoobj(i+1).ellipse.center(3)).^2)/densoobj(i+1).ellipse.params(3)^2>3),:);                   
- Did the same for GetImpLevInfo
% level3=find(...
%     vals(:,1)>=workspace.impLev(3).x(1)&vals(:,1)<=workspace.impLev(3).x(2)&...
%     vals(:,2)>=workspace.impLev(3).y(1)&vals(:,2)<=workspace.impLev(3).y(2)&...
%     vals(:,3)>=workspace.impLev(3).z(1)&vals(:,3)<=workspace.impLev(3).z(2));
% %if there are some points in level 3, find out which ones are nside level2
% if size(level3,2)>0
%     level2=level3(find(...
%         vals(level3,1)>=workspace.impLev(2).x(1)&vals(level3,1)<=workspace.impLev(2).x(2)&...
%         vals(level3,2)>=workspace.impLev(2).y(1)&vals(level3,2)<=workspace.impLev(2).y(2)&...
%         vals(level3,3)>=workspace.impLev(2).z(1)&vals(level3,3)<=workspace.impLev(2).z(2)));
%     %if there are some points in level 2, find out which ones are nside level1
%     if size(level2,2)>0
%         level1=level2(find(...
%             vals(level2,1)>=workspace.impLev(1).x(1)&vals(level2,1)<=workspace.impLev(1).x(2)&...
%             vals(level2,2)>=workspace.impLev(1).y(1)&vals(level2,2)<=workspace.impLev(1).y(2)&...
%             vals(level2,3)>=workspace.impLev(1).z(1)&vals(level2,3)<=workspace.impLev(1).z(2)&...
%             sqrt((vals(level2,1)-robot_maxreach.firstlinkpos(1)).^2+...
%                  (vals(level2,2)-robot_maxreach.firstlinkpos(2)).^2+...
%                  (vals(level2,3)-robot_maxreach.firstlinkpos(3)).^2)<robot_maxreach.val));
%     else
%         level1=[];
%     end
% end  
level3=find(...
    vals(:,1)>=workspace.impLev(3).x(1)&vals(:,1)<=workspace.impLev(3).x(2)&...
    vals(:,2)>=workspace.impLev(3).y(1)&vals(:,2)<=workspace.impLev(3).y(2)&...
    vals(:,3)>=workspace.impLev(3).z(1)&vals(:,3)<=workspace.impLev(3).z(2));
%if there are some points in level 3, find out which ones are nside level2
if size(level3,2)>0
    level2=level3((...
        vals(level3,1)>=workspace.impLev(2).x(1)&vals(level3,1)<=workspace.impLev(2).x(2)&...
        vals(level3,2)>=workspace.impLev(2).y(1)&vals(level3,2)<=workspace.impLev(2).y(2)&...
        vals(level3,3)>=workspace.impLev(2).z(1)&vals(level3,3)<=workspace.impLev(2).z(2)));
    %if there are some points in level 2, find out which ones are nside level1
    if size(level2,2)>0
        level1=level2((...
            vals(level2,1)>=workspace.impLev(1).x(1)&vals(level2,1)<=workspace.impLev(1).x(2)&...
            vals(level2,2)>=workspace.impLev(1).y(1)&vals(level2,2)<=workspace.impLev(1).y(2)&...
            vals(level2,3)>=workspace.impLev(1).z(1)&vals(level2,3)<=workspace.impLev(1).z(2)&...
            sqrt((vals(level2,1)-robot_maxreach.firstlinkpos(1)).^2+...
                 (vals(level2,2)-robot_maxreach.firstlinkpos(2)).^2+...
                 (vals(level2,3)-robot_maxreach.firstlinkpos(3)).^2)<robot_maxreach.val));
    else
        level1=[];
    end
end   

- Changed doscan for the simulated case so that the knewest knowledge was the setdiff between potential and actually known
workspace.newestknownledge=setdiff(potentiallyknown,workspace.knowncoords,'rows');
- Removed more finds from nbv_volume, the part where it gets point inside min and max but outside robot area
- In oorgaise data removed the "find" from this command
	ice_cream_bounds=ice_cream_bounds((RangeData>0),:);
and this one
    ice_cream_bounds=ice_cream_bounds((ice_cream_bounds(:,1)>=workspace.min(1) & ice_cream_bounds(:,1)<=workspace.max(1) &...
                                           ice_cream_bounds(:,2)>=workspace.min(2) & ice_cream_bounds(:,2)<=workspace.max(2) &...
                                           ice_cream_bounds(:,3)>=workspace.min(3) & ice_cream_bounds(:,3)<=workspace.max(3)),:);
- Changed statements in pathplanner from length to isempty
if isempty(find(newQ~=Q, 1))
and
if ~isempty(find(newQ'<qlimits(:,1), 1)) || ~isempty(find(newQ'>qlimits(:,2), 1))
and
if ~isempty(find(all_steps(end,:)-endQ~=0)>0)
and
if ~isempty(find(all_steps(end,:)-endQ~=0)>0);all_steps=[all_steps;endQ];end
and
while ~isempty(find(result_row==0, 1))
-In streamOnto_mine_manystarts.m changed the isempty
if ~isempty(find(q(1:3)~=0, 1))
and
if (dist>optimise.minAccepDis) || (~isempty(find(targetdist>optimise.maxtargetdis, 1))) 

-In surface_making_simple
            norm=eigenvectors(:,(eigenvalues==min2max_eig(1)));                
and
	    plane(plane_num).points=distance_between.closest_indices((dis_to_plane<mew));
Also removed all the finds from this 
for i=1:max_values(1)
    point_in_cube((in_which_cube(:,1)==i),1)=i;
end
for j=1:max_values(2)
    point_in_cube((in_which_cube(:,2)==j),2)=j;
end
for k=1:max_values(3)                    
    point_in_cube((in_which_cube(:,3)==k),3)=k;
end

- Changed the check in Check_FF so that it will only find the first instance of a point inside the elipse then stop
    if ~isempty(find(((translated_points(:,1)-ellipse_vals.center(1)).^2)/ellipse_vals.params(1)^2+...
            ((translated_points(:,2)-ellipse_vals.center(2)).^2)/ellipse_vals.params(2)^2+...
            ((translated_points(:,3)-ellipse_vals.center(3)).^2)/ellipse_vals.params(3)^2<=1,1))
- Changed remove_self_scanning value to 2.5 instead of 3
   points=points((((translated_points(:,1)-densoobj(i+1).ellipse.center(1)).^2)/densoobj(i+1).ellipse.params(1)^2+...
                  ((translated_points(:,2)-densoobj(i+1).ellipse.center(2)).^2)/densoobj(i+1).ellipse.params(2)^2+...
                  ((translated_points(:,3)-densoobj(i+1).ellipse.center(3)).^2)/densoobj(i+1).ellipse.params(3)^2>2.5),:);
- in setupworkspace for a quick test Changed 
workspace.inc_size=0.09;
workspace.mew=0.30;
- There were problems in this part of organise_data the formula was wrong
tempMaxAngle=acos(...
                  sqrt(...
                       1-(...
                          (workspace.inc_size/numpntsInCube)/(sqrt(2)*maxdist)...%used to be scan.size %%Now it will be AT LEAST scan size but maybe bigger
                          )^2 ...
                       )...
                  );
- then there are also problems with the next part since we have been using scan.alpha even though this isn't the most recent scan alpha parameter it is fixed
now get the last scan passed in in radians and use this so we get a better ratioofscans to use
ratioOfScansToUse=abs(...
                    floor(...
                        tempMaxAngle/...  
                                     ((scan.theta*2) / ...
                                      (size(PointData,2))...
                                     )...
                         )...
                     *...
                    floor(...
                        tempMaxAngle/...  
                                     ((abs(tilt_scan_range)*2) / ...
                                      (size(PointData,1))...
                                     )...
                         )...
                       );
- Also made it quicker by getting rid of the find now only using logicals (so it is never empty as such) and also checkingas is putting a check next to cubes which are
floored to being inbetween and rounded to being in between, also using int8 instead of doubles
    markedcubes=[markedcubes;int8(cubes_checked((cubes_checked(:,1)>=space_min_and_max(1) &...
                                                 cubes_checked(:,2)>=space_min_and_max(2) &...
                                                 cubes_checked(:,3)>=space_min_and_max(3) &...
                                                 cubes_checked(:,1)<=space_min_and_max(4) &...
                                                 cubes_checked(:,2)<=space_min_and_max(5) &...
                                                 cubes_checked(:,3)<=space_min_and_max(6)),:))];        
- Removed the drawing on the GUI on the calculating path writing
%set(handles.dialog_text,'String','Calculating Path......');drawnow;        
- Changed the weighting of the addinfo so that it has more sway over the averall weight, it used to be 5 
optimise.addinfoweight=20;  


3/9/2007 Monday
- Commented out the section in explore where you could select specific places to explore from. there may be a need for this eventually as a GUI but I haven't used it yet



_______Exploration Test log______
- Always starting from the intial point (move separately) before starting test
- Using 3 initial default poses and ccounting these in the steps

nbv_beta (current_test_case 2)
-Test No: 1
Step Counter 1 (zero state), 2,3,4 defaults 5-10 nbv_beta exploration
while size(bestviews,2)>optimise.valid_max*3/4
valid_max=20;
Info weighting = 20;

nbv_beta (current_test_case 2)
-Test No: 2
Step Counter 1 (zero state), 2,3,4 defaults 5-10 nbv_beta exploration
while size(bestviews,2)>optimise.valid_max*3/4
valid_max=10;
Info weighting = 20;
Comments: There was an error getting the data back on the third scan from defaults

nbv_beta (current_test_case 2)
-Test No: 3
Step Counter 1 (zero state), 2,3,4 defaults 5-10 nbv_beta exploration
while size(bestviews,2)>optimise.valid_max*3/4
valid_max=10;
Info weighting = 50;
I put the timeout on the laser too small so it was waiting for user input a great deal of the time




4/9/2007 Tuesday
- There was a problem with the organisation of the data, we were removing rangedata==0 but the matrix we were searching through was the n*m matrix and the results of this find where not
equivelant to the ice_cream_bounds hence we were removing points that should be there while leaving points that should not. This probably caused the problems later on with the inbetween since we had points
which were at zero and hence had no in between points. This has been changed to construct a similar shaped matrix (except it is range so only single value not x,y,z) to the ice_cream_bound one and then search on this
  rangedata_singlemat=zeros([size(RangeData,1)*size(RangeData,2),1]);
    for i=1:size(RangeData,1);
    rangedata_singlemat((i-1)*size(RangeData,2)+1 : i*size(RangeData,2) , :)=...
        RangeData(i,:)';                  
    end
    ice_cream_bounds=ice_cream_bounds((rangedata_singlemat>0),:);

- All tests are not valid because of the above errors, what we were estimating we would know and what we actually found out were so different because of this deletion of data that it is not valid
- Removed the continue statement out the exGUI if the pose is not valid, since this continue will create a neverending loop
- Trying something different in nbv_volume. Trying to take out the knownpoints and then taken out the indexed obsticles after doing the plane calculations
%keep only unique points               
% points=unique(points,'rows');
points=setdiff(points,workspace.knowncoords,'rows')
- At the end I have this 
%then finally remove the known obstacles from the points to be returned
points=setdiff(points,workspace.indexedobsticles,'rows');
- Have to look at where nbv_volume was called and make sure you are not redoing this
- Problem with the ray traceing is where there is no end point and hence no ray to trac, so the point behind the robot are hard to see because there is no background to see them, we need a distance reading so we can get a messurements
- Problem with the nbv_volume where I was doing the plane shadowing and using a different index (points on other side of plane only) inside a matrix which is all points. This has been changed to this
        falseindex=points_sign~=scan_origin_sign;
        points_on_oposite_side=points(falseindex,:);
        
        points=[points(points_sign==scan_origin_sign,:);...
               points_on_oposite_side((sqrt((intersectionPNTs(falseindex,1)-temp_plane_homepnts(planes_of_interest(i),1)).^2+...
                            (intersectionPNTs(falseindex,2)-temp_plane_homepnts(planes_of_interest(i),2)).^2+...
                            (intersectionPNTs(falseindex,3)-temp_plane_homepnts(planes_of_interest(i),3)).^2)>mew),:)];
- The check_path_for_col was using all the points in workspace.indexedobsticles which are all obsticles, this should be passed in otherwise it 
needs to be calculated everytime
if nargin<2
    global workspace
    obsticle_points=workspace.indexedobsticles(GetImpLevInfo(workspace.indexedobsticles),:);
end
- Added the possiblitiy to pass in this variable into check_path_for_col 
- Now calculating the obsticles earlier in nbv_beta so we can check arm for collisions
- Added to path planner the obstacle points
%these are the obstacle point within the arm range that are present during this iteration of path planning
obsticle_points=workspace.indexedobsticles(GetImpLevInfo(workspace.indexedobsticles),:);
- Also inside the pathplanner.m file there is the most time consuming function checkdirectpath so the obstacle points also had to be passed to that
function [pathfound,all_steps]=checkdirectpath(startQ,endQ,max_angle_for123,check_arm_perms,obsticle_points)
- Made the result in check_FF to start as = 1 so we don't have to have 2 else statements in there
- Currently we are not using the fact that we have a path to all the results and infact we are calculating a new path everytime anyway, therefore there
is no need to get a path to all of them (UNLESS YOU ARE GOING TO USE THE PATH TO WEIGHT THE MOVEMENT)
- Put these around this way so unique is first, which may make this slightly quicker
%keep only unique points               
points=unique(points,'rows');

%if we pass in the newQ then we can remove self scanning points
if exist('newQ','var')
    points=remove_self_scanning(points,newQ);
end

- In nbv_volume the calculation of the intersecting points was now incorrect because of the change due to the index problem, put this code after points_on_oposite_side is decalared
        intersectionPNTs=(points_on_oposite_side+[t_var.*r_var(:,1),t_var.*r_var(:,2),t_var.*r_var(:,3)]);

_______Exploration Test log______

nbv_beta (current_test_case 2)
-Test No: 4
- Graph file: realrobot_exploration results_13-nbv_beta_test4.fig
Step Counter 1 (zero state), 2,3,4 defaults 5-10 nbv_beta exploration
while size(bestviews,2)>optimise.valid_max*3/4
valid_max=10;
Info weighting = 50;
I was plotting the set difference to see that it matched so the time is slower, also plotting the robot (not animate move) 

nbv_beta (current_test_case 2)
-Test No: 5
- Graph file: realrobot_exploration results_14-nbv_beta_test5.fig
Step Counter 1 (zero state), 2,3,4 defaults 5-10 nbv_beta exploration
while size(bestviews,2)>optimise.valid_max*3/4
valid_max=10;
Info weighting = 50;
There were about 4 times when it returned no data but now we have the checks it is easy to simply say 'continue' and have another go at it
These results were GOOD, the best we have gathered so far in this environment
Saved datafile of workspace to Testcase5_data_nbv_beta.mat

NBV (current_test_case 3)
-Test No: 6
- Graph file: realrobot_exploration results_15-nbv_beta_test6.fig
Step Counter 1 (zero state), 2,3,4 defaults 5-10 nbv_beta exploration
while size(bestviews,2)>optimise.valid_max*3/4
valid_max=10;
Info weighting = 50;
There were several time when it returned no data but now we have the checks it is easy to simply say 'continue' and have another go at it
These results were GOOD, the best we have gathered so far in this environment
Saved datafile of workspace to Testcase5_data_nbv_beta.mat

NBV (current_test_case 3)
-Test No: 7
- Graph file: realrobot_exploration results_16-nbv_beta_test7.fig
Step Counter 1 (zero state), 2,3,4 defaults 5-10 nbv_beta exploration
while size(bestviews,2)>optimise.valid_max*3/4
valid_max=10;
Info weighting = 50;
Towards the end it couldn't find any valid places to go to probably the last 3 iterations of the NBV didn't work. The reason was it was trying to find more than 3/4 of the valid max otherwise the 
while statement would not be true. This has since been corrected so as long as there are 2 it will get through these
This could be used to proove that this method finds it hard to find a suolution without an exhastive search and the last 3 limited searches were took about 2 minutes each



5/9/2007 Wednesday

- There was actually a problem calculating the r_var in all previous versions it used ot do this 1-1,2-2,2-2 
r_var=[points(:,1)-scan.origin(1),points(:,2)-scan.origin(2),points(:,2)-scan.origin(2)];
rather than 1-1,2-2,3-3
 r_var=[points_on_oposite_side(:,1)-scan.origin(1),...
               points_on_oposite_side(:,2)-scan.origin(2),...
               points_on_oposite_side(:,3)-scan.origin(3)];
- The t variable also appeared wrong as it was -ax -by-cz-d when it should be +d, so changed to this
        t_var=( -(...
                  plane_equ(i,1)*points_on_oposite_side(:,1)+...
                  plane_equ(i,2)*points_on_oposite_side(:,2)+...
                  plane_equ(i,3)*points_on_oposite_side(:,3)...
                  )+ plane_equ(i,4)...
                )./...
                bottomof_t_var;  
- Removed this calculation because it was not worthwile, all points are inside level3
% [nothing,nothing,Implev3]=GetImpLevInfo(points);

- Also removed the finding planes inside level3 since this is all of them
- Changed the use_real_robot_SCAN so that there is a section for isempty(PointData) and it will wait before releasing the arm since it has started moving
elseif isempty(PointData)
        sprintf('%s','Waiting for laser to complete before retrying');            
        while get(robscan_h,'Completed')==0
            pause(0.5);sprintf('%s','.');
        end
        release_scanner(robscan_h);
- In nbv_volument there was ANOTHER mistake this time with the sign calculation, I was using scan.origin(1) for all of them rather than 1,2,3, this has since been fixed
        scan_origin_sign=(plane_equ(i,1)*scan.origin(1)+...
                          plane_equ(i,2)*scan.origin(2)+...
                          plane_equ(i,3)*scan.origin(3)+...
                          plane_equ(i,4)>0);
- The mathod was wrong when calculating the t_var, changed fmo the commentted out section to the next section
%         t_var=( -(...
%                   plane_equ(i,1)*points_on_oposite_side(:,1)+...
%                   plane_equ(i,2)*points_on_oposite_side(:,2)+...
%                   plane_equ(i,3)*points_on_oposite_side(:,3)...
%                   )+ plane_equ(i,4)...
%                 )./...
%                 bottomof_t_var;                               
        t_var=( -(...
                  plane_equ(i,1)*scan.origin(1)+...
                  plane_equ(i,2)*scan.origin(2)+...
                  plane_equ(i,3)*scan.origin(3)...
                  )+ plane_equ(i,4)...
                )./...
                bottomof_t_var;   
- Instead of filtering out some of the planes I am now putting them all in, this way I make sure that even where the home point isn't part of the point set that plane can still have an effect
- In nbv_volume I used to be constantly using scan.origin rather than the actual supposed scan origin as decided by the tr. so now I am using current_scan_origin
- So I could get better plane plots I changed plot_planes to 50 so more samples
[base_x,base_y,base_z]=sphere(100);
- The problem ended up being because I was using r_val for 2 different things, one to calculate the t_val and one to calculate the intersection however
the formula that I had worked out was to use P2-P1 but when calculating the t_val I was essentailly using P1-P2 and hence the r_val was incorrect
will write up more specifically about this when explaining the shadowing effect
- Now I try and get to the final place before doing explore, it there is no path ie this function returns not 1
movetonewQ(h,bestviews(1).Q*180/pi)
then we have to go to the next best view

________TEst results__________
nbv_beta (current_test_case 2) 
with lots of obstacles
-Test No: 8
- Graph file: realrobot_exploration results_17-nbv_beta_test8.fig
Step Counter 1 (zero state), 2,3,4 defaults 5-10 nbv_beta exploration
max_bestviews_togothrough=optimise.valid_max*1/4;
while current_bestview<=max_bestviews_togothrough && size(bestviews,2)>=1
valid_max=12; (so will do top 3)
Info weighting = 50;
NOtes: there were lots of abstacles and we had no collisions and no near collisions but a fe things to say were, it often got no returns
from places longer than max range and hence kept trying to look at these places, it also was unable to find a path in about 1/4 of the cases although further path planning testing should be done

Thursday
- The stepping was inccorrect for nbv_beta since either end had 1 deg taken off it then the amount of steps was always actually one less than what was requested. Chnaged so this is at start (not we are taking 5deg of either side)
qlimit(1:3,1)=qlimit(1:3,1)+5*pi/180;
qlimit(1:3,2)=qlimit(1:3,2)-5*pi/180;
and then this is the stepper
for J1=qlimit(1,1):(qlimit(1,2)-qlimit(1,1))/numNBVanglesteps:qlimit(1,2)
    for J2=qlimit(2,1):(qlimit(2,2)-qlimit(2,1))/numNBVanglesteps:qlimit(2,2)
        for J3=qlimit(3,1):(qlimit(3,2)-qlimit(3,1))/numNBVanglesteps:qlimit(3,2)
- Need to have something so that you don't do a nbv_beta calculation for poses which have already been done
- Added this check in exGUI so that we don't get an error that there is no temp_bestviews var
if size(bestviews,2)>1  
- Added a check in nbv_beta so that scans that have already been done or failed will not be repeated
if size(intersect(scan.done_bestviews,newQ,'rows'),1)==0
- Changed the logic in nbv_beta for the check_path_for_col so that I don't have to use continue but can simply check and go into statement if destination is possible
if check_path_for_col([J1,J2,J3,0,0,0],obsticle_points)

- Added this additional check in nbv_beta si to check if the arm is on collisions due to the current J4 and J5
- Changed the variable to done_bestviews_orfailed so taht we can hold both places we have been and ones we have tried to get to before and failed 
THIS MAY NOT BE A GOOD IDEA BECAUSE WHAT MAY NOT BE POSSIBLE FROM THE CURRENT POSSITION MAY EVENTUALLY BE POSSIBLE KEEP A CHEK OF THIS VARIABLE
    else %it failed so note down that we can't get to this destination
        scan.done_bestviews_orfailed=[scan.done_bestviews_orfailed;bestviews(current_view).Q];
- in use_real_robot_SCAN cahnged the disaplying to display('.'); rather tahn sprintf which dosen't seel to do anything
- Changed the check to see if we have done/tried this pose before to 
~(newQ(1)==scan.done_bestviews_orfailed(:,1)&...
                            newQ(2)==scan.done_bestviews_orfailed(:,2)&...
                            newQ(3)==scan.done_bestviews_orfailed(:,3)&....
                            newQ(4)==scan.done_bestviews_orfailed(:,4)&...
                            newQ(5)==scan.done_bestviews_orfailed(:,5))
- It is noted that if you put the random damper in you may limit the number of poses we try and get a NBV from but may end up with no places that can be got to and hence
difficulty in getting through the ath planning step
- Added this if this fails in NBV_beta check_path_for_col([J1,J2,J3,0,0,0],obsticle_points)
else
 %add this to the list of places we can't get to
 scan.done_bestviews_orfailed=[scan.done_bestviews_orfailed;[J1,J2,J3,inf,inf,inf]];
- Then add a check before this to see if we have tried to get to this J1,J2,J3 combo before and failed and if so then don't bother
NOTE THAT joints 4, 5 and 6 are at inf so we know it was from a check_col check done in NBV_beta. This using of INF may cause problems later on but these entrie should simply be ignored
if ~(J1==scan.done_bestviews_orfailed(:,1)&...
                 J2==scan.done_bestviews_orfailed(:,2)&...
                 J3==scan.done_bestviews_orfailed(:,3)&...
                 inf==scan.done_bestviews_orfailed(:,4)&...
                 inf==scan.done_bestviews_orfailed(:,5)&...
                 inf==scan.done_bestviews_orfailed(:,6))
- in nbv_beta it was getting a list of all the indexed known points but it wasn't rounding them when dividing by workspace.inc size so lots of actual possibilities were being discarded
- Adde dthis to organise_data since it seems that known points was holding where the obstacles were as well but we were using this to check if the current point was valid but you can't do that if there is an obstacle there
Made this to be after indexobstacle variable was filled and changed it so that it got the set difference between the (unique points (known and points) ) and hte indexedobstacles
%fill in the newest knowledge about points, the newestscan knowledge is

%what is now known compared to what was known about freespace and obstacles before
workspace.newestknownledge=setdiff(points,[workspace.knowncoords;workspace.indexedobsticles],'rows');
workspace.knowncoords=unique([workspace.knowncoords;points],'rows');
%overall point is what is known that is not an obstacle
workspace.knowncoords=setdiff(unique([workspace.knowncoords;points],'rows'),workspace.indexedobsticles,'rows');

- To make sure that the known_coords where being checked properly in NBV_beta I had this code as the else to if the tr(1:3,4) is not in known space, it is because it is inside the robots space, but this rarely happens
                                else
                                    if (indexedpnt(1)<workspace.robotsize(1,1) && indexedpnt(1)>workspace.robotsize(1,2)&&...
                                        indexedpnt(2)<workspace.robotsize(2,1) && indexedpnt(1)>workspace.robotsize(2,2)&&...
                                        indexedpnt(3)<workspace.robotsize(3,1) && indexedpnt(1)>workspace.robotsize(3,2))                                           
                                        try delete(a);end;figure(2);hold on;a=plot3(indexedpnt(1),indexedpnt(2),indexedpnt(3),'b*');keyboard;
                                    end

-I've added back in the random dampner check since now we have too many points beinhg checked for NBV
- We are aiming for the NBV_beta to take about 3-5 sec per pose which means we can get 5 poses in 25 seconds consistently that would be good
- Put a new optimisation variable in
optimise.nbv_beta_dampner=0.75;
%this will be multiplied by the percentage of the points that we know in
%space around the robot. It we know nothing then most possibliities will
%pass through but there is less change that the robot arm will be allowed
%at that spot. As we know more and the tr(1:3,4) of the arm in nbv_beta
%results in safe places this dampner will stop all possibilites being
%explored and only some will be looked at (still random)
optimise.nbv_beta_dampner=0.7;
- now that I have a function to look after all the moving I took this out of the simulation version of explore.m
    if useNBV && isempty(find(Q~=bestviews(selection).all_steps(end,:), 1))
        if get(h.animate_move_checkbox,'Value')
            demopath(bestviews(selection).all_steps);    
        end
        plotdenso(r, newQ, guiglobal.checkFF, guiglobal.plot_ellipse);
        Q=newQ;
    else
        movetonewQ(h,newQ*180/pi);
    end           
- NOte the simulation may not be able to see everything unless we give its scanner a greater range, although it got close 39714/39739

________TEst results__________
nbv_beta (current_test_case 2) 
with lots of obstacles
-Test No: 9
- Graph file: realrobot_exploration results_18-nbv_beta_test9.fig
Step Counter 1 (zero state), 2,3,4 defaults 5-10 nbv_beta exploration
max_bestviews_togothrough=optimise.valid_max*1/4;
while current_bestview<=max_bestviews_togothrough && size(bestviews,2)>=1
valid_max=20; (so will do top 5)
Info weighting = 50;
Some paths cant be reaached, lots of cases of no data returned

10/9/2007 Monday
- In calknownweight it used to use the length function however if the matrix 3*m has m<3 then the result will be incorrect
changed from top one to bottom one
% knownweight=(length(level1_kn)*workspace.dotweight(1)+...
%              length(level2_kn)*workspace.dotweight(2)+...
%              length(level3_kn)*workspace.dotweight(3));
knownweight=(size(level1_kn,1)*workspace.dotweight(1)+...
             size(level2_kn,2)*workspace.dotweight(2)+...
             size(level3_kn,3)*workspace.dotweight(3));
- In calunknownweight did the same as above with the length changed to size,1 also added in the subtraction of the indexedobstacles since now we are 
defining the environement as the sum of unknown, known and obstacles
% unknownweight=((length(level1_un)-length(level1_kn))*workspace.dotweight(1)+...
%                (length(level2_un)-length(level2_kn))*workspace.dotweight(2)+...
%                (length(level3_un)-length(level3_kn))*workspace.dotweight(3));
unknownweight=(size(level1_un,1)-size(level1_kn,1)-size(level1_ob,1))*workspace.dotweight(1)+...
              (size(level2_un,1)-size(level2_kn,1)-size(level2_ob,1))*workspace.dotweight(2)+...
              (size(level3_un,1)-size(level3_kn,1)-size(level3_ob,1))*workspace.dotweight(3);
- Commented out the displaying of last angle = 0 in explore function
%     display('final angle has been change to 0 so we can get the largest scan')
- deleted all the stuff where you can select the point to scan from in explore, previouis versions wil have this

11/9/2007 Tuesday
- Changed in explore so that we do an fkine and make this equal to tr rather than intiialpoint and then straight away set the scan.origin
  tr=fkine(r,Q);
  scan.origin=[tr(1,4),tr(2,4),tr(3,4)];
- Turned these round the oposite way, it used to scan first then do the move to newQ, but since the scan was from newQ it should make no difference
    movetonewQ(h,newQ*180/pi);
    doscan(newQ);
- Deleted te commented out section of explore where we used to set the angle to scan from
%     if scan.chosenview(3)>0 
%         tilt_scan_range=round(-(Q(5)-scan.alpha)*180/pi);
%     else
%         tilt_scan_range=round(-(Q(5)+scan.alpha)*180/pi);
%     end
% uiwait(msgbox('Not inputing the -80 here anymore, using the scan.alpha and range-CAREFULL'));
%         % Doing a scan
%         display('putting -80 here');        
%         if Q(5)>-20
%             tilt_scan_range=-80;
%         else
%             tilt_scan_range=80;
%         end
- Delete the comented out plotting work at the end of explore which shows the new points
%tempp stuff
%temp=plot3(workspace.newestknownledge(:,1),workspace.newestknownledge(:,2),workspace.newestknownledge(:,3),'b*');
%pause(1);
%view(3);drawnow;pause(1);
%delete(temp);
%view(2);

%add the new points to the plot
%plot3(workspace.newestknownledge(:,1),workspace.newestknownledge(:,2),workspace.newestknownledge(:,3),'r*');
- Also delete the hold on command in explore which wassn't commented out, this could effect something CAREFULL
- Should check to see if the variable scan.ALLorigin is ever used other that being collected in explore
- Deleted the commented out text which showed details of the scan position on the GUI since it was annoying and didn't help
%text(scan.origin(1),scan.origin(2),scan.origin(3),strcat('Scan:',int2str(scan.tries+1),' - with pose:',num2str(scan.chosenview)));
- At the end of explore I was replotting the robot but I have deleted this
plotdenso(r, newQ, guiglobal.checkFF, guiglobal.plot_ellipse);
- Added a new function to calculate the weighting of obstacles then added this to be displayed in explore
obstacleweight=calobstacleweight();

% Print out the details of WEIGHTED known/unknown/obstacle knowledge
display(strcat('Weighted: New freespace knowledge is:',num2str(knownweight-previously_known),...
               ', Weighted Total Known Free:',num2str(knownweight), ', Weighted Obsticles:',num2str(obstacleweight),...
               ' Remaining Weighted Unknown withing workspace:',num2str(unknownweight));
- Now the total knowledge it known (free) + indexedobstacles
- in exGUI changed what happens after an error in exploration where it resets the Q you must be using a real robot (checkbox on GUI) to call use_real_robot_GETJs
- Removed the global guiglobal from explore since it isn't used anymore
- if get(handles.useRealRobot_checkbox,'Value')==1;  use_real_robot_GETJs();end   
- The index of unknowncoords was not correct so when comparing the sets of known/obstacle with unknown there were rounding errors so added this to setupworkspace and removed the commented stuff
%round to the correct index
workspace.unknowncoords=round(workspace.unknowncoords/workspace.inc_size)*workspace.inc_size;

[workspace.lev1unknown,level2_un,level3_un]=GetImpLevInfo(workspace.unknowncoords);
workspace.unknowncoords=workspace.unknowncoords(level3_un,:);

% % get rid of the points around the crouching positon robot bottom known to be safe
% index=find((workspace.unknowncoords(:,1)<workspace.robotsize(1,2) & workspace.unknowncoords(:,1)>workspace.robotsize(1,1)) &...
%            (workspace.unknowncoords(:,2)<workspace.robotsize(2,2) & workspace.unknowncoords(:,2)>workspace.robotsize(2,1)) &...
%             workspace.unknowncoords(:,3)<workspace.robotsize(3,2));
% newindex=setdiff([1:size(workspace.unknowncoords,1)]',index);
% workspace.unknowncoords=workspace.unknowncoords(newindex,:);

% %This is used in check robot so it dosen't have to do thos calculation everytime
% [workspace.lev1unknown]=GetImpLevInfo(workspace.unknowncoords);
- In exGUI show_unknown: Since the robot size was being included as unknown in the plotting changed it so we use GetImpLev function instead
a=round(   workspace.unknowncoords(GetImpLevInfo(workspace.unknowncoords)   ,:)/workspace.inc_size);
b=round(     workspace.knowncoords(GetImpLevInfo(workspace.knowncoords)     ,:)/workspace.inc_size);
c=round(workspace.indexedobsticles(GetImpLevInfo(workspace.indexedobsticles),:)/workspace.inc_size);

%     a=round(workspace.unknowncoords(workspace.lev1unknown,:)/workspace.inc_size);
%     b=round(workspace.knowncoords(GetImpLevInfo(workspace.knowncoords),:)/workspace.inc_size);
% %     c=round(workspace.indexedobsticles(GetImpLevInfo(workspace.indexedobsticles),:)/workspace.inc_size);
%     c=round(workspace.indexedobsticles/workspace.inc_size);

- Added this to the setupworkspace where we make sure that unknown coords within the known robot space are not included
before we used to assume that the bottom of robot was min space too
workspace.unknowncoords(:,3)<workspace.robotsize(3,1)
so now it is
index=find((workspace.unknowncoords(:,1)<workspace.robotsize(1,2) & workspace.unknowncoords(:,1)>workspace.robotsize(1,1)) &...
           (workspace.unknowncoords(:,2)<workspace.robotsize(2,2) & workspace.unknowncoords(:,2)>workspace.robotsize(2,1)) &...
           (workspace.unknowncoords(:,3)<workspace.robotsize(3,2) & workspace.unknowncoords(:,3)>workspace.robotsize(3,1)));
- Deleted this out of NBV.m since it wasn't being used but was to check that the updating was working properly
temp=setdiff(nbv_volume(tr,bestviews(cur_view).Q), workspace.knowncoords,'rows')


28/9/2007 Friday
- The formula in organise data for the angle was still incorrect, it was
maxangle=acos(...
              sqrt(...
                   1-(...
                      (workspace.inc_size/numpntsInCube)/(sqrt(2)*maxdist)...%used to be scan.size %%Now it will be AT LEAST scan size but maybe bigger
                      )^2 ...
                   )...
              );
However there is no need for the sqrt of everything in the acos
maxangle=acos(...            
               1-(...
                  (workspace.inc_size/numpntsInCube)/(sqrt(2)*maxdist)...%used to be scan.size %%Now it will be AT LEAST scan size but maybe bigger
                  )^2 ...
              );
- In the %% Go through each valid row (where dist>0) of organise data removed all the commented out inbetweenpoint= lines, go to previous version for this included	
- removed the commented out plotting commands thatwere in here
- Removed more plotting commands of the resulting ice_cream_bounds
%plot it up (obsticles) also should add the surfaces made)
% hold on;
%plot3(ice_cream_bounds_NOSELF(:,1),ice_cream_bounds_NOSELF(:,2),ice_cream_bounds_NOSELF(:,3),'b.')
- Removed this line form nbv_volume since it was commented out
% [obstructingPNTS,plane_index]=intersect(plane_homepnts, points,'rows');
- removed this comment since I don't know if it will be used
%EVENTUALLY
            %also if there are obsticles then there is high probability
            %that surrounding (unknown areas) are also obsticles
- Removed the commented out stuff in nbv_volume which was an incorrect r value
%             r_var=[points_on_oposite_side(:,1)-current_scan_origin(1),...
%                    points_on_oposite_side(:,2)-current_scan_origin(2),...
%                    points_on_oposite_side(:,3)-current_scan_origin(3)];
- Also the incorrect t_val
%             t_var=( -(...
%                       plane_equ(i,1)*current_scan_origin(1)+...
%                       plane_equ(i,2)*current_scan_origin(2)+...
%                       plane_equ(i,3)*current_scan_origin(3)...
%                       )+ plane_equ(i,4)...
%                     )./...
%                     bottomof_t_var;                               
- And the incorrect intersect points
    %         intersectionPNTs=points_on_oposite_side+[t_var.*r_var(:,1),...
    %                                                  t_var.*r_var(:,2),...
    %                                                  t_var.*r_var(:,3)];
- Removed this commented out section of NBV.m where it used to delete the handles of each bestview
- Since now in NBV I am only selecting one pose for each position I don't need the unique function like this
random_poses=unique(ceil((rand(1,1)*8)));
it can be just
random_poses=ceil((rand(1,1)*8));
- Changed this line in use_real_robot_MOVE from (6->2) because since joint 6 dosen't move it dosen't make sense that we chack this
        if (rob_h.JointState(2)<-60 || tempQ(6)<-60)
        if (rob_h.JointState(2)<-60 || tempQ(2)<-60)

- Commented out this variable
% scan.tiltstouse=2;
of setupscanner because I don't think it is actually ever used. Should grep for this

29/9/2007 Saturday
- Removed all the old redundant commented out variables in setuprobot.m
- Removed the commented out old more complicated lsqonlin since we dont use many variables that were passed back
% [dq,resnorm,residual,exitFlag,output,lambda,jacobian] = lsqnonlin(@costComponents, xGuess, lb, ub, options);    
- Also got simpler costComponents function in stream_onto_min_manystarts
%     function [e,J]=costComponents(dq)
- Delete the plotting stuff that was commmented out in this function
%delete plotting shit        
% plot(r,q_temp','joints');hold on; 
% % temp(1)=plot3(tr(1,1)+tr(1,4),tr(2,1)+tr(2,4),tr(3,1)+tr(3,4),'r*');
% % temp(2)=plot3(tr(1,2)+tr(1,4),tr(2,2)+tr(2,4),tr(3,2)+tr(3,4),'g*');  
% temp(3)=plot3(tr(1,3)+tr(1,4),tr(2,3)+tr(2,4),tr(3,3)+tr(3,4),'b*');
% temp(4)=plot3(actual_targ(1),actual_targ(2),actual_targ(3),'y*');
% temp(5)=plot3(desired_targ(1),desired_targ(2),desired_targ(3),'black*');
% temp(6)=plot3(ZpointAT(1),ZpointAT(2),ZpointAT(3),'m*'); 
% temp(7)=plot3(pt(1),pt(2),pt(3),'r*'); 
% drawnow
% % display(strcat('dist desired_targ-> ZpointAT=',num2str(sqrt((desired_targ(1)-ZpointAT(1))^2+(desired_targ(2)-ZpointAT(2))^2+(desired_targ(3)-ZpointAT(3))^2))));
% % display(strcat('dist actual_targ-> actualZpoint=',num2str(sqrt((actual_targ(1)-(tr(1,3)+tr(1,4)))^2+(actual_targ(2)-(tr(2,3)+tr(2,4)))^2+(actual_targ(3)-(tr(3,3)+tr(3,4)))^2))));
% display(strcat('dist desired_targ-> actual_targ=',num2str(sqrt((desired_targ(1)-actual_targ(1))^2+(desired_targ(2)-actual_targ(2))^2+(desired_targ(3)-actual_targ(3))^2))));
% display(strcat('dist desired Z point -> actualZpoint=',num2str(sqrt((ZpointAT(1)-(tr(1,3)+tr(1,4)))^2+(ZpointAT(2)-(tr(2,3)+tr(2,4)))^2+(ZpointAT(3)-(tr(3,3)+tr(3,4)))^2))));
%delete plotting shit


2/10/2007 Tuesday
- Removed from surface_making_simple the ability to pass in PointData that is not in the 3 by many cartisian points form I used to allow it to be as a data block, this was when the classification didn't return a block
%% puts back in original form
if size(PointData,3)>1
    %assign points to a plane they belong to, remember they could belong to
    %more than one plane and this will only assign them to one of these
    point_belongs_to=zeros([size(scan_data,1),1]);
    for i=1:size(plane,2);  point_belongs_to(plane(i).points)=i; end
    
    originalmat=zeros([size(PointData,1),size(PointData,2)]);
    for i=1:size(originalmat,1)
        originalmat(i,1:size(originalmat,2))=point_belongs_to((i-1)*size(originalmat,2)+1:i*size(originalmat,2))';
    end
    %shows the intensity image
    %imshow(originalmat/max(max(originalmat)));
end
- This may be needed later however if you go back to previous versions it will be in here, for now it is not

3/10/2007 Wednesday
- Deleted streamOnto_mine_nodirection.m go to previous versions (before 12:00 this day)


4/10/2007 Thursday
- Finished first version of sourceforge project be put online for sharing

5/10/2007 Friday
- Fixed up the comments
- Removed the old scanning command and added the new mesh commands
%     robscan_h=actxserver('EyeInHand.ScannerCommand');
    %give it an initial pose for base position)
    robscan_h=robmap_h.ScannerCommand(eye(4));
%     %this function handles the data coming back from the laser object
%     robscan_h.registerevent(@myhandler);
- The NBV doesn't work properly since it can't estimate how much new knowledge it is back to front, I think the inverse kinematics still works properly
----ON THE ROBOT
- Fixed up a logic error in scan function where if no data was there straight away it would still give an error because it was breaking to the correct possition, new code is
%checks that there still really is no data coming back
        if ~isempty(PointData); 
            display('Data came back eventually');
            attemptingscan=0; 
        else
            release_scanner(robscan_h);
            error('No Data coming back ... Giving up');             
        end    
- In use_real_robot_MOVE changed the soft limit check from being hard coded to calling the function written specifically for this purpose
%% Check that no steps exceed soft limits
if ~joint_softlimit_check(all_steps)
- When we check path for collision we intially had result to be 1 however if we return out because of asoft motion error it will still allow this path so change it to add result =0
if ~joint_softlimit_check(all_steps)
    result=0;
    return;
end
- Changed the 3rd default scan position so that it could see the beam
default_Q=[default_Q;[0,-88*pi/180,98*pi/180,0,-15*pi/180,0]];
- Added this so we can exit out of the main look exploiration when there is an error
if want_to_continue==0; error('User chose to exit');end
- Made a new funtion to do the releasing because it wasn't releasing the stopdrivejointabs properly in the use_real_robot_MOVE
%% FUNCTION release the robot object
function releaserobot(rob_h)

    pause(0.1);
    rob_h.Type='StopDriveJointAbs';
    rob_h.Start;
    rob_h.WaitUntilCompleted(0.5,0)
    rob_h.release;
- commented this out for the time being since it isn't useful
%threeDMedianFilt();
- Changed the size of the base platform to be 1 cube size up not 2
workspace.impLev(1).z=[workspace.inc_size,1.5];
- Deleted the workspace.mat variable because it was big and never used the good variable is the testing5 one and it has a very good map
- I should also save one of stephens meshes and try and use it for my surface making and then have this fed into the planning process

8/10/2007 Monday
- Added extra features to the GUI and removed the ability to choose where to explore since it wasn't used
- Temp change to make elipses bigger, see if we can still get a path
params=params*1.10;
params=params+sum(params)/3*0.10;
- Seems to be able to get a bit of a safer path
- CHnaged exGUI so that it would't try and go through as many best views now it has 6 steps which means there should be 2 NBV calculations
    for stepcount=stepcount+1:6;
- Added to check path so that it wont check the first 2 pieces
        if piece>1
before it does the check_FF

15/10/2007 Monday
- Fixed an error with the nbv_beta so it now saves the invalid ones properly